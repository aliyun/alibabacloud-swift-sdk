import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class DentryAppPropertiesValue : Tea.TeaModel {
    public var name: String?

    public var value: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DentriesAppPropertiesValue : Tea.TeaModel {
    public var name: String?

    public var value: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class AddAttendeeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddAttendeeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddAttendeeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddAttendeeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddAttendeeRequest : Tea.TeaModel {
    public class AttendeesToAdd : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public var attendeesToAdd: [AddAttendeeRequest.AttendeesToAdd]?

    public var calendarId: String?

    public var eventId: String?

    public var chatNotification: Bool?

    public var pushNotification: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToAdd != nil {
            var tmp : [Any] = []
            for k in self.attendeesToAdd! {
                tmp.append(k.toMap())
            }
            map["AttendeesToAdd"] = tmp
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.chatNotification != nil {
            map["chatNotification"] = self.chatNotification!
        }
        if self.pushNotification != nil {
            map["pushNotification"] = self.pushNotification!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToAdd") {
            var tmp : [AddAttendeeRequest.AttendeesToAdd] = []
            for v in dict["AttendeesToAdd"] as! [Any] {
                var model = AddAttendeeRequest.AttendeesToAdd()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendeesToAdd = tmp
        }
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("chatNotification") {
            self.chatNotification = dict["chatNotification"] as! Bool
        }
        if dict.keys.contains("pushNotification") {
            self.pushNotification = dict["pushNotification"] as! Bool
        }
    }
}

public class AddAttendeeShrinkRequest : Tea.TeaModel {
    public var attendeesToAddShrink: String?

    public var calendarId: String?

    public var eventId: String?

    public var chatNotification: Bool?

    public var pushNotification: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToAddShrink != nil {
            map["AttendeesToAdd"] = self.attendeesToAddShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.chatNotification != nil {
            map["chatNotification"] = self.chatNotification!
        }
        if self.pushNotification != nil {
            map["pushNotification"] = self.pushNotification!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToAdd") {
            self.attendeesToAddShrink = dict["AttendeesToAdd"] as! String
        }
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("chatNotification") {
            self.chatNotification = dict["chatNotification"] as! Bool
        }
        if dict.keys.contains("pushNotification") {
            self.pushNotification = dict["pushNotification"] as! Bool
        }
    }
}

public class AddAttendeeResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! Any
            }
        }
    }
    public var content: AddAttendeeResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["ErrorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = AddAttendeeResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorCtx") {
            self.errorCtx = dict["ErrorCtx"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAttendeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAttendeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAttendeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDriveSpaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddDriveSpaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddDriveSpaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddDriveSpaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddDriveSpaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var tenantContext: AddDriveSpaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = AddDriveSpaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class AddDriveSpaceShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class AddDriveSpaceResponseBody : Tea.TeaModel {
    public var createTime: String?

    public var modifyTime: String?

    public var permissionMode: String?

    public var quota: Int64?

    public var requestId: String?

    public var spaceId: String?

    public var spaceName: String?

    public var spaceType: String?

    public var usedQuota: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.modifyTime != nil {
            map["modifyTime"] = self.modifyTime!
        }
        if self.permissionMode != nil {
            map["permissionMode"] = self.permissionMode!
        }
        if self.quota != nil {
            map["quota"] = self.quota!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.spaceId != nil {
            map["spaceId"] = self.spaceId!
        }
        if self.spaceName != nil {
            map["spaceName"] = self.spaceName!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.usedQuota != nil {
            map["usedQuota"] = self.usedQuota!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("modifyTime") {
            self.modifyTime = dict["modifyTime"] as! String
        }
        if dict.keys.contains("permissionMode") {
            self.permissionMode = dict["permissionMode"] as! String
        }
        if dict.keys.contains("quota") {
            self.quota = dict["quota"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("spaceId") {
            self.spaceId = dict["spaceId"] as! String
        }
        if dict.keys.contains("spaceName") {
            self.spaceName = dict["spaceName"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
        if dict.keys.contains("usedQuota") {
            self.usedQuota = dict["usedQuota"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class AddDriveSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDriveSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDriveSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMeetingRoomsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddMeetingRoomsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddMeetingRoomsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddMeetingRoomsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddMeetingRoomsRequest : Tea.TeaModel {
    public class MeetingRoomsToAdd : Tea.TeaModel {
        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToAdd: [AddMeetingRoomsRequest.MeetingRoomsToAdd]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToAdd != nil {
            var tmp : [Any] = []
            for k in self.meetingRoomsToAdd! {
                tmp.append(k.toMap())
            }
            map["MeetingRoomsToAdd"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToAdd") {
            var tmp : [AddMeetingRoomsRequest.MeetingRoomsToAdd] = []
            for v in dict["MeetingRoomsToAdd"] as! [Any] {
                var model = AddMeetingRoomsRequest.MeetingRoomsToAdd()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRoomsToAdd = tmp
        }
    }
}

public class AddMeetingRoomsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToAddShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToAddShrink != nil {
            map["MeetingRoomsToAdd"] = self.meetingRoomsToAddShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToAdd") {
            self.meetingRoomsToAddShrink = dict["MeetingRoomsToAdd"] as! String
        }
    }
}

public class AddMeetingRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class AddMeetingRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMeetingRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMeetingRoomsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddRecordPermissionHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddRecordPermissionHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddRecordPermissionHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddRecordPermissionShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddRecordPermissionRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var bizType: String?

    public var conferenceId: String?

    public var tenantContext: AddRecordPermissionRequest.TenantContext?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ConferenceId") {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = AddRecordPermissionRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddRecordPermissionShrinkRequest : Tea.TeaModel {
    public var bizType: String?

    public var conferenceId: String?

    public var tenantContextShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ConferenceId") {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddRecordPermissionResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class AddRecordPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRecordPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddRecordPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddScenegroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddScenegroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddScenegroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddScenegroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddScenegroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class AddScenegroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddScenegroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddScenegroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddScenegroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTicketMemoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddTicketMemoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddTicketMemoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddTicketMemoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddTicketMemoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class TicketMemo : Tea.TeaModel {
        public class Attachments : Tea.TeaModel {
            public var fileName: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
            }
        }
        public var attachments: [AddTicketMemoRequest.TicketMemo.Attachments]?

        public var memo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachments != nil {
                var tmp : [Any] = []
                for k in self.attachments! {
                    tmp.append(k.toMap())
                }
                map["Attachments"] = tmp
            }
            if self.memo != nil {
                map["Memo"] = self.memo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attachments") {
                var tmp : [AddTicketMemoRequest.TicketMemo.Attachments] = []
                for v in dict["Attachments"] as! [Any] {
                    var model = AddTicketMemoRequest.TicketMemo.Attachments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachments = tmp
            }
            if dict.keys.contains("Memo") {
                self.memo = dict["Memo"] as! String
            }
        }
    }
    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContext: AddTicketMemoRequest.TenantContext?

    public var ticketMemo: AddTicketMemoRequest.TicketMemo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
        try self.ticketMemo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.ticketMemo != nil {
            map["TicketMemo"] = self.ticketMemo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = AddTicketMemoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("TicketMemo") {
            var model = AddTicketMemoRequest.TicketMemo()
            model.fromMap(dict["TicketMemo"] as! [String: Any])
            self.ticketMemo = model
        }
    }
}

public class AddTicketMemoShrinkRequest : Tea.TeaModel {
    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContextShrink: String?

    public var ticketMemoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.ticketMemoShrink != nil {
            map["TicketMemo"] = self.ticketMemoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("TicketMemo") {
            self.ticketMemoShrink = dict["TicketMemo"] as! String
        }
    }
}

public class AddTicketMemoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class AddTicketMemoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTicketMemoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTicketMemoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var description_: String?

        public var teamId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var option: AddWorkspaceRequest.Option?

    public var tenantContext: AddWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") {
            var model = AddWorkspaceRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") {
            var model = AddWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class AddWorkspaceShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var optionShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class AddWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: AddWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                var model = AddWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: AddWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") {
            var model = AddWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class AddWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [AddWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: AddWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [AddWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = AddWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AddWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [AddWorkspaceMembersRequest.Members]?

    public var tenantContext: AddWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [AddWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") {
            var model = AddWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceMembersResponseBody : Tea.TeaModel {
    public var notInOrgList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notInOrgList != nil {
            map["NotInOrgList"] = self.notInOrgList!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotInOrgList") {
            self.notInOrgList = dict["NotInOrgList"] as! [String]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignTicketHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AssignTicketHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = AssignTicketHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AssignTicketShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AssignTicketRequest : Tea.TeaModel {
    public class Notify : Tea.TeaModel {
        public var groupNoticeReceiverUserIds: [String]?

        public var noticeAllGroupMember: Bool?

        public var workNoticeReceiverUserIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupNoticeReceiverUserIds != nil {
                map["GroupNoticeReceiverUserIds"] = self.groupNoticeReceiverUserIds!
            }
            if self.noticeAllGroupMember != nil {
                map["NoticeAllGroupMember"] = self.noticeAllGroupMember!
            }
            if self.workNoticeReceiverUserIds != nil {
                map["WorkNoticeReceiverUserIds"] = self.workNoticeReceiverUserIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupNoticeReceiverUserIds") {
                self.groupNoticeReceiverUserIds = dict["GroupNoticeReceiverUserIds"] as! [String]
            }
            if dict.keys.contains("NoticeAllGroupMember") {
                self.noticeAllGroupMember = dict["NoticeAllGroupMember"] as! Bool
            }
            if dict.keys.contains("WorkNoticeReceiverUserIds") {
                self.workNoticeReceiverUserIds = dict["WorkNoticeReceiverUserIds"] as! [String]
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class TicketMemo : Tea.TeaModel {
        public class Attachments : Tea.TeaModel {
            public var fileName: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
            }
        }
        public var attachments: [AssignTicketRequest.TicketMemo.Attachments]?

        public var memo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachments != nil {
                var tmp : [Any] = []
                for k in self.attachments! {
                    tmp.append(k.toMap())
                }
                map["Attachments"] = tmp
            }
            if self.memo != nil {
                map["Memo"] = self.memo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attachments") {
                var tmp : [AssignTicketRequest.TicketMemo.Attachments] = []
                for v in dict["Attachments"] as! [Any] {
                    var model = AssignTicketRequest.TicketMemo.Attachments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachments = tmp
            }
            if dict.keys.contains("Memo") {
                self.memo = dict["Memo"] as! String
            }
        }
    }
    public var notify: AssignTicketRequest.Notify?

    public var openTeamId: String?

    public var openTicketId: String?

    public var processorUserIds: [String]?

    public var tenantContext: AssignTicketRequest.TenantContext?

    public var ticketMemo: AssignTicketRequest.TicketMemo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notify?.validate()
        try self.tenantContext?.validate()
        try self.ticketMemo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notify != nil {
            map["Notify"] = self.notify?.toMap()
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.processorUserIds != nil {
            map["ProcessorUserIds"] = self.processorUserIds!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.ticketMemo != nil {
            map["TicketMemo"] = self.ticketMemo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Notify") {
            var model = AssignTicketRequest.Notify()
            model.fromMap(dict["Notify"] as! [String: Any])
            self.notify = model
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("ProcessorUserIds") {
            self.processorUserIds = dict["ProcessorUserIds"] as! [String]
        }
        if dict.keys.contains("TenantContext") {
            var model = AssignTicketRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("TicketMemo") {
            var model = AssignTicketRequest.TicketMemo()
            model.fromMap(dict["TicketMemo"] as! [String: Any])
            self.ticketMemo = model
        }
    }
}

public class AssignTicketShrinkRequest : Tea.TeaModel {
    public var notifyShrink: String?

    public var openTeamId: String?

    public var openTicketId: String?

    public var processorUserIdsShrink: String?

    public var tenantContextShrink: String?

    public var ticketMemoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notifyShrink != nil {
            map["Notify"] = self.notifyShrink!
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.processorUserIdsShrink != nil {
            map["ProcessorUserIds"] = self.processorUserIdsShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.ticketMemoShrink != nil {
            map["TicketMemo"] = self.ticketMemoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Notify") {
            self.notifyShrink = dict["Notify"] as! String
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("ProcessorUserIds") {
            self.processorUserIdsShrink = dict["ProcessorUserIds"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("TicketMemo") {
            self.ticketMemoShrink = dict["TicketMemo"] as! String
        }
    }
}

public class AssignTicketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class AssignTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssignTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchGetFormDataByIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchGetFormDataByIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = BatchGetFormDataByIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchGetFormDataByIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchGetFormDataByIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var needFormInstanceValue: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.needFormInstanceValue != nil {
            map["NeedFormInstanceValue"] = self.needFormInstanceValue!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("NeedFormInstanceValue") {
            self.needFormInstanceValue = dict["NeedFormInstanceValue"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchGetFormDataByIdListShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var needFormInstanceValue: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.needFormInstanceValue != nil {
            map["NeedFormInstanceValue"] = self.needFormInstanceValue!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("NeedFormInstanceValue") {
            self.needFormInstanceValue = dict["NeedFormInstanceValue"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchGetFormDataByIdListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: BatchGetFormDataByIdListResponseBody.Result.ModifyUser.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    var model = BatchGetFormDataByIdListResponseBody.Result.ModifyUser.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: BatchGetFormDataByIdListResponseBody.Result.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    var model = BatchGetFormDataByIdListResponseBody.Result.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var id: Int64?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var modifier: String?

        public var modifyUser: BatchGetFormDataByIdListResponseBody.Result.ModifyUser?

        public var originator: BatchGetFormDataByIdListResponseBody.Result.Originator?

        public var sequence: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormData") {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceValue") {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Modifier") {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("ModifyUser") {
                var model = BatchGetFormDataByIdListResponseBody.Result.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") {
                var model = BatchGetFormDataByIdListResponseBody.Result.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [BatchGetFormDataByIdListResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [BatchGetFormDataByIdListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = BatchGetFormDataByIdListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchGetFormDataByIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetFormDataByIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchGetFormDataByIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchRemovalByFormInstanceIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchRemovalByFormInstanceIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = BatchRemovalByFormInstanceIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchRemovalByFormInstanceIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var executeExpression: Bool?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.executeExpression != nil {
            map["ExecuteExpression"] = self.executeExpression!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("ExecuteExpression") {
            self.executeExpression = dict["ExecuteExpression"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var executeExpression: Bool?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.executeExpression != nil {
            map["ExecuteExpression"] = self.executeExpression!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("ExecuteExpression") {
            self.executeExpression = dict["ExecuteExpression"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchRemovalByFormInstanceIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchRemovalByFormInstanceIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchSaveFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchSaveFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = BatchSaveFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchSaveFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchSaveFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formDataJsonList: [String]?

    public var formUuid: String?

    public var keepRunningAfterException: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formDataJsonList != nil {
            map["FormDataJsonList"] = self.formDataJsonList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.keepRunningAfterException != nil {
            map["KeepRunningAfterException"] = self.keepRunningAfterException!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormDataJsonList") {
            self.formDataJsonList = dict["FormDataJsonList"] as! [String]
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("KeepRunningAfterException") {
            self.keepRunningAfterException = dict["KeepRunningAfterException"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchSaveFormDataShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formDataJsonListShrink: String?

    public var formUuid: String?

    public var keepRunningAfterException: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formDataJsonListShrink != nil {
            map["FormDataJsonList"] = self.formDataJsonListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.keepRunningAfterException != nil {
            map["KeepRunningAfterException"] = self.keepRunningAfterException!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormDataJsonList") {
            self.formDataJsonListShrink = dict["FormDataJsonList"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("KeepRunningAfterException") {
            self.keepRunningAfterException = dict["KeepRunningAfterException"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchSaveFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchSaveFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchSaveFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchSaveFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchUpdateFormDataByInstanceIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchUpdateFormDataByInstanceIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = BatchUpdateFormDataByInstanceIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchUpdateFormDataByInstanceIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceIdRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceIdShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchUpdateFormDataByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchUpdateFormDataByInstanceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchUpdateFormDataByInstanceMapHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchUpdateFormDataByInstanceMapHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = BatchUpdateFormDataByInstanceMapHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchUpdateFormDataByInstanceMapShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceMapRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJsonMap: [String: Any]?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJsonMap != nil {
            map["UpdateFormDataJsonMap"] = self.updateFormDataJsonMap!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJsonMap") {
            self.updateFormDataJsonMap = dict["UpdateFormDataJsonMap"] as! [String: Any]
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceMapShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJsonMapShrink: String?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJsonMapShrink != nil {
            map["UpdateFormDataJsonMap"] = self.updateFormDataJsonMapShrink!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJsonMap") {
            self.updateFormDataJsonMapShrink = dict["UpdateFormDataJsonMap"] as! String
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceMapResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchUpdateFormDataByInstanceMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchUpdateFormDataByInstanceMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CancelScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CancelScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CancelScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CancelScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var scheduleConferenceId: String?

    public var tenantContext: CancelScheduleConferenceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CancelScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CancelScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var scheduleConferenceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CancelScheduleConferenceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CancelScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckAlibabaStaffHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CheckAlibabaStaffHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CheckAlibabaStaffHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CheckAlibabaStaffShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CheckAlibabaStaffRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var mobile: String?

    public var tenantContext: CheckAlibabaStaffRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CheckAlibabaStaffRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CheckAlibabaStaffShrinkRequest : Tea.TeaModel {
    public var mobile: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CheckAlibabaStaffResponseBody : Tea.TeaModel {
    public var isAlibabaStaff: Bool?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isAlibabaStaff != nil {
            map["isAlibabaStaff"] = self.isAlibabaStaff!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("isAlibabaStaff") {
            self.isAlibabaStaff = dict["isAlibabaStaff"] as! Bool
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CheckAlibabaStaffResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckAlibabaStaffResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckAlibabaStaffResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckUserIsGroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CheckUserIsGroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CheckUserIsGroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CheckUserIsGroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CheckUserIsGroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
    }
}

public class CheckUserIsGroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CheckUserIsGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckUserIsGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckUserIsGroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ClearHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ClearHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ClearShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ClearRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: ClearRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ClearRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ClearResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ClearResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ClearDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ClearDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ClearDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ClearDataRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: ClearDataRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ClearDataRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearDataShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearDataResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ClearDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ClearDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseVideoConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CloseVideoConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CloseVideoConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CloseVideoConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CloseVideoConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: CloseVideoConferenceRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = CloseVideoConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class CloseVideoConferenceShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class CloseVideoConferenceResponseBody : Tea.TeaModel {
    public var cause: String?

    public var code: Int64?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cause != nil {
            map["cause"] = self.cause!
        }
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cause") {
            self.cause = dict["cause"] as! String
        }
        if dict.keys.contains("code") {
            self.code = dict["code"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CloseVideoConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseVideoConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseVideoConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CommentListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CommentListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CommentListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CommentListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CommentListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: CommentListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CommentListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CommentListReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CommentListReportResponseBody : Tea.TeaModel {
    public class Comments : Tea.TeaModel {
        public var content: String?

        public var createTime: String?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.userid != nil {
                map["Userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Userid") {
                self.userid = dict["Userid"] as! String
            }
        }
    }
    public var comments: [CommentListReportResponseBody.Comments]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comments != nil {
            var tmp : [Any] = []
            for k in self.comments! {
                tmp.append(k.toMap())
            }
            map["comments"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("comments") {
            var tmp : [CommentListReportResponseBody.Comments] = []
            for v in dict["comments"] as! [Any] {
                var model = CommentListReportResponseBody.Comments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.comments = tmp
        }
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CommentListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CommentListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CommentListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CommitFileHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CommitFileHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CommitFileHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CommitFileShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CommitFileRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public class AppProperties : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var appProperties: [CommitFileRequest.Option.AppProperties]?

        public var conflictStrategy: String?

        public var convertToOnlineDoc: Bool?

        public var convertToOnlineDocTargetDocumentType: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appProperties != nil {
                var tmp : [Any] = []
                for k in self.appProperties! {
                    tmp.append(k.toMap())
                }
                map["AppProperties"] = tmp
            }
            if self.conflictStrategy != nil {
                map["ConflictStrategy"] = self.conflictStrategy!
            }
            if self.convertToOnlineDoc != nil {
                map["ConvertToOnlineDoc"] = self.convertToOnlineDoc!
            }
            if self.convertToOnlineDocTargetDocumentType != nil {
                map["ConvertToOnlineDocTargetDocumentType"] = self.convertToOnlineDocTargetDocumentType!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppProperties") {
                var tmp : [CommitFileRequest.Option.AppProperties] = []
                for v in dict["AppProperties"] as! [Any] {
                    var model = CommitFileRequest.Option.AppProperties()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appProperties = tmp
            }
            if dict.keys.contains("ConflictStrategy") {
                self.conflictStrategy = dict["ConflictStrategy"] as! String
            }
            if dict.keys.contains("ConvertToOnlineDoc") {
                self.convertToOnlineDoc = dict["ConvertToOnlineDoc"] as! Bool
            }
            if dict.keys.contains("ConvertToOnlineDocTargetDocumentType") {
                self.convertToOnlineDocTargetDocumentType = dict["ConvertToOnlineDocTargetDocumentType"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var option: CommitFileRequest.Option?

    public var parentDentryUuid: String?

    public var tenantContext: CommitFileRequest.TenantContext?

    public var uploadKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.parentDentryUuid != nil {
            map["ParentDentryUuid"] = self.parentDentryUuid!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.uploadKey != nil {
            map["UploadKey"] = self.uploadKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") {
            var model = CommitFileRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("ParentDentryUuid") {
            self.parentDentryUuid = dict["ParentDentryUuid"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CommitFileRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UploadKey") {
            self.uploadKey = dict["UploadKey"] as! String
        }
    }
}

public class CommitFileShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var optionShrink: String?

    public var parentDentryUuid: String?

    public var tenantContextShrink: String?

    public var uploadKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.parentDentryUuid != nil {
            map["ParentDentryUuid"] = self.parentDentryUuid!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.uploadKey != nil {
            map["UploadKey"] = self.uploadKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("ParentDentryUuid") {
            self.parentDentryUuid = dict["ParentDentryUuid"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UploadKey") {
            self.uploadKey = dict["UploadKey"] as! String
        }
    }
}

public class CommitFileResponseBody : Tea.TeaModel {
    public class Dentry : Tea.TeaModel {
        public class Properties : Tea.TeaModel {
            public var readOnly: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
            }
        }
        public class Thumbnail : Tea.TeaModel {
            public var height: Int32?

            public var url: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var appProperties: [String: [DentryAppPropertiesValue]]?

        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var id: String?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var parentId: String?

        public var partitionType: String?

        public var path: String?

        public var properties: CommitFileResponseBody.Dentry.Properties?

        public var size: Int64?

        public var spaceId: String?

        public var status: String?

        public var storageDriver: String?

        public var thumbnail: CommitFileResponseBody.Dentry.Thumbnail?

        public var type: String?

        public var uuid: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.properties?.validate()
            try self.thumbnail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appProperties != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.appProperties! {
                    var l1 : [Any] = []
                    for k1 in v {
                        l1.append(k1.toMap())
                    }
                    tmp[k] = l1
                }
                map["AppProperties"] = tmp
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.partitionType != nil {
                map["PartitionType"] = self.partitionType!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.properties != nil {
                map["Properties"] = self.properties?.toMap()
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageDriver != nil {
                map["StorageDriver"] = self.storageDriver!
            }
            if self.thumbnail != nil {
                map["Thumbnail"] = self.thumbnail?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppProperties") {
                var tmp : [String: [DentryAppPropertiesValue]] = [:]
                for (k, v) in dict["AppProperties"] as! [String: Any] {
                    var l1 : [DentryAppPropertiesValue] = []
                    for v1 in v as! [Any] {
                        var model = DentryAppPropertiesValue()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp[k] = l1
                }
                self.appProperties = tmp
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! String
            }
            if dict.keys.contains("PartitionType") {
                self.partitionType = dict["PartitionType"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Properties") {
                var model = CommitFileResponseBody.Dentry.Properties()
                model.fromMap(dict["Properties"] as! [String: Any])
                self.properties = model
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageDriver") {
                self.storageDriver = dict["StorageDriver"] as! String
            }
            if dict.keys.contains("Thumbnail") {
                var model = CommitFileResponseBody.Dentry.Thumbnail()
                model.fromMap(dict["Thumbnail"] as! [String: Any])
                self.thumbnail = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var dentry: CommitFileResponseBody.Dentry?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dentry?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentry != nil {
            map["dentry"] = self.dentry?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dentry") {
            var model = CommitFileResponseBody.Dentry()
            model.fromMap(dict["dentry"] as! [String: Any])
            self.dentry = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CommitFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CommitFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CommitFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyDentryHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CopyDentryHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CopyDentryHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CopyDentryShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CopyDentryRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var name: String?

    public var spaceId: String?

    public var targetSpaceId: String?

    public var tenantContext: CopyDentryRequest.TenantContext?

    public var toNextDentryId: String?

    public var toParentDentryId: String?

    public var toPrevDentryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.targetSpaceId != nil {
            map["TargetSpaceId"] = self.targetSpaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.toNextDentryId != nil {
            map["ToNextDentryId"] = self.toNextDentryId!
        }
        if self.toParentDentryId != nil {
            map["ToParentDentryId"] = self.toParentDentryId!
        }
        if self.toPrevDentryId != nil {
            map["ToPrevDentryId"] = self.toPrevDentryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TargetSpaceId") {
            self.targetSpaceId = dict["TargetSpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CopyDentryRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("ToNextDentryId") {
            self.toNextDentryId = dict["ToNextDentryId"] as! String
        }
        if dict.keys.contains("ToParentDentryId") {
            self.toParentDentryId = dict["ToParentDentryId"] as! String
        }
        if dict.keys.contains("ToPrevDentryId") {
            self.toPrevDentryId = dict["ToPrevDentryId"] as! String
        }
    }
}

public class CopyDentryShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var name: String?

    public var spaceId: String?

    public var targetSpaceId: String?

    public var tenantContextShrink: String?

    public var toNextDentryId: String?

    public var toParentDentryId: String?

    public var toPrevDentryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.targetSpaceId != nil {
            map["TargetSpaceId"] = self.targetSpaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.toNextDentryId != nil {
            map["ToNextDentryId"] = self.toNextDentryId!
        }
        if self.toParentDentryId != nil {
            map["ToParentDentryId"] = self.toParentDentryId!
        }
        if self.toPrevDentryId != nil {
            map["ToPrevDentryId"] = self.toPrevDentryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TargetSpaceId") {
            self.targetSpaceId = dict["TargetSpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("ToNextDentryId") {
            self.toNextDentryId = dict["ToNextDentryId"] as! String
        }
        if dict.keys.contains("ToParentDentryId") {
            self.toParentDentryId = dict["ToParentDentryId"] as! String
        }
        if dict.keys.contains("ToPrevDentryId") {
            self.toPrevDentryId = dict["ToPrevDentryId"] as! String
        }
    }
}

public class CopyDentryResponseBody : Tea.TeaModel {
    public class LinkSourceInfo : Tea.TeaModel {
        public class IconUrl : Tea.TeaModel {
            public var line: String?

            public var small: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.small != nil {
                    map["Small"] = self.small!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Small") {
                    self.small = dict["Small"] as! String
                }
            }
        }
        public var extension_: String?

        public var iconUrl: CopyDentryResponseBody.LinkSourceInfo.IconUrl?

        public var id: String?

        public var linkType: Int64?

        public var spaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.iconUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.linkType != nil {
                map["LinkType"] = self.linkType!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("IconUrl") {
                var model = CopyDentryResponseBody.LinkSourceInfo.IconUrl()
                model.fromMap(dict["IconUrl"] as! [String: Any])
                self.iconUrl = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LinkType") {
                self.linkType = dict["LinkType"] as! Int64
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
        }
    }
    public class Space : Tea.TeaModel {
        public class HdIconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class IconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Owner : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class RecentList : Tea.TeaModel {
            public class Creator : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class LinkSourceInfo : Tea.TeaModel {
                public class IconUrl : Tea.TeaModel {
                    public var line: String?

                    public var small: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.small != nil {
                            map["Small"] = self.small!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Line") {
                            self.line = dict["Line"] as! String
                        }
                        if dict.keys.contains("Small") {
                            self.small = dict["Small"] as! String
                        }
                    }
                }
                public var extension_: String?

                public var iconUrl: CopyDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl?

                public var id: String?

                public var linkType: Int64?

                public var spaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.iconUrl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.iconUrl != nil {
                        map["IconUrl"] = self.iconUrl?.toMap()
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.linkType != nil {
                        map["LinkType"] = self.linkType!
                    }
                    if self.spaceId != nil {
                        map["SpaceId"] = self.spaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("IconUrl") {
                        var model = CopyDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl()
                        model.fromMap(dict["IconUrl"] as! [String: Any])
                        self.iconUrl = model
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("LinkType") {
                        self.linkType = dict["LinkType"] as! Int64
                    }
                    if dict.keys.contains("SpaceId") {
                        self.spaceId = dict["SpaceId"] as! String
                    }
                }
            }
            public class StatisticalInfo : Tea.TeaModel {
                public var wordCount: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.wordCount != nil {
                        map["WordCount"] = self.wordCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WordCount") {
                        self.wordCount = dict["WordCount"] as! Int64
                    }
                }
            }
            public class Updater : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var contentType: String?

            public var createdTime: Int64?

            public var creator: CopyDentryResponseBody.Space.RecentList.Creator?

            public var dentryId: String?

            public var dentryType: String?

            public var dentryUuid: String?

            public var docKey: String?

            public var extension_: String?

            public var hasChildren: Bool?

            public var linkSourceInfo: CopyDentryResponseBody.Space.RecentList.LinkSourceInfo?

            public var name: String?

            public var path: String?

            public var space: Any?

            public var spaceId: String?

            public var statisticalInfo: CopyDentryResponseBody.Space.RecentList.StatisticalInfo?

            public var updatedTime: Int64?

            public var updater: CopyDentryResponseBody.Space.RecentList.Updater?

            public var url: String?

            public var visitorInfo: CopyDentryResponseBody.Space.RecentList.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.creator?.validate()
                try self.linkSourceInfo?.validate()
                try self.statisticalInfo?.validate()
                try self.updater?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator?.toMap()
                }
                if self.dentryId != nil {
                    map["DentryId"] = self.dentryId!
                }
                if self.dentryType != nil {
                    map["DentryType"] = self.dentryType!
                }
                if self.dentryUuid != nil {
                    map["DentryUuid"] = self.dentryUuid!
                }
                if self.docKey != nil {
                    map["DocKey"] = self.docKey!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.hasChildren != nil {
                    map["HasChildren"] = self.hasChildren!
                }
                if self.linkSourceInfo != nil {
                    map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.space != nil {
                    map["Space"] = self.space!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                if self.statisticalInfo != nil {
                    map["StatisticalInfo"] = self.statisticalInfo?.toMap()
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.updater != nil {
                    map["Updater"] = self.updater?.toMap()
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentType") {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    var model = CopyDentryResponseBody.Space.RecentList.Creator()
                    model.fromMap(dict["Creator"] as! [String: Any])
                    self.creator = model
                }
                if dict.keys.contains("DentryId") {
                    self.dentryId = dict["DentryId"] as! String
                }
                if dict.keys.contains("DentryType") {
                    self.dentryType = dict["DentryType"] as! String
                }
                if dict.keys.contains("DentryUuid") {
                    self.dentryUuid = dict["DentryUuid"] as! String
                }
                if dict.keys.contains("DocKey") {
                    self.docKey = dict["DocKey"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("HasChildren") {
                    self.hasChildren = dict["HasChildren"] as! Bool
                }
                if dict.keys.contains("LinkSourceInfo") {
                    var model = CopyDentryResponseBody.Space.RecentList.LinkSourceInfo()
                    model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                    self.linkSourceInfo = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Space") {
                    self.space = dict["Space"] as! Any
                }
                if dict.keys.contains("SpaceId") {
                    self.spaceId = dict["SpaceId"] as! String
                }
                if dict.keys.contains("StatisticalInfo") {
                    var model = CopyDentryResponseBody.Space.RecentList.StatisticalInfo()
                    model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                    self.statisticalInfo = model
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
                if dict.keys.contains("Updater") {
                    var model = CopyDentryResponseBody.Space.RecentList.Updater()
                    model.fromMap(dict["Updater"] as! [String: Any])
                    self.updater = model
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") {
                    var model = CopyDentryResponseBody.Space.RecentList.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var cover: String?

        public var description_: String?

        public var hdIconVO: CopyDentryResponseBody.Space.HdIconVO?

        public var iconVO: CopyDentryResponseBody.Space.IconVO?

        public var id: String?

        public var name: String?

        public var owner: CopyDentryResponseBody.Space.Owner?

        public var recentList: [CopyDentryResponseBody.Space.RecentList]?

        public var type: Int32?

        public var url: String?

        public var visitorInfo: CopyDentryResponseBody.Space.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.hdIconVO?.validate()
            try self.iconVO?.validate()
            try self.owner?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hdIconVO != nil {
                map["HdIconVO"] = self.hdIconVO?.toMap()
            }
            if self.iconVO != nil {
                map["IconVO"] = self.iconVO?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner?.toMap()
            }
            if self.recentList != nil {
                var tmp : [Any] = []
                for k in self.recentList! {
                    tmp.append(k.toMap())
                }
                map["RecentList"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("HdIconVO") {
                var model = CopyDentryResponseBody.Space.HdIconVO()
                model.fromMap(dict["HdIconVO"] as! [String: Any])
                self.hdIconVO = model
            }
            if dict.keys.contains("IconVO") {
                var model = CopyDentryResponseBody.Space.IconVO()
                model.fromMap(dict["IconVO"] as! [String: Any])
                self.iconVO = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                var model = CopyDentryResponseBody.Space.Owner()
                model.fromMap(dict["Owner"] as! [String: Any])
                self.owner = model
            }
            if dict.keys.contains("RecentList") {
                var tmp : [CopyDentryResponseBody.Space.RecentList] = []
                for v in dict["RecentList"] as! [Any] {
                    var model = CopyDentryResponseBody.Space.RecentList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recentList = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") {
                var model = CopyDentryResponseBody.Space.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public var contentType: String?

    public var createdTime: Int64?

    public var creator: [String: Any]?

    public var dentryId: String?

    public var dentryType: String?

    public var dentryUuid: String?

    public var docKey: String?

    public var extension_: String?

    public var hasChildren: Bool?

    public var linkSourceInfo: CopyDentryResponseBody.LinkSourceInfo?

    public var name: String?

    public var path: String?

    public var requestId: String?

    public var space: CopyDentryResponseBody.Space?

    public var spaceId: String?

    public var updatedTime: Int64?

    public var updater: [String: Any]?

    public var url: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public var visitorInfo: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.linkSourceInfo?.validate()
        try self.space?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentType != nil {
            map["contentType"] = self.contentType!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creator != nil {
            map["creator"] = self.creator!
        }
        if self.dentryId != nil {
            map["dentryId"] = self.dentryId!
        }
        if self.dentryType != nil {
            map["dentryType"] = self.dentryType!
        }
        if self.dentryUuid != nil {
            map["dentryUuid"] = self.dentryUuid!
        }
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hasChildren != nil {
            map["hasChildren"] = self.hasChildren!
        }
        if self.linkSourceInfo != nil {
            map["linkSourceInfo"] = self.linkSourceInfo?.toMap()
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.space != nil {
            map["space"] = self.space?.toMap()
        }
        if self.spaceId != nil {
            map["spaceId"] = self.spaceId!
        }
        if self.updatedTime != nil {
            map["updatedTime"] = self.updatedTime!
        }
        if self.updater != nil {
            map["updater"] = self.updater!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        if self.visitorInfo != nil {
            map["visitorInfo"] = self.visitorInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("contentType") {
            self.contentType = dict["contentType"] as! String
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creator") {
            self.creator = dict["creator"] as! [String: Any]
        }
        if dict.keys.contains("dentryId") {
            self.dentryId = dict["dentryId"] as! String
        }
        if dict.keys.contains("dentryType") {
            self.dentryType = dict["dentryType"] as! String
        }
        if dict.keys.contains("dentryUuid") {
            self.dentryUuid = dict["dentryUuid"] as! String
        }
        if dict.keys.contains("docKey") {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("extension") {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hasChildren") {
            self.hasChildren = dict["hasChildren"] as! Bool
        }
        if dict.keys.contains("linkSourceInfo") {
            var model = CopyDentryResponseBody.LinkSourceInfo()
            model.fromMap(dict["linkSourceInfo"] as! [String: Any])
            self.linkSourceInfo = model
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("space") {
            var model = CopyDentryResponseBody.Space()
            model.fromMap(dict["space"] as! [String: Any])
            self.space = model
        }
        if dict.keys.contains("spaceId") {
            self.spaceId = dict["spaceId"] as! String
        }
        if dict.keys.contains("updatedTime") {
            self.updatedTime = dict["updatedTime"] as! Int64
        }
        if dict.keys.contains("updater") {
            self.updater = dict["updater"] as! [String: Any]
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
        if dict.keys.contains("visitorInfo") {
            self.visitorInfo = dict["visitorInfo"] as! [String: Any]
        }
    }
}

public class CopyDentryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyDentryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyDentryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDeliveryPlanHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var userToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userToken != nil {
                map["userToken"] = self.userToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("userToken") {
                self.userToken = dict["userToken"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateDeliveryPlanHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateDeliveryPlanHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateDeliveryPlanShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateDeliveryPlanRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContext: CreateDeliveryPlanRequest.TenantContext?

    public var userIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateDeliveryPlanRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserIdList") {
            self.userIdList = dict["UserIdList"] as! [String]
        }
    }
}

public class CreateDeliveryPlanShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var userIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userIdListShrink != nil {
            map["UserIdList"] = self.userIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdListShrink = dict["UserIdList"] as! String
        }
    }
}

public class CreateDeliveryPlanResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateDeliveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeliveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDeliveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDingtalkPersonalTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateDingtalkPersonalTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateDingtalkPersonalTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateDingtalkPersonalTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateDingtalkPersonalTodoTaskRequest : Tea.TeaModel {
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["DingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingNotify") {
                self.dingNotify = dict["DingNotify"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var description_: String?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var notifyConfigs: CreateDingtalkPersonalTodoTaskRequest.NotifyConfigs?

    public var participantIds: [String]?

    public var subject: String?

    public var tenantContext: CreateDingtalkPersonalTodoTaskRequest.TenantContext?

    public var userToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifyConfigs?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dueTime != nil {
            map["DueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["ExecutorIds"] = self.executorIds!
        }
        if self.notifyConfigs != nil {
            map["NotifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.participantIds != nil {
            map["ParticipantIds"] = self.participantIds!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userToken != nil {
            map["UserToken"] = self.userToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DueTime") {
            self.dueTime = dict["DueTime"] as! Int64
        }
        if dict.keys.contains("ExecutorIds") {
            self.executorIds = dict["ExecutorIds"] as! [String]
        }
        if dict.keys.contains("NotifyConfigs") {
            var model = CreateDingtalkPersonalTodoTaskRequest.NotifyConfigs()
            model.fromMap(dict["NotifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("ParticipantIds") {
            self.participantIds = dict["ParticipantIds"] as! [String]
        }
        if dict.keys.contains("Subject") {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateDingtalkPersonalTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserToken") {
            self.userToken = dict["UserToken"] as! String
        }
    }
}

public class CreateDingtalkPersonalTodoTaskShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var notifyConfigsShrink: String?

    public var participantIdsShrink: String?

    public var subject: String?

    public var tenantContextShrink: String?

    public var userToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dueTime != nil {
            map["DueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["ExecutorIds"] = self.executorIdsShrink!
        }
        if self.notifyConfigsShrink != nil {
            map["NotifyConfigs"] = self.notifyConfigsShrink!
        }
        if self.participantIdsShrink != nil {
            map["ParticipantIds"] = self.participantIdsShrink!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userToken != nil {
            map["UserToken"] = self.userToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DueTime") {
            self.dueTime = dict["DueTime"] as! Int64
        }
        if dict.keys.contains("ExecutorIds") {
            self.executorIdsShrink = dict["ExecutorIds"] as! String
        }
        if dict.keys.contains("NotifyConfigs") {
            self.notifyConfigsShrink = dict["NotifyConfigs"] as! String
        }
        if dict.keys.contains("ParticipantIds") {
            self.participantIdsShrink = dict["ParticipantIds"] as! String
        }
        if dict.keys.contains("Subject") {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserToken") {
            self.userToken = dict["UserToken"] as! String
        }
    }
}

public class CreateDingtalkPersonalTodoTaskResponseBody : Tea.TeaModel {
    public var createdTime: Int64?

    public var requestId: String?

    public var taskId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateDingtalkPersonalTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDingtalkPersonalTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDingtalkPersonalTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateEventRequest : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public class CardInstances : Tea.TeaModel {
        public var outTrackId: String?

        public var scenario: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outTrackId != nil {
                map["OutTrackId"] = self.outTrackId!
            }
            if self.scenario != nil {
                map["Scenario"] = self.scenario!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutTrackId") {
                self.outTrackId = dict["OutTrackId"] as! String
            }
            if dict.keys.contains("Scenario") {
                self.scenario = dict["Scenario"] as! String
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayName") {
                self.displayName = dict["displayName"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["dayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["daysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.interval != nil {
                    map["interval"] = self.interval!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dayOfMonth") {
                    self.dayOfMonth = dict["dayOfMonth"] as! Int32
                }
                if dict.keys.contains("daysOfWeek") {
                    self.daysOfWeek = dict["daysOfWeek"] as! String
                }
                if dict.keys.contains("index") {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("interval") {
                    self.interval = dict["interval"] as! Int32
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["endDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["numberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("endDate") {
                    self.endDate = dict["endDate"] as! String
                }
                if dict.keys.contains("numberOfOccurrences") {
                    self.numberOfOccurrences = dict["numberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var pattern: CreateEventRequest.Recurrence.Pattern?

        public var range: CreateEventRequest.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("pattern") {
                var model = CreateEventRequest.Recurrence.Pattern()
                model.fromMap(dict["pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("range") {
                var model = CreateEventRequest.Recurrence.Range()
                model.fromMap(dict["range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["method"] = self.method!
            }
            if self.minutes != nil {
                map["minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("method") {
                self.method = dict["method"] as! String
            }
            if dict.keys.contains("minutes") {
                self.minutes = dict["minutes"] as! Int32
            }
        }
    }
    public class RichTextDescription : Tea.TeaModel {
        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.text != nil {
                map["text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("text") {
                self.text = dict["text"] as! String
            }
        }
    }
    public class UiConfigs : Tea.TeaModel {
        public var uiName: String?

        public var uiStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uiName != nil {
                map["uiName"] = self.uiName!
            }
            if self.uiStatus != nil {
                map["uiStatus"] = self.uiStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("uiName") {
                self.uiName = dict["uiName"] as! String
            }
            if dict.keys.contains("uiStatus") {
                self.uiStatus = dict["uiStatus"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public var attendees: [CreateEventRequest.Attendees]?

    public var cardInstances: [CreateEventRequest.CardInstances]?

    public var description_: String?

    public var end: CreateEventRequest.End?

    public var extra: [String: String]?

    public var isAllDay: Bool?

    public var location: CreateEventRequest.Location?

    public var onlineMeetingInfo: CreateEventRequest.OnlineMeetingInfo?

    public var recurrence: CreateEventRequest.Recurrence?

    public var reminders: [CreateEventRequest.Reminders]?

    public var richTextDescription: CreateEventRequest.RichTextDescription?

    public var summary: String?

    public var uiConfigs: [CreateEventRequest.UiConfigs]?

    public var calendarId: String?

    public var start: CreateEventRequest.Start?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.recurrence?.validate()
        try self.richTextDescription?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["Attendees"] = tmp
        }
        if self.cardInstances != nil {
            var tmp : [Any] = []
            for k in self.cardInstances! {
                tmp.append(k.toMap())
            }
            map["CardInstances"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.end != nil {
            map["End"] = self.end?.toMap()
        }
        if self.extra != nil {
            map["Extra"] = self.extra!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["Location"] = self.location?.toMap()
        }
        if self.onlineMeetingInfo != nil {
            map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["Reminders"] = tmp
        }
        if self.richTextDescription != nil {
            map["RichTextDescription"] = self.richTextDescription?.toMap()
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.uiConfigs != nil {
            var tmp : [Any] = []
            for k in self.uiConfigs! {
                tmp.append(k.toMap())
            }
            map["UiConfigs"] = tmp
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") {
            var tmp : [CreateEventRequest.Attendees] = []
            for v in dict["Attendees"] as! [Any] {
                var model = CreateEventRequest.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("CardInstances") {
            var tmp : [CreateEventRequest.CardInstances] = []
            for v in dict["CardInstances"] as! [Any] {
                var model = CreateEventRequest.CardInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cardInstances = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") {
            var model = CreateEventRequest.End()
            model.fromMap(dict["End"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("Extra") {
            self.extra = dict["Extra"] as! [String: String]
        }
        if dict.keys.contains("IsAllDay") {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") {
            var model = CreateEventRequest.Location()
            model.fromMap(dict["Location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("OnlineMeetingInfo") {
            var model = CreateEventRequest.OnlineMeetingInfo()
            model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("Recurrence") {
            var model = CreateEventRequest.Recurrence()
            model.fromMap(dict["Recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("Reminders") {
            var tmp : [CreateEventRequest.Reminders] = []
            for v in dict["Reminders"] as! [Any] {
                var model = CreateEventRequest.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("RichTextDescription") {
            var model = CreateEventRequest.RichTextDescription()
            model.fromMap(dict["RichTextDescription"] as! [String: Any])
            self.richTextDescription = model
        }
        if dict.keys.contains("Summary") {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("UiConfigs") {
            var tmp : [CreateEventRequest.UiConfigs] = []
            for v in dict["UiConfigs"] as! [Any] {
                var model = CreateEventRequest.UiConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uiConfigs = tmp
        }
        if dict.keys.contains("calendarId") {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("start") {
            var model = CreateEventRequest.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
    }
}

public class CreateEventShrinkRequest : Tea.TeaModel {
    public var attendeesShrink: String?

    public var cardInstancesShrink: String?

    public var description_: String?

    public var endShrink: String?

    public var extraShrink: String?

    public var isAllDay: Bool?

    public var locationShrink: String?

    public var onlineMeetingInfoShrink: String?

    public var recurrenceShrink: String?

    public var remindersShrink: String?

    public var richTextDescriptionShrink: String?

    public var summary: String?

    public var uiConfigsShrink: String?

    public var calendarId: String?

    public var startShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesShrink != nil {
            map["Attendees"] = self.attendeesShrink!
        }
        if self.cardInstancesShrink != nil {
            map["CardInstances"] = self.cardInstancesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endShrink != nil {
            map["End"] = self.endShrink!
        }
        if self.extraShrink != nil {
            map["Extra"] = self.extraShrink!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.locationShrink != nil {
            map["Location"] = self.locationShrink!
        }
        if self.onlineMeetingInfoShrink != nil {
            map["OnlineMeetingInfo"] = self.onlineMeetingInfoShrink!
        }
        if self.recurrenceShrink != nil {
            map["Recurrence"] = self.recurrenceShrink!
        }
        if self.remindersShrink != nil {
            map["Reminders"] = self.remindersShrink!
        }
        if self.richTextDescriptionShrink != nil {
            map["RichTextDescription"] = self.richTextDescriptionShrink!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.uiConfigsShrink != nil {
            map["UiConfigs"] = self.uiConfigsShrink!
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.startShrink != nil {
            map["start"] = self.startShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") {
            self.attendeesShrink = dict["Attendees"] as! String
        }
        if dict.keys.contains("CardInstances") {
            self.cardInstancesShrink = dict["CardInstances"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") {
            self.endShrink = dict["End"] as! String
        }
        if dict.keys.contains("Extra") {
            self.extraShrink = dict["Extra"] as! String
        }
        if dict.keys.contains("IsAllDay") {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") {
            self.locationShrink = dict["Location"] as! String
        }
        if dict.keys.contains("OnlineMeetingInfo") {
            self.onlineMeetingInfoShrink = dict["OnlineMeetingInfo"] as! String
        }
        if dict.keys.contains("Recurrence") {
            self.recurrenceShrink = dict["Recurrence"] as! String
        }
        if dict.keys.contains("Reminders") {
            self.remindersShrink = dict["Reminders"] as! String
        }
        if dict.keys.contains("RichTextDescription") {
            self.richTextDescriptionShrink = dict["RichTextDescription"] as! String
        }
        if dict.keys.contains("Summary") {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("UiConfigs") {
            self.uiConfigsShrink = dict["UiConfigs"] as! String
        }
        if dict.keys.contains("calendarId") {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("start") {
            self.startShrink = dict["start"] as! String
        }
    }
}

public class CreateEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("IsOptional") {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var conferenceId: String?

        public var extraInfo: [String: Any]?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: CreateEventResponseBody.Recurrence.Pattern?

        public var range: CreateEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") {
                var model = CreateEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") {
                var model = CreateEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class RichTextDescription : Tea.TeaModel {
        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.text != nil {
                map["text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("text") {
                self.text = dict["text"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class UiConfigs : Tea.TeaModel {
        public var uiName: String?

        public var uiStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uiName != nil {
                map["UiName"] = self.uiName!
            }
            if self.uiStatus != nil {
                map["UiStatus"] = self.uiStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UiName") {
                self.uiName = dict["UiName"] as! String
            }
            if dict.keys.contains("UiStatus") {
                self.uiStatus = dict["UiStatus"] as! String
            }
        }
    }
    public var attendees: [CreateEventResponseBody.Attendees]?

    public var createTime: String?

    public var description_: String?

    public var end: CreateEventResponseBody.End?

    public var id: String?

    public var isAllDay: Bool?

    public var location: CreateEventResponseBody.Location?

    public var onlineMeetingInfo: CreateEventResponseBody.OnlineMeetingInfo?

    public var organizer: CreateEventResponseBody.Organizer?

    public var recurrence: CreateEventResponseBody.Recurrence?

    public var reminders: [CreateEventResponseBody.Reminders]?

    public var requestId: String?

    public var richTextDescription: CreateEventResponseBody.RichTextDescription?

    public var start: CreateEventResponseBody.Start?

    public var summary: String?

    public var uiConfigs: [CreateEventResponseBody.UiConfigs]?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.organizer?.validate()
        try self.recurrence?.validate()
        try self.richTextDescription?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.onlineMeetingInfo != nil {
            map["onlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.richTextDescription != nil {
            map["richTextDescription"] = self.richTextDescription?.toMap()
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.uiConfigs != nil {
            var tmp : [Any] = []
            for k in self.uiConfigs! {
                tmp.append(k.toMap())
            }
            map["uiConfigs"] = tmp
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") {
            var tmp : [CreateEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = CreateEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") {
            var model = CreateEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") {
            var model = CreateEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("onlineMeetingInfo") {
            var model = CreateEventResponseBody.OnlineMeetingInfo()
            model.fromMap(dict["onlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("organizer") {
            var model = CreateEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("recurrence") {
            var model = CreateEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") {
            var tmp : [CreateEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = CreateEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("richTextDescription") {
            var model = CreateEventResponseBody.RichTextDescription()
            model.fromMap(dict["richTextDescription"] as! [String: Any])
            self.richTextDescription = model
        }
        if dict.keys.contains("start") {
            var model = CreateEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("summary") {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("uiConfigs") {
            var tmp : [CreateEventResponseBody.UiConfigs] = []
            for v in dict["uiConfigs"] as! [Any] {
                var model = CreateEventResponseBody.UiConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uiConfigs = tmp
        }
        if dict.keys.contains("updateTime") {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class CreateEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var coverUrl: String?

    public var introduction: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var publicType: Int64?

    public var tenantContext: CreateLiveRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.publicType != nil {
            map["PublicType"] = self.publicType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("PreEndTime") {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("PublicType") {
            self.publicType = dict["PublicType"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateLiveShrinkRequest : Tea.TeaModel {
    public var coverUrl: String?

    public var introduction: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var publicType: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.publicType != nil {
            map["PublicType"] = self.publicType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("PreEndTime") {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("PublicType") {
            self.publicType = dict["PublicType"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateLiveResponseBody : Tea.TeaModel {
    public var liveId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("liveId") {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateMeetingRoomRequest : Tea.TeaModel {
    public class ReservationAuthority : Tea.TeaModel {
        public class AuthorizedMembers : Tea.TeaModel {
            public var memberId: String?

            public var memberName: String?

            public var memberType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.memberType != nil {
                    map["MemberType"] = self.memberType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemberId") {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("MemberType") {
                    self.memberType = dict["MemberType"] as! String
                }
            }
        }
        public var authorizedMembers: [CreateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedMembers != nil {
                var tmp : [Any] = []
                for k in self.authorizedMembers! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedMembers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedMembers") {
                var tmp : [CreateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers] = []
                for v in dict["AuthorizedMembers"] as! [Any] {
                    var model = CreateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedMembers = tmp
            }
        }
    }
    public class RoomLocation : Tea.TeaModel {
        public var desc: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthority: CreateMeetingRoomRequest.ReservationAuthority?

    public var roomCapacity: Int32?

    public var roomLabelIds: [Int64]?

    public var roomLocation: CreateMeetingRoomRequest.RoomLocation?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContext: CreateMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservationAuthority?.validate()
        try self.roomLocation?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthority != nil {
            map["ReservationAuthority"] = self.reservationAuthority?.toMap()
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomLabelIds != nil {
            map["RoomLabelIds"] = self.roomLabelIds!
        }
        if self.roomLocation != nil {
            map["RoomLocation"] = self.roomLocation?.toMap()
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") {
            var model = CreateMeetingRoomRequest.ReservationAuthority()
            model.fromMap(dict["ReservationAuthority"] as! [String: Any])
            self.reservationAuthority = model
        }
        if dict.keys.contains("RoomCapacity") {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomLabelIds") {
            self.roomLabelIds = dict["RoomLabelIds"] as! [Int64]
        }
        if dict.keys.contains("RoomLocation") {
            var model = CreateMeetingRoomRequest.RoomLocation()
            model.fromMap(dict["RoomLocation"] as! [String: Any])
            self.roomLocation = model
        }
        if dict.keys.contains("RoomName") {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateMeetingRoomShrinkRequest : Tea.TeaModel {
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthorityShrink: String?

    public var roomCapacity: Int32?

    public var roomLabelIdsShrink: String?

    public var roomLocationShrink: String?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthorityShrink != nil {
            map["ReservationAuthority"] = self.reservationAuthorityShrink!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomLabelIdsShrink != nil {
            map["RoomLabelIds"] = self.roomLabelIdsShrink!
        }
        if self.roomLocationShrink != nil {
            map["RoomLocation"] = self.roomLocationShrink!
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") {
            self.reservationAuthorityShrink = dict["ReservationAuthority"] as! String
        }
        if dict.keys.contains("RoomCapacity") {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomLabelIds") {
            self.roomLabelIdsShrink = dict["RoomLabelIds"] as! String
        }
        if dict.keys.contains("RoomLocation") {
            self.roomLocationShrink = dict["RoomLocation"] as! String
        }
        if dict.keys.contains("RoomName") {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateMeetingRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupName: String?

    public var parentGroupId: Int64?

    public var tenantContext: CreateMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ParentGroupId") {
            self.parentGroupId = dict["ParentGroupId"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupName: String?

    public var parentGroupId: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ParentGroupId") {
            self.parentGroupId = dict["ParentGroupId"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Int64
        }
    }
}

public class CreateMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMessageHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
    }
}

public class CreateMessageRequest : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class CardCallback : Tea.TeaModel {
            public var content: String?

            public var templateId: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public class DingCard : Tea.TeaModel {
            public var cardDesc: String?

            public var content: String?

            public var contentType: String?

            public var finished: Bool?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardDesc != nil {
                    map["cardDesc"] = self.cardDesc!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.contentType != nil {
                    map["contentType"] = self.contentType!
                }
                if self.finished != nil {
                    map["finished"] = self.finished!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardDesc") {
                    self.cardDesc = dict["cardDesc"] as! String
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("contentType") {
                    self.contentType = dict["contentType"] as! String
                }
                if dict.keys.contains("finished") {
                    self.finished = dict["finished"] as! Bool
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
            }
        }
        public class ImageUrl : Tea.TeaModel {
            public var detail: String?

            public var imageDesc: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail!
                }
                if self.imageDesc != nil {
                    map["imageDesc"] = self.imageDesc!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    self.detail = dict["detail"] as! String
                }
                if dict.keys.contains("imageDesc") {
                    self.imageDesc = dict["imageDesc"] as! String
                }
                if dict.keys.contains("url") {
                    self.url = dict["url"] as! String
                }
            }
        }
        public class Markdown : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class Text : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var cardCallback: CreateMessageRequest.Content.CardCallback?

        public var dingCard: CreateMessageRequest.Content.DingCard?

        public var imageUrl: CreateMessageRequest.Content.ImageUrl?

        public var markdown: CreateMessageRequest.Content.Markdown?

        public var text: CreateMessageRequest.Content.Text?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cardCallback?.validate()
            try self.dingCard?.validate()
            try self.imageUrl?.validate()
            try self.markdown?.validate()
            try self.text?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardCallback != nil {
                map["cardCallback"] = self.cardCallback?.toMap()
            }
            if self.dingCard != nil {
                map["dingCard"] = self.dingCard?.toMap()
            }
            if self.imageUrl != nil {
                map["imageUrl"] = self.imageUrl?.toMap()
            }
            if self.markdown != nil {
                map["markdown"] = self.markdown?.toMap()
            }
            if self.text != nil {
                map["text"] = self.text?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cardCallback") {
                var model = CreateMessageRequest.Content.CardCallback()
                model.fromMap(dict["cardCallback"] as! [String: Any])
                self.cardCallback = model
            }
            if dict.keys.contains("dingCard") {
                var model = CreateMessageRequest.Content.DingCard()
                model.fromMap(dict["dingCard"] as! [String: Any])
                self.dingCard = model
            }
            if dict.keys.contains("imageUrl") {
                var model = CreateMessageRequest.Content.ImageUrl()
                model.fromMap(dict["imageUrl"] as! [String: Any])
                self.imageUrl = model
            }
            if dict.keys.contains("markdown") {
                var model = CreateMessageRequest.Content.Markdown()
                model.fromMap(dict["markdown"] as! [String: Any])
                self.markdown = model
            }
            if dict.keys.contains("text") {
                var model = CreateMessageRequest.Content.Text()
                model.fromMap(dict["text"] as! [String: Any])
                self.text = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var assistantId: String?

    public var content: [CreateMessageRequest.Content]?

    public var metadata: [String: Any]?

    public var originalAssistantId: String?

    public var role: String?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistantId != nil {
            map["assistantId"] = self.assistantId!
        }
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["content"] = tmp
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.originalAssistantId != nil {
            map["originalAssistantId"] = self.originalAssistantId!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assistantId") {
            self.assistantId = dict["assistantId"] as! String
        }
        if dict.keys.contains("content") {
            var tmp : [CreateMessageRequest.Content] = []
            for v in dict["content"] as! [Any] {
                var model = CreateMessageRequest.Content()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.content = tmp
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("originalAssistantId") {
            self.originalAssistantId = dict["originalAssistantId"] as! String
        }
        if dict.keys.contains("role") {
            self.role = dict["role"] as! String
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class CreateMessageResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class CardCallback : Tea.TeaModel {
            public var content: String?

            public var templateId: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public class DingCard : Tea.TeaModel {
            public var cardDesc: String?

            public var content: String?

            public var contentType: String?

            public var finished: Bool?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardDesc != nil {
                    map["cardDesc"] = self.cardDesc!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.contentType != nil {
                    map["contentType"] = self.contentType!
                }
                if self.finished != nil {
                    map["finished"] = self.finished!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardDesc") {
                    self.cardDesc = dict["cardDesc"] as! String
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("contentType") {
                    self.contentType = dict["contentType"] as! String
                }
                if dict.keys.contains("finished") {
                    self.finished = dict["finished"] as! Bool
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
            }
        }
        public class ImageUrl : Tea.TeaModel {
            public var detail: String?

            public var imageDesc: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail!
                }
                if self.imageDesc != nil {
                    map["imageDesc"] = self.imageDesc!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    self.detail = dict["detail"] as! String
                }
                if dict.keys.contains("imageDesc") {
                    self.imageDesc = dict["imageDesc"] as! String
                }
                if dict.keys.contains("url") {
                    self.url = dict["url"] as! String
                }
            }
        }
        public class Markdown : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class Text : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var cardCallback: CreateMessageResponseBody.Content.CardCallback?

        public var dingCard: CreateMessageResponseBody.Content.DingCard?

        public var imageUrl: CreateMessageResponseBody.Content.ImageUrl?

        public var markdown: CreateMessageResponseBody.Content.Markdown?

        public var text: CreateMessageResponseBody.Content.Text?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cardCallback?.validate()
            try self.dingCard?.validate()
            try self.imageUrl?.validate()
            try self.markdown?.validate()
            try self.text?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardCallback != nil {
                map["cardCallback"] = self.cardCallback?.toMap()
            }
            if self.dingCard != nil {
                map["dingCard"] = self.dingCard?.toMap()
            }
            if self.imageUrl != nil {
                map["imageUrl"] = self.imageUrl?.toMap()
            }
            if self.markdown != nil {
                map["markdown"] = self.markdown?.toMap()
            }
            if self.text != nil {
                map["text"] = self.text?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cardCallback") {
                var model = CreateMessageResponseBody.Content.CardCallback()
                model.fromMap(dict["cardCallback"] as! [String: Any])
                self.cardCallback = model
            }
            if dict.keys.contains("dingCard") {
                var model = CreateMessageResponseBody.Content.DingCard()
                model.fromMap(dict["dingCard"] as! [String: Any])
                self.dingCard = model
            }
            if dict.keys.contains("imageUrl") {
                var model = CreateMessageResponseBody.Content.ImageUrl()
                model.fromMap(dict["imageUrl"] as! [String: Any])
                self.imageUrl = model
            }
            if dict.keys.contains("markdown") {
                var model = CreateMessageResponseBody.Content.Markdown()
                model.fromMap(dict["markdown"] as! [String: Any])
                self.markdown = model
            }
            if dict.keys.contains("text") {
                var model = CreateMessageResponseBody.Content.Text()
                model.fromMap(dict["text"] as! [String: Any])
                self.text = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var content: [CreateMessageResponseBody.Content]?

    public var createAt: Int64?

    public var id: String?

    public var metadata: [String: Any]?

    public var object: String?

    public var requestId: String?

    public var role: String?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["content"] = tmp
        }
        if self.createAt != nil {
            map["createAt"] = self.createAt!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            var tmp : [CreateMessageResponseBody.Content] = []
            for v in dict["content"] as! [Any] {
                var model = CreateMessageResponseBody.Content()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.content = tmp
        }
        if dict.keys.contains("createAt") {
            self.createAt = dict["createAt"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("object") {
            self.object = dict["object"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("role") {
            self.role = dict["role"] as! String
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class CreateMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMessageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateOrUpdateFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateOrUpdateFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateOrUpdateFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateOrUpdateFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formDataJson: String?

    public var formUuid: String?

    public var noExecuteExpression: Bool?

    public var searchCondition: String?

    public var systemToken: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.searchCondition != nil {
            map["SearchCondition"] = self.searchCondition!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormDataJson") {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("NoExecuteExpression") {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SearchCondition") {
            self.searchCondition = dict["SearchCondition"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateOrUpdateFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateOrUpdateFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrUpdateFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrgHonorTemplateHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateOrgHonorTemplateHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateOrgHonorTemplateHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateOrgHonorTemplateShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateOrgHonorTemplateRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: CreateOrgHonorTemplateRequest.TenantContext?

    public var avatarFrameMediaId: String?

    public var defaultBgColor: String?

    public var medalDesc: String?

    public var medalMediaId: String?

    public var medalName: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.avatarFrameMediaId != nil {
            map["avatarFrameMediaId"] = self.avatarFrameMediaId!
        }
        if self.defaultBgColor != nil {
            map["defaultBgColor"] = self.defaultBgColor!
        }
        if self.medalDesc != nil {
            map["medalDesc"] = self.medalDesc!
        }
        if self.medalMediaId != nil {
            map["medalMediaId"] = self.medalMediaId!
        }
        if self.medalName != nil {
            map["medalName"] = self.medalName!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = CreateOrgHonorTemplateRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("avatarFrameMediaId") {
            self.avatarFrameMediaId = dict["avatarFrameMediaId"] as! String
        }
        if dict.keys.contains("defaultBgColor") {
            self.defaultBgColor = dict["defaultBgColor"] as! String
        }
        if dict.keys.contains("medalDesc") {
            self.medalDesc = dict["medalDesc"] as! String
        }
        if dict.keys.contains("medalMediaId") {
            self.medalMediaId = dict["medalMediaId"] as! String
        }
        if dict.keys.contains("medalName") {
            self.medalName = dict["medalName"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var avatarFrameMediaId: String?

    public var defaultBgColor: String?

    public var medalDesc: String?

    public var medalMediaId: String?

    public var medalName: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.avatarFrameMediaId != nil {
            map["avatarFrameMediaId"] = self.avatarFrameMediaId!
        }
        if self.defaultBgColor != nil {
            map["defaultBgColor"] = self.defaultBgColor!
        }
        if self.medalDesc != nil {
            map["medalDesc"] = self.medalDesc!
        }
        if self.medalMediaId != nil {
            map["medalMediaId"] = self.medalMediaId!
        }
        if self.medalName != nil {
            map["medalName"] = self.medalName!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("avatarFrameMediaId") {
            self.avatarFrameMediaId = dict["avatarFrameMediaId"] as! String
        }
        if dict.keys.contains("defaultBgColor") {
            self.defaultBgColor = dict["defaultBgColor"] as! String
        }
        if dict.keys.contains("medalDesc") {
            self.medalDesc = dict["medalDesc"] as! String
        }
        if dict.keys.contains("medalMediaId") {
            self.medalMediaId = dict["medalMediaId"] as! String
        }
        if dict.keys.contains("medalName") {
            self.medalName = dict["medalName"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateResponseBody : Tea.TeaModel {
    public var honorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrgHonorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrgHonorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePersonalTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreatePersonalTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreatePersonalTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreatePersonalTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreatePersonalTodoTaskRequest : Tea.TeaModel {
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["DingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingNotify") {
                self.dingNotify = dict["DingNotify"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var description_: String?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var notifyConfigs: CreatePersonalTodoTaskRequest.NotifyConfigs?

    public var participantIds: [String]?

    public var reminderTimeStamp: Int64?

    public var subject: String?

    public var tenantContext: CreatePersonalTodoTaskRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifyConfigs?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dueTime != nil {
            map["DueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["ExecutorIds"] = self.executorIds!
        }
        if self.notifyConfigs != nil {
            map["NotifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.participantIds != nil {
            map["ParticipantIds"] = self.participantIds!
        }
        if self.reminderTimeStamp != nil {
            map["ReminderTimeStamp"] = self.reminderTimeStamp!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DueTime") {
            self.dueTime = dict["DueTime"] as! Int64
        }
        if dict.keys.contains("ExecutorIds") {
            self.executorIds = dict["ExecutorIds"] as! [String]
        }
        if dict.keys.contains("NotifyConfigs") {
            var model = CreatePersonalTodoTaskRequest.NotifyConfigs()
            model.fromMap(dict["NotifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("ParticipantIds") {
            self.participantIds = dict["ParticipantIds"] as! [String]
        }
        if dict.keys.contains("ReminderTimeStamp") {
            self.reminderTimeStamp = dict["ReminderTimeStamp"] as! Int64
        }
        if dict.keys.contains("Subject") {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CreatePersonalTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreatePersonalTodoTaskShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var notifyConfigsShrink: String?

    public var participantIdsShrink: String?

    public var reminderTimeStamp: Int64?

    public var subject: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dueTime != nil {
            map["DueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["ExecutorIds"] = self.executorIdsShrink!
        }
        if self.notifyConfigsShrink != nil {
            map["NotifyConfigs"] = self.notifyConfigsShrink!
        }
        if self.participantIdsShrink != nil {
            map["ParticipantIds"] = self.participantIdsShrink!
        }
        if self.reminderTimeStamp != nil {
            map["ReminderTimeStamp"] = self.reminderTimeStamp!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DueTime") {
            self.dueTime = dict["DueTime"] as! Int64
        }
        if dict.keys.contains("ExecutorIds") {
            self.executorIdsShrink = dict["ExecutorIds"] as! String
        }
        if dict.keys.contains("NotifyConfigs") {
            self.notifyConfigsShrink = dict["NotifyConfigs"] as! String
        }
        if dict.keys.contains("ParticipantIds") {
            self.participantIdsShrink = dict["ParticipantIds"] as! String
        }
        if dict.keys.contains("ReminderTimeStamp") {
            self.reminderTimeStamp = dict["ReminderTimeStamp"] as! Int64
        }
        if dict.keys.contains("Subject") {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreatePersonalTodoTaskResponseBody : Tea.TeaModel {
    public var createdTime: Int64?

    public var requestId: String?

    public var taskId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreatePersonalTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePersonalTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePersonalTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateReportRequest : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var content: String?

        public var contentType: String?

        public var key: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentType") {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var contents: [CreateReportRequest.Contents]?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContext: CreateReportRequest.TenantContext?

    public var toChat: Bool?

    public var toCids: [String]?

    public var toUserids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.toChat != nil {
            map["ToChat"] = self.toChat!
        }
        if self.toCids != nil {
            map["ToCids"] = self.toCids!
        }
        if self.toUserids != nil {
            map["ToUserids"] = self.toUserids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") {
            var tmp : [CreateReportRequest.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = CreateReportRequest.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("DdFrom") {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("ToChat") {
            self.toChat = dict["ToChat"] as! Bool
        }
        if dict.keys.contains("ToCids") {
            self.toCids = dict["ToCids"] as! [String]
        }
        if dict.keys.contains("ToUserids") {
            self.toUserids = dict["ToUserids"] as! [String]
        }
    }
}

public class CreateReportShrinkRequest : Tea.TeaModel {
    public var contentsShrink: String?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContextShrink: String?

    public var toChat: Bool?

    public var toCidsShrink: String?

    public var toUseridsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentsShrink != nil {
            map["Contents"] = self.contentsShrink!
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.toChat != nil {
            map["ToChat"] = self.toChat!
        }
        if self.toCidsShrink != nil {
            map["ToCids"] = self.toCidsShrink!
        }
        if self.toUseridsShrink != nil {
            map["ToUserids"] = self.toUseridsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") {
            self.contentsShrink = dict["Contents"] as! String
        }
        if dict.keys.contains("DdFrom") {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("ToChat") {
            self.toChat = dict["ToChat"] as! Bool
        }
        if dict.keys.contains("ToCids") {
            self.toCidsShrink = dict["ToCids"] as! String
        }
        if dict.keys.contains("ToUserids") {
            self.toUseridsShrink = dict["ToUserids"] as! String
        }
    }
}

public class CreateReportResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRunHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
    }
}

public class CreateRunRequest : Tea.TeaModel {
    public var assistantId: String?

    public var instructions: String?

    public var metadata: [String: Any]?

    public var originalAssistantId: String?

    public var stream: Bool?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistantId != nil {
            map["assistantId"] = self.assistantId!
        }
        if self.instructions != nil {
            map["instructions"] = self.instructions!
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.originalAssistantId != nil {
            map["originalAssistantId"] = self.originalAssistantId!
        }
        if self.stream != nil {
            map["stream"] = self.stream!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assistantId") {
            self.assistantId = dict["assistantId"] as! String
        }
        if dict.keys.contains("instructions") {
            self.instructions = dict["instructions"] as! String
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("originalAssistantId") {
            self.originalAssistantId = dict["originalAssistantId"] as! String
        }
        if dict.keys.contains("stream") {
            self.stream = dict["stream"] as! Bool
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class CreateRunResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class CardCallback : Tea.TeaModel {
            public var content: String?

            public var templateId: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public class DingCard : Tea.TeaModel {
            public var cardDesc: String?

            public var content: String?

            public var contentType: String?

            public var finished: Bool?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardDesc != nil {
                    map["cardDesc"] = self.cardDesc!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.contentType != nil {
                    map["contentType"] = self.contentType!
                }
                if self.finished != nil {
                    map["finished"] = self.finished!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardDesc") {
                    self.cardDesc = dict["cardDesc"] as! String
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("contentType") {
                    self.contentType = dict["contentType"] as! String
                }
                if dict.keys.contains("finished") {
                    self.finished = dict["finished"] as! Bool
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
            }
        }
        public class ImageUrl : Tea.TeaModel {
            public var detail: String?

            public var imageDesc: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail!
                }
                if self.imageDesc != nil {
                    map["imageDesc"] = self.imageDesc!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    self.detail = dict["detail"] as! String
                }
                if dict.keys.contains("imageDesc") {
                    self.imageDesc = dict["imageDesc"] as! String
                }
                if dict.keys.contains("url") {
                    self.url = dict["url"] as! String
                }
            }
        }
        public class Markdown : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class Text : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var cardCallback: CreateRunResponseBody.Content.CardCallback?

        public var dingCard: CreateRunResponseBody.Content.DingCard?

        public var imageUrl: CreateRunResponseBody.Content.ImageUrl?

        public var markdown: CreateRunResponseBody.Content.Markdown?

        public var text: CreateRunResponseBody.Content.Text?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cardCallback?.validate()
            try self.dingCard?.validate()
            try self.imageUrl?.validate()
            try self.markdown?.validate()
            try self.text?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardCallback != nil {
                map["cardCallback"] = self.cardCallback?.toMap()
            }
            if self.dingCard != nil {
                map["dingCard"] = self.dingCard?.toMap()
            }
            if self.imageUrl != nil {
                map["imageUrl"] = self.imageUrl?.toMap()
            }
            if self.markdown != nil {
                map["markdown"] = self.markdown?.toMap()
            }
            if self.text != nil {
                map["text"] = self.text?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cardCallback") {
                var model = CreateRunResponseBody.Content.CardCallback()
                model.fromMap(dict["cardCallback"] as! [String: Any])
                self.cardCallback = model
            }
            if dict.keys.contains("dingCard") {
                var model = CreateRunResponseBody.Content.DingCard()
                model.fromMap(dict["dingCard"] as! [String: Any])
                self.dingCard = model
            }
            if dict.keys.contains("imageUrl") {
                var model = CreateRunResponseBody.Content.ImageUrl()
                model.fromMap(dict["imageUrl"] as! [String: Any])
                self.imageUrl = model
            }
            if dict.keys.contains("markdown") {
                var model = CreateRunResponseBody.Content.Markdown()
                model.fromMap(dict["markdown"] as! [String: Any])
                self.markdown = model
            }
            if dict.keys.contains("text") {
                var model = CreateRunResponseBody.Content.Text()
                model.fromMap(dict["text"] as! [String: Any])
                self.text = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public class Delta : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class CardCallback : Tea.TeaModel {
                public var content: String?

                public var templateId: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.templateId != nil {
                        map["templateId"] = self.templateId!
                    }
                    if self.userId != nil {
                        map["userId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("templateId") {
                        self.templateId = dict["templateId"] as! String
                    }
                    if dict.keys.contains("userId") {
                        self.userId = dict["userId"] as! String
                    }
                }
            }
            public class DingCard : Tea.TeaModel {
                public var cardDesc: String?

                public var content: String?

                public var contentType: String?

                public var finished: Bool?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cardDesc != nil {
                        map["cardDesc"] = self.cardDesc!
                    }
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.contentType != nil {
                        map["contentType"] = self.contentType!
                    }
                    if self.finished != nil {
                        map["finished"] = self.finished!
                    }
                    if self.templateId != nil {
                        map["templateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cardDesc") {
                        self.cardDesc = dict["cardDesc"] as! String
                    }
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("contentType") {
                        self.contentType = dict["contentType"] as! String
                    }
                    if dict.keys.contains("finished") {
                        self.finished = dict["finished"] as! Bool
                    }
                    if dict.keys.contains("templateId") {
                        self.templateId = dict["templateId"] as! String
                    }
                }
            }
            public class ImageUrl : Tea.TeaModel {
                public var detail: String?

                public var imageDesc: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        map["detail"] = self.detail!
                    }
                    if self.imageDesc != nil {
                        map["imageDesc"] = self.imageDesc!
                    }
                    if self.url != nil {
                        map["url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("detail") {
                        self.detail = dict["detail"] as! String
                    }
                    if dict.keys.contains("imageDesc") {
                        self.imageDesc = dict["imageDesc"] as! String
                    }
                    if dict.keys.contains("url") {
                        self.url = dict["url"] as! String
                    }
                }
            }
            public class Markdown : Tea.TeaModel {
                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public class Text : Tea.TeaModel {
                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var cardCallback: CreateRunResponseBody.Delta.Content.CardCallback?

            public var dingCard: CreateRunResponseBody.Delta.Content.DingCard?

            public var imageUrl: CreateRunResponseBody.Delta.Content.ImageUrl?

            public var markdown: CreateRunResponseBody.Delta.Content.Markdown?

            public var text: CreateRunResponseBody.Delta.Content.Text?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cardCallback?.validate()
                try self.dingCard?.validate()
                try self.imageUrl?.validate()
                try self.markdown?.validate()
                try self.text?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardCallback != nil {
                    map["cardCallback"] = self.cardCallback?.toMap()
                }
                if self.dingCard != nil {
                    map["dingCard"] = self.dingCard?.toMap()
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl?.toMap()
                }
                if self.markdown != nil {
                    map["markdown"] = self.markdown?.toMap()
                }
                if self.text != nil {
                    map["text"] = self.text?.toMap()
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardCallback") {
                    var model = CreateRunResponseBody.Delta.Content.CardCallback()
                    model.fromMap(dict["cardCallback"] as! [String: Any])
                    self.cardCallback = model
                }
                if dict.keys.contains("dingCard") {
                    var model = CreateRunResponseBody.Delta.Content.DingCard()
                    model.fromMap(dict["dingCard"] as! [String: Any])
                    self.dingCard = model
                }
                if dict.keys.contains("imageUrl") {
                    var model = CreateRunResponseBody.Delta.Content.ImageUrl()
                    model.fromMap(dict["imageUrl"] as! [String: Any])
                    self.imageUrl = model
                }
                if dict.keys.contains("markdown") {
                    var model = CreateRunResponseBody.Delta.Content.Markdown()
                    model.fromMap(dict["markdown"] as! [String: Any])
                    self.markdown = model
                }
                if dict.keys.contains("text") {
                    var model = CreateRunResponseBody.Delta.Content.Text()
                    model.fromMap(dict["text"] as! [String: Any])
                    self.text = model
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var content: CreateRunResponseBody.Delta.Content?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                var model = CreateRunResponseBody.Delta.Content()
                model.fromMap(dict["content"] as! [String: Any])
                self.content = model
            }
        }
    }
    public var cancelledAt: Int64?

    public var completedAt: Int64?

    public var content: CreateRunResponseBody.Content?

    public var createAt: Int64?

    public var delta: CreateRunResponseBody.Delta?

    public var expiresAt: Int64?

    public var failedAt: Int64?

    public var id: String?

    public var lastErrorMsg: String?

    public var metadata: [String: Any]?

    public var object: String?

    public var requestId: String?

    public var startedAt: Int64?

    public var status: String?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
        try self.delta?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cancelledAt != nil {
            map["cancelledAt"] = self.cancelledAt!
        }
        if self.completedAt != nil {
            map["completedAt"] = self.completedAt!
        }
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.createAt != nil {
            map["createAt"] = self.createAt!
        }
        if self.delta != nil {
            map["delta"] = self.delta?.toMap()
        }
        if self.expiresAt != nil {
            map["expiresAt"] = self.expiresAt!
        }
        if self.failedAt != nil {
            map["failedAt"] = self.failedAt!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastErrorMsg != nil {
            map["lastErrorMsg"] = self.lastErrorMsg!
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.startedAt != nil {
            map["startedAt"] = self.startedAt!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cancelledAt") {
            self.cancelledAt = dict["cancelledAt"] as! Int64
        }
        if dict.keys.contains("completedAt") {
            self.completedAt = dict["completedAt"] as! Int64
        }
        if dict.keys.contains("content") {
            var model = CreateRunResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("createAt") {
            self.createAt = dict["createAt"] as! Int64
        }
        if dict.keys.contains("delta") {
            var model = CreateRunResponseBody.Delta()
            model.fromMap(dict["delta"] as! [String: Any])
            self.delta = model
        }
        if dict.keys.contains("expiresAt") {
            self.expiresAt = dict["expiresAt"] as! Int64
        }
        if dict.keys.contains("failedAt") {
            self.failedAt = dict["failedAt"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("lastErrorMsg") {
            self.lastErrorMsg = dict["lastErrorMsg"] as! String
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("object") {
            self.object = dict["object"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("startedAt") {
            self.startedAt = dict["startedAt"] as! Int64
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class CreateRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScenegroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateScenegroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateScenegroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateScenegroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateScenegroupRequest : Tea.TeaModel {
    public var addFriendForbidden: Int64?

    public var allMembersCanCreateCalendar: Int64?

    public var allMembersCanCreateMcsConf: Int64?

    public var chatBannedType: Int64?

    public var groupEmailDisabled: Int64?

    public var groupLiveSwitch: Int64?

    public var icon: String?

    public var managementType: Int64?

    public var membersToAdminChat: Int64?

    public var mentionAllAuthority: Int64?

    public var onlyAdminCanDing: Int64?

    public var onlyAdminCanSetMsgTop: Int64?

    public var searchable: Int64?

    public var showHistoryType: Int64?

    public var subadminIds: String?

    public var templateId: String?

    public var title: String?

    public var userIds: String?

    public var uuid: String?

    public var validationType: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addFriendForbidden != nil {
            map["AddFriendForbidden"] = self.addFriendForbidden!
        }
        if self.allMembersCanCreateCalendar != nil {
            map["AllMembersCanCreateCalendar"] = self.allMembersCanCreateCalendar!
        }
        if self.allMembersCanCreateMcsConf != nil {
            map["AllMembersCanCreateMcsConf"] = self.allMembersCanCreateMcsConf!
        }
        if self.chatBannedType != nil {
            map["ChatBannedType"] = self.chatBannedType!
        }
        if self.groupEmailDisabled != nil {
            map["GroupEmailDisabled"] = self.groupEmailDisabled!
        }
        if self.groupLiveSwitch != nil {
            map["GroupLiveSwitch"] = self.groupLiveSwitch!
        }
        if self.icon != nil {
            map["Icon"] = self.icon!
        }
        if self.managementType != nil {
            map["ManagementType"] = self.managementType!
        }
        if self.membersToAdminChat != nil {
            map["MembersToAdminChat"] = self.membersToAdminChat!
        }
        if self.mentionAllAuthority != nil {
            map["MentionAllAuthority"] = self.mentionAllAuthority!
        }
        if self.onlyAdminCanDing != nil {
            map["OnlyAdminCanDing"] = self.onlyAdminCanDing!
        }
        if self.onlyAdminCanSetMsgTop != nil {
            map["OnlyAdminCanSetMsgTop"] = self.onlyAdminCanSetMsgTop!
        }
        if self.searchable != nil {
            map["Searchable"] = self.searchable!
        }
        if self.showHistoryType != nil {
            map["ShowHistoryType"] = self.showHistoryType!
        }
        if self.subadminIds != nil {
            map["SubadminIds"] = self.subadminIds!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.validationType != nil {
            map["ValidationType"] = self.validationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddFriendForbidden") {
            self.addFriendForbidden = dict["AddFriendForbidden"] as! Int64
        }
        if dict.keys.contains("AllMembersCanCreateCalendar") {
            self.allMembersCanCreateCalendar = dict["AllMembersCanCreateCalendar"] as! Int64
        }
        if dict.keys.contains("AllMembersCanCreateMcsConf") {
            self.allMembersCanCreateMcsConf = dict["AllMembersCanCreateMcsConf"] as! Int64
        }
        if dict.keys.contains("ChatBannedType") {
            self.chatBannedType = dict["ChatBannedType"] as! Int64
        }
        if dict.keys.contains("GroupEmailDisabled") {
            self.groupEmailDisabled = dict["GroupEmailDisabled"] as! Int64
        }
        if dict.keys.contains("GroupLiveSwitch") {
            self.groupLiveSwitch = dict["GroupLiveSwitch"] as! Int64
        }
        if dict.keys.contains("Icon") {
            self.icon = dict["Icon"] as! String
        }
        if dict.keys.contains("ManagementType") {
            self.managementType = dict["ManagementType"] as! Int64
        }
        if dict.keys.contains("MembersToAdminChat") {
            self.membersToAdminChat = dict["MembersToAdminChat"] as! Int64
        }
        if dict.keys.contains("MentionAllAuthority") {
            self.mentionAllAuthority = dict["MentionAllAuthority"] as! Int64
        }
        if dict.keys.contains("OnlyAdminCanDing") {
            self.onlyAdminCanDing = dict["OnlyAdminCanDing"] as! Int64
        }
        if dict.keys.contains("OnlyAdminCanSetMsgTop") {
            self.onlyAdminCanSetMsgTop = dict["OnlyAdminCanSetMsgTop"] as! Int64
        }
        if dict.keys.contains("Searchable") {
            self.searchable = dict["Searchable"] as! Int64
        }
        if dict.keys.contains("ShowHistoryType") {
            self.showHistoryType = dict["ShowHistoryType"] as! Int64
        }
        if dict.keys.contains("SubadminIds") {
            self.subadminIds = dict["SubadminIds"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("ValidationType") {
            self.validationType = dict["ValidationType"] as! Int64
        }
    }
}

public class CreateScenegroupResponseBody : Tea.TeaModel {
    public var openConversationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["openConversationId"] = self.openConversationId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("openConversationId") {
            self.openConversationId = dict["openConversationId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateScenegroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScenegroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScenegroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateScheduleConferenceRequest : Tea.TeaModel {
    public class ScheduleConfSettingModel : Tea.TeaModel {
        public class MoziConfOpenRecordSetting : Tea.TeaModel {
            public var isFollowHost: Bool?

            public var mode: String?

            public var recordAutoStart: Int32?

            public var recordAutoStartType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isFollowHost != nil {
                    map["IsFollowHost"] = self.isFollowHost!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.recordAutoStart != nil {
                    map["RecordAutoStart"] = self.recordAutoStart!
                }
                if self.recordAutoStartType != nil {
                    map["RecordAutoStartType"] = self.recordAutoStartType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsFollowHost") {
                    self.isFollowHost = dict["IsFollowHost"] as! Bool
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("RecordAutoStart") {
                    self.recordAutoStart = dict["RecordAutoStart"] as! Int32
                }
                if dict.keys.contains("RecordAutoStartType") {
                    self.recordAutoStartType = dict["RecordAutoStartType"] as! Int32
                }
            }
        }
        public class MoziConfVirtualExtraSetting : Tea.TeaModel {
            public class MoziConfExtensionAppSettings : Tea.TeaModel {
                public var autoOpenMode: Int32?

                public var coolAppCode: String?

                public var extensionAppBizData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoOpenMode != nil {
                        map["AutoOpenMode"] = self.autoOpenMode!
                    }
                    if self.coolAppCode != nil {
                        map["CoolAppCode"] = self.coolAppCode!
                    }
                    if self.extensionAppBizData != nil {
                        map["ExtensionAppBizData"] = self.extensionAppBizData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoOpenMode") {
                        self.autoOpenMode = dict["AutoOpenMode"] as! Int32
                    }
                    if dict.keys.contains("CoolAppCode") {
                        self.coolAppCode = dict["CoolAppCode"] as! String
                    }
                    if dict.keys.contains("ExtensionAppBizData") {
                        self.extensionAppBizData = dict["ExtensionAppBizData"] as! String
                    }
                }
            }
            public var cloudRecordOwnerUserId: String?

            public var enableChat: Int32?

            public var enableWebAnonymousJoin: Bool?

            public var joinBeforeHost: Int32?

            public var lockMediaStatusMicMute: Int32?

            public var lockNick: Int32?

            public var minutesOwnerUserId: String?

            public var moziConfExtensionAppSettings: [CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting.MoziConfExtensionAppSettings]?

            public var pushAllMeetingRecords: Bool?

            public var pushCloudRecordCard: Bool?

            public var pushMinutesCard: Bool?

            public var waitingRoom: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cloudRecordOwnerUserId != nil {
                    map["CloudRecordOwnerUserId"] = self.cloudRecordOwnerUserId!
                }
                if self.enableChat != nil {
                    map["EnableChat"] = self.enableChat!
                }
                if self.enableWebAnonymousJoin != nil {
                    map["EnableWebAnonymousJoin"] = self.enableWebAnonymousJoin!
                }
                if self.joinBeforeHost != nil {
                    map["JoinBeforeHost"] = self.joinBeforeHost!
                }
                if self.lockMediaStatusMicMute != nil {
                    map["LockMediaStatusMicMute"] = self.lockMediaStatusMicMute!
                }
                if self.lockNick != nil {
                    map["LockNick"] = self.lockNick!
                }
                if self.minutesOwnerUserId != nil {
                    map["MinutesOwnerUserId"] = self.minutesOwnerUserId!
                }
                if self.moziConfExtensionAppSettings != nil {
                    var tmp : [Any] = []
                    for k in self.moziConfExtensionAppSettings! {
                        tmp.append(k.toMap())
                    }
                    map["MoziConfExtensionAppSettings"] = tmp
                }
                if self.pushAllMeetingRecords != nil {
                    map["PushAllMeetingRecords"] = self.pushAllMeetingRecords!
                }
                if self.pushCloudRecordCard != nil {
                    map["PushCloudRecordCard"] = self.pushCloudRecordCard!
                }
                if self.pushMinutesCard != nil {
                    map["PushMinutesCard"] = self.pushMinutesCard!
                }
                if self.waitingRoom != nil {
                    map["WaitingRoom"] = self.waitingRoom!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CloudRecordOwnerUserId") {
                    self.cloudRecordOwnerUserId = dict["CloudRecordOwnerUserId"] as! String
                }
                if dict.keys.contains("EnableChat") {
                    self.enableChat = dict["EnableChat"] as! Int32
                }
                if dict.keys.contains("EnableWebAnonymousJoin") {
                    self.enableWebAnonymousJoin = dict["EnableWebAnonymousJoin"] as! Bool
                }
                if dict.keys.contains("JoinBeforeHost") {
                    self.joinBeforeHost = dict["JoinBeforeHost"] as! Int32
                }
                if dict.keys.contains("LockMediaStatusMicMute") {
                    self.lockMediaStatusMicMute = dict["LockMediaStatusMicMute"] as! Int32
                }
                if dict.keys.contains("LockNick") {
                    self.lockNick = dict["LockNick"] as! Int32
                }
                if dict.keys.contains("MinutesOwnerUserId") {
                    self.minutesOwnerUserId = dict["MinutesOwnerUserId"] as! String
                }
                if dict.keys.contains("MoziConfExtensionAppSettings") {
                    var tmp : [CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting.MoziConfExtensionAppSettings] = []
                    for v in dict["MoziConfExtensionAppSettings"] as! [Any] {
                        var model = CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting.MoziConfExtensionAppSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.moziConfExtensionAppSettings = tmp
                }
                if dict.keys.contains("PushAllMeetingRecords") {
                    self.pushAllMeetingRecords = dict["PushAllMeetingRecords"] as! Bool
                }
                if dict.keys.contains("PushCloudRecordCard") {
                    self.pushCloudRecordCard = dict["PushCloudRecordCard"] as! Bool
                }
                if dict.keys.contains("PushMinutesCard") {
                    self.pushMinutesCard = dict["PushMinutesCard"] as! Bool
                }
                if dict.keys.contains("WaitingRoom") {
                    self.waitingRoom = dict["WaitingRoom"] as! Int32
                }
            }
        }
        public var cohostUserIds: [String]?

        public var confAllowedCorpId: String?

        public var hostUserId: String?

        public var lockRoom: Int32?

        public var moziConfOpenRecordSetting: CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfOpenRecordSetting?

        public var moziConfVirtualExtraSetting: CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting?

        public var muteOnJoin: Int32?

        public var screenShareForbidden: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.moziConfOpenRecordSetting?.validate()
            try self.moziConfVirtualExtraSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cohostUserIds != nil {
                map["CohostUserIds"] = self.cohostUserIds!
            }
            if self.confAllowedCorpId != nil {
                map["ConfAllowedCorpId"] = self.confAllowedCorpId!
            }
            if self.hostUserId != nil {
                map["HostUserId"] = self.hostUserId!
            }
            if self.lockRoom != nil {
                map["LockRoom"] = self.lockRoom!
            }
            if self.moziConfOpenRecordSetting != nil {
                map["MoziConfOpenRecordSetting"] = self.moziConfOpenRecordSetting?.toMap()
            }
            if self.moziConfVirtualExtraSetting != nil {
                map["MoziConfVirtualExtraSetting"] = self.moziConfVirtualExtraSetting?.toMap()
            }
            if self.muteOnJoin != nil {
                map["MuteOnJoin"] = self.muteOnJoin!
            }
            if self.screenShareForbidden != nil {
                map["ScreenShareForbidden"] = self.screenShareForbidden!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CohostUserIds") {
                self.cohostUserIds = dict["CohostUserIds"] as! [String]
            }
            if dict.keys.contains("ConfAllowedCorpId") {
                self.confAllowedCorpId = dict["ConfAllowedCorpId"] as! String
            }
            if dict.keys.contains("HostUserId") {
                self.hostUserId = dict["HostUserId"] as! String
            }
            if dict.keys.contains("LockRoom") {
                self.lockRoom = dict["LockRoom"] as! Int32
            }
            if dict.keys.contains("MoziConfOpenRecordSetting") {
                var model = CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfOpenRecordSetting()
                model.fromMap(dict["MoziConfOpenRecordSetting"] as! [String: Any])
                self.moziConfOpenRecordSetting = model
            }
            if dict.keys.contains("MoziConfVirtualExtraSetting") {
                var model = CreateScheduleConferenceRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting()
                model.fromMap(dict["MoziConfVirtualExtraSetting"] as! [String: Any])
                self.moziConfVirtualExtraSetting = model
            }
            if dict.keys.contains("MuteOnJoin") {
                self.muteOnJoin = dict["MuteOnJoin"] as! Int32
            }
            if dict.keys.contains("ScreenShareForbidden") {
                self.screenShareForbidden = dict["ScreenShareForbidden"] as! Int32
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var scheduleConfSettingModel: CreateScheduleConferenceRequest.ScheduleConfSettingModel?

    public var startTime: Int64?

    public var tenantContext: CreateScheduleConferenceRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scheduleConfSettingModel?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConfSettingModel != nil {
            map["ScheduleConfSettingModel"] = self.scheduleConfSettingModel?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConfSettingModel") {
            var model = CreateScheduleConferenceRequest.ScheduleConfSettingModel()
            model.fromMap(dict["ScheduleConfSettingModel"] as! [String: Any])
            self.scheduleConfSettingModel = model
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var scheduleConfSettingModelShrink: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConfSettingModelShrink != nil {
            map["ScheduleConfSettingModel"] = self.scheduleConfSettingModelShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConfSettingModel") {
            self.scheduleConfSettingModelShrink = dict["ScheduleConfSettingModel"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateScheduleConferenceResponseBody : Tea.TeaModel {
    public var phones: [String]?

    public var requestId: String?

    public var roomCode: String?

    public var scheduleConferenceId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.phones != nil {
            map["phones"] = self.phones!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("phones") {
            self.phones = dict["phones"] as! [String]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") {
            self.roomCode = dict["roomCode"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
    }
}

public class CreateScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchDomeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var userToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userToken != nil {
                map["userToken"] = self.userToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("userToken") {
                self.userToken = dict["userToken"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSearchDomeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateSearchDomeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSearchDomeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSearchDomeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: String?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContext: CreateSearchDomeRequest.TenantContext?

    public var userIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateSearchDomeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserIdList") {
            self.userIdList = dict["UserIdList"] as! [String]
        }
    }
}

public class CreateSearchDomeShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var userIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userIdListShrink != nil {
            map["UserIdList"] = self.userIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdListShrink = dict["UserIdList"] as! String
        }
    }
}

public class CreateSearchDomeResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateSearchDomeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchDomeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchDomeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchKeywordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var userToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userToken != nil {
                map["userToken"] = self.userToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("userToken") {
                self.userToken = dict["userToken"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSearchKeywordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateSearchKeywordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSearchKeywordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSearchKeywordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: String?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContext: CreateSearchKeywordRequest.TenantContext?

    public var userIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateSearchKeywordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserIdList") {
            self.userIdList = dict["UserIdList"] as! [String]
        }
    }
}

public class CreateSearchKeywordShrinkRequest : Tea.TeaModel {
    public var content: String?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var userIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userIdListShrink != nil {
            map["UserIdList"] = self.userIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdListShrink = dict["UserIdList"] as! String
        }
    }
}

public class CreateSearchKeywordResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateSearchKeywordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchKeywordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchKeywordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var tenantContext: CreateSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class CreateSheetShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class CreateSheetResponseBody : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var requestId: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.visibility != nil {
            map["visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("visibility") {
            self.visibility = dict["visibility"] as! String
        }
    }
}

public class CreateSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSubscribedCalendarRequest : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var corpIds: [String]?

        public var openConversationIds: [String]?

        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpIds != nil {
                map["CorpIds"] = self.corpIds!
            }
            if self.openConversationIds != nil {
                map["OpenConversationIds"] = self.openConversationIds!
            }
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpIds") {
                self.corpIds = dict["CorpIds"] as! [String]
            }
            if dict.keys.contains("OpenConversationIds") {
                self.openConversationIds = dict["OpenConversationIds"] as! [String]
            }
            if dict.keys.contains("UserIds") {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var subscribeScope: CreateSubscribedCalendarRequest.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScope != nil {
            map["SubscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") {
            self.managers = dict["Managers"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") {
            var model = CreateSubscribedCalendarRequest.SubscribeScope()
            model.fromMap(dict["SubscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class CreateSubscribedCalendarShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var managersShrink: String?

    public var name: String?

    public var subscribeScopeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScopeShrink != nil {
            map["SubscribeScope"] = self.subscribeScopeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") {
            self.managersShrink = dict["Managers"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") {
            self.subscribeScopeShrink = dict["SubscribeScope"] as! String
        }
    }
}

public class CreateSubscribedCalendarResponseBody : Tea.TeaModel {
    public var calendarId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("calendarId") {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateThreadHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
    }
}

public class CreateThreadRequest : Tea.TeaModel {
    public var assistantId: String?

    public var metadata: [String: Any]?

    public var originalAssistantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistantId != nil {
            map["assistantId"] = self.assistantId!
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.originalAssistantId != nil {
            map["originalAssistantId"] = self.originalAssistantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assistantId") {
            self.assistantId = dict["assistantId"] as! String
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("originalAssistantId") {
            self.originalAssistantId = dict["originalAssistantId"] as! String
        }
    }
}

public class CreateThreadResponseBody : Tea.TeaModel {
    public var createAt: Int64?

    public var id: String?

    public var metadata: [String: Any]?

    public var object: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createAt != nil {
            map["createAt"] = self.createAt!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createAt") {
            self.createAt = dict["createAt"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("object") {
            self.object = dict["object"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateThreadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateThreadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateThreadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTicketHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateTicketHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateTicketHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateTicketShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateTicketRequest : Tea.TeaModel {
    public class Notify : Tea.TeaModel {
        public var groupNoticeReceiverUserIds: [String]?

        public var noticeAllGroupMember: Bool?

        public var workNoticeReceiverUserIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupNoticeReceiverUserIds != nil {
                map["GroupNoticeReceiverUserIds"] = self.groupNoticeReceiverUserIds!
            }
            if self.noticeAllGroupMember != nil {
                map["NoticeAllGroupMember"] = self.noticeAllGroupMember!
            }
            if self.workNoticeReceiverUserIds != nil {
                map["WorkNoticeReceiverUserIds"] = self.workNoticeReceiverUserIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupNoticeReceiverUserIds") {
                self.groupNoticeReceiverUserIds = dict["GroupNoticeReceiverUserIds"] as! [String]
            }
            if dict.keys.contains("NoticeAllGroupMember") {
                self.noticeAllGroupMember = dict["NoticeAllGroupMember"] as! Bool
            }
            if dict.keys.contains("WorkNoticeReceiverUserIds") {
                self.workNoticeReceiverUserIds = dict["WorkNoticeReceiverUserIds"] as! [String]
            }
        }
    }
    public class SceneContext : Tea.TeaModel {
        public class GroupMsgs : Tea.TeaModel {
            public var anchor: Bool?

            public var openMsgId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.anchor != nil {
                    map["Anchor"] = self.anchor!
                }
                if self.openMsgId != nil {
                    map["OpenMsgId"] = self.openMsgId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Anchor") {
                    self.anchor = dict["Anchor"] as! Bool
                }
                if dict.keys.contains("OpenMsgId") {
                    self.openMsgId = dict["OpenMsgId"] as! String
                }
            }
        }
        public var groupMsgs: [CreateTicketRequest.SceneContext.GroupMsgs]?

        public var openConversationId: String?

        public var relevantorUserIds: [String]?

        public var topicId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupMsgs != nil {
                var tmp : [Any] = []
                for k in self.groupMsgs! {
                    tmp.append(k.toMap())
                }
                map["GroupMsgs"] = tmp
            }
            if self.openConversationId != nil {
                map["OpenConversationId"] = self.openConversationId!
            }
            if self.relevantorUserIds != nil {
                map["RelevantorUserIds"] = self.relevantorUserIds!
            }
            if self.topicId != nil {
                map["TopicId"] = self.topicId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupMsgs") {
                var tmp : [CreateTicketRequest.SceneContext.GroupMsgs] = []
                for v in dict["GroupMsgs"] as! [Any] {
                    var model = CreateTicketRequest.SceneContext.GroupMsgs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupMsgs = tmp
            }
            if dict.keys.contains("OpenConversationId") {
                self.openConversationId = dict["OpenConversationId"] as! String
            }
            if dict.keys.contains("RelevantorUserIds") {
                self.relevantorUserIds = dict["RelevantorUserIds"] as! [String]
            }
            if dict.keys.contains("TopicId") {
                self.topicId = dict["TopicId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var customFields: String?

    public var notify: CreateTicketRequest.Notify?

    public var openTeamId: String?

    public var openTemplateBizId: String?

    public var processorUserIds: [String]?

    public var scene: String?

    public var sceneContext: CreateTicketRequest.SceneContext?

    public var tenantContext: CreateTicketRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notify?.validate()
        try self.sceneContext?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customFields != nil {
            map["CustomFields"] = self.customFields!
        }
        if self.notify != nil {
            map["Notify"] = self.notify?.toMap()
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTemplateBizId != nil {
            map["OpenTemplateBizId"] = self.openTemplateBizId!
        }
        if self.processorUserIds != nil {
            map["ProcessorUserIds"] = self.processorUserIds!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.sceneContext != nil {
            map["SceneContext"] = self.sceneContext?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomFields") {
            self.customFields = dict["CustomFields"] as! String
        }
        if dict.keys.contains("Notify") {
            var model = CreateTicketRequest.Notify()
            model.fromMap(dict["Notify"] as! [String: Any])
            self.notify = model
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTemplateBizId") {
            self.openTemplateBizId = dict["OpenTemplateBizId"] as! String
        }
        if dict.keys.contains("ProcessorUserIds") {
            self.processorUserIds = dict["ProcessorUserIds"] as! [String]
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("SceneContext") {
            var model = CreateTicketRequest.SceneContext()
            model.fromMap(dict["SceneContext"] as! [String: Any])
            self.sceneContext = model
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateTicketRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateTicketShrinkRequest : Tea.TeaModel {
    public var customFields: String?

    public var notifyShrink: String?

    public var openTeamId: String?

    public var openTemplateBizId: String?

    public var processorUserIdsShrink: String?

    public var scene: String?

    public var sceneContextShrink: String?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customFields != nil {
            map["CustomFields"] = self.customFields!
        }
        if self.notifyShrink != nil {
            map["Notify"] = self.notifyShrink!
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTemplateBizId != nil {
            map["OpenTemplateBizId"] = self.openTemplateBizId!
        }
        if self.processorUserIdsShrink != nil {
            map["ProcessorUserIds"] = self.processorUserIdsShrink!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.sceneContextShrink != nil {
            map["SceneContext"] = self.sceneContextShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomFields") {
            self.customFields = dict["CustomFields"] as! String
        }
        if dict.keys.contains("Notify") {
            self.notifyShrink = dict["Notify"] as! String
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTemplateBizId") {
            self.openTemplateBizId = dict["OpenTemplateBizId"] as! String
        }
        if dict.keys.contains("ProcessorUserIds") {
            self.processorUserIdsShrink = dict["ProcessorUserIds"] as! String
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("SceneContext") {
            self.sceneContextShrink = dict["SceneContext"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateTicketResponseBody : Tea.TeaModel {
    public var openTicketId: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTicketId != nil {
            map["openTicketId"] = self.openTicketId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("openTicketId") {
            self.openTicketId = dict["openTicketId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class ActionList : Tea.TeaModel {
        public class Param : Tea.TeaModel {
            public var body: String?

            public var header: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.body != nil {
                    map["body"] = self.body!
                }
                if self.header != nil {
                    map["header"] = self.header!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("body") {
                    self.body = dict["body"] as! String
                }
                if dict.keys.contains("header") {
                    self.header = dict["header"] as! [String: String]
                }
            }
        }
        public var actionKey: String?

        public var actionType: Int32?

        public var buttonStyleType: Int32?

        public var param: CreateTodoTaskRequest.ActionList.Param?

        public var pcUrl: String?

        public var title: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.param?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionKey != nil {
                map["actionKey"] = self.actionKey!
            }
            if self.actionType != nil {
                map["actionType"] = self.actionType!
            }
            if self.buttonStyleType != nil {
                map["buttonStyleType"] = self.buttonStyleType!
            }
            if self.param != nil {
                map["param"] = self.param?.toMap()
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actionKey") {
                self.actionKey = dict["actionKey"] as! String
            }
            if dict.keys.contains("actionType") {
                self.actionType = dict["actionType"] as! Int32
            }
            if dict.keys.contains("buttonStyleType") {
                self.buttonStyleType = dict["buttonStyleType"] as! Int32
            }
            if dict.keys.contains("param") {
                var model = CreateTodoTaskRequest.ActionList.Param()
                model.fromMap(dict["param"] as! [String: Any])
                self.param = model
            }
            if dict.keys.contains("pcUrl") {
                self.pcUrl = dict["pcUrl"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public class ContentFieldList : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["appUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUrl") {
                self.appUrl = dict["appUrl"] as! String
            }
            if dict.keys.contains("pcUrl") {
                self.pcUrl = dict["pcUrl"] as! String
            }
        }
    }
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["dingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dingNotify") {
                self.dingNotify = dict["dingNotify"] as! String
            }
        }
    }
    public var tenantContext: CreateTodoTaskRequest.TenantContext?

    public var actionList: [CreateTodoTaskRequest.ActionList]?

    public var contentFieldList: [CreateTodoTaskRequest.ContentFieldList]?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: CreateTodoTaskRequest.DetailUrl?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var isOnlyShowExecutor: Bool?

    public var notifyConfigs: CreateTodoTaskRequest.NotifyConfigs?

    public var operatorId: String?

    public var participantIds: [String]?

    public var priority: Int32?

    public var sourceId: String?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
        try self.detailUrl?.validate()
        try self.notifyConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.actionList != nil {
            var tmp : [Any] = []
            for k in self.actionList! {
                tmp.append(k.toMap())
            }
            map["actionList"] = tmp
        }
        if self.contentFieldList != nil {
            var tmp : [Any] = []
            for k in self.contentFieldList! {
                tmp.append(k.toMap())
            }
            map["contentFieldList"] = tmp
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.notifyConfigs != nil {
            map["notifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = CreateTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("actionList") {
            var tmp : [CreateTodoTaskRequest.ActionList] = []
            for v in dict["actionList"] as! [Any] {
                var model = CreateTodoTaskRequest.ActionList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.actionList = tmp
        }
        if dict.keys.contains("contentFieldList") {
            var tmp : [CreateTodoTaskRequest.ContentFieldList] = []
            for v in dict["contentFieldList"] as! [Any] {
                var model = CreateTodoTaskRequest.ContentFieldList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contentFieldList = tmp
        }
        if dict.keys.contains("creatorId") {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") {
            var model = CreateTodoTaskRequest.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("dueTime") {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("isOnlyShowExecutor") {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("notifyConfigs") {
            var model = CreateTodoTaskRequest.NotifyConfigs()
            model.fromMap(dict["notifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("participantIds") {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("sourceId") {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var actionListShrink: String?

    public var contentFieldListShrink: String?

    public var creatorId: String?

    public var description_: String?

    public var detailUrlShrink: String?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var isOnlyShowExecutor: Bool?

    public var notifyConfigsShrink: String?

    public var operatorId: String?

    public var participantIdsShrink: String?

    public var priority: Int32?

    public var sourceId: String?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.actionListShrink != nil {
            map["actionList"] = self.actionListShrink!
        }
        if self.contentFieldListShrink != nil {
            map["contentFieldList"] = self.contentFieldListShrink!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrlShrink != nil {
            map["detailUrl"] = self.detailUrlShrink!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["executorIds"] = self.executorIdsShrink!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.notifyConfigsShrink != nil {
            map["notifyConfigs"] = self.notifyConfigsShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.participantIdsShrink != nil {
            map["participantIds"] = self.participantIdsShrink!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("actionList") {
            self.actionListShrink = dict["actionList"] as! String
        }
        if dict.keys.contains("contentFieldList") {
            self.contentFieldListShrink = dict["contentFieldList"] as! String
        }
        if dict.keys.contains("creatorId") {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") {
            self.detailUrlShrink = dict["detailUrl"] as! String
        }
        if dict.keys.contains("dueTime") {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") {
            self.executorIdsShrink = dict["executorIds"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("notifyConfigs") {
            self.notifyConfigsShrink = dict["notifyConfigs"] as! String
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("participantIds") {
            self.participantIdsShrink = dict["participantIds"] as! String
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("sourceId") {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskResponseBody : Tea.TeaModel {
    public class ContentFieldList : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["appUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUrl") {
                self.appUrl = dict["appUrl"] as! String
            }
            if dict.keys.contains("pcUrl") {
                self.pcUrl = dict["pcUrl"] as! String
            }
        }
    }
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["dingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dingNotify") {
                self.dingNotify = dict["dingNotify"] as! String
            }
        }
    }
    public var bizTag: String?

    public var contentFieldList: [CreateTodoTaskResponseBody.ContentFieldList]?

    public var createdTime: Int64?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: CreateTodoTaskResponseBody.DetailUrl?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var finishTime: Int64?

    public var id: String?

    public var isOnlyShowExecutor: Bool?

    public var modifiedTime: Int64?

    public var modifierId: String?

    public var notifyConfigs: CreateTodoTaskResponseBody.NotifyConfigs?

    public var participantIds: [String]?

    public var priority: Int32?

    public var requestId: String?

    public var source: String?

    public var sourceId: String?

    public var startTime: Int64?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailUrl?.validate()
        try self.notifyConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizTag != nil {
            map["bizTag"] = self.bizTag!
        }
        if self.contentFieldList != nil {
            var tmp : [Any] = []
            for k in self.contentFieldList! {
                tmp.append(k.toMap())
            }
            map["contentFieldList"] = tmp
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.finishTime != nil {
            map["finishTime"] = self.finishTime!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.modifiedTime != nil {
            map["modifiedTime"] = self.modifiedTime!
        }
        if self.modifierId != nil {
            map["modifierId"] = self.modifierId!
        }
        if self.notifyConfigs != nil {
            map["notifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("bizTag") {
            self.bizTag = dict["bizTag"] as! String
        }
        if dict.keys.contains("contentFieldList") {
            var tmp : [CreateTodoTaskResponseBody.ContentFieldList] = []
            for v in dict["contentFieldList"] as! [Any] {
                var model = CreateTodoTaskResponseBody.ContentFieldList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contentFieldList = tmp
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creatorId") {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") {
            var model = CreateTodoTaskResponseBody.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("done") {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("finishTime") {
            self.finishTime = dict["finishTime"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("modifiedTime") {
            self.modifiedTime = dict["modifiedTime"] as! Int64
        }
        if dict.keys.contains("modifierId") {
            self.modifierId = dict["modifierId"] as! String
        }
        if dict.keys.contains("notifyConfigs") {
            var model = CreateTodoTaskResponseBody.NotifyConfigs()
            model.fromMap(dict["notifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("participantIds") {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("sourceId") {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVideoConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateVideoConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateVideoConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateVideoConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateVideoConferenceRequest : Tea.TeaModel {
    public var confTitle: String?

    public var inviteCaller: Bool?

    public var inviteUserIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confTitle != nil {
            map["ConfTitle"] = self.confTitle!
        }
        if self.inviteCaller != nil {
            map["InviteCaller"] = self.inviteCaller!
        }
        if self.inviteUserIds != nil {
            map["InviteUserIds"] = self.inviteUserIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfTitle") {
            self.confTitle = dict["ConfTitle"] as! String
        }
        if dict.keys.contains("InviteCaller") {
            self.inviteCaller = dict["InviteCaller"] as! Bool
        }
        if dict.keys.contains("InviteUserIds") {
            self.inviteUserIds = dict["InviteUserIds"] as! [String]
        }
    }
}

public class CreateVideoConferenceShrinkRequest : Tea.TeaModel {
    public var confTitle: String?

    public var inviteCaller: Bool?

    public var inviteUserIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confTitle != nil {
            map["ConfTitle"] = self.confTitle!
        }
        if self.inviteCaller != nil {
            map["InviteCaller"] = self.inviteCaller!
        }
        if self.inviteUserIdsShrink != nil {
            map["InviteUserIds"] = self.inviteUserIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfTitle") {
            self.confTitle = dict["ConfTitle"] as! String
        }
        if dict.keys.contains("InviteCaller") {
            self.inviteCaller = dict["InviteCaller"] as! Bool
        }
        if dict.keys.contains("InviteUserIds") {
            self.inviteUserIdsShrink = dict["InviteUserIds"] as! String
        }
    }
}

public class CreateVideoConferenceResponseBody : Tea.TeaModel {
    public var conferenceId: String?

    public var conferencePassword: String?

    public var externalLinkUrl: String?

    public var hostPassword: String?

    public var phoneNumbers: [String]?

    public var requestId: String?

    public var roomCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.conferencePassword != nil {
            map["conferencePassword"] = self.conferencePassword!
        }
        if self.externalLinkUrl != nil {
            map["externalLinkUrl"] = self.externalLinkUrl!
        }
        if self.hostPassword != nil {
            map["hostPassword"] = self.hostPassword!
        }
        if self.phoneNumbers != nil {
            map["phoneNumbers"] = self.phoneNumbers!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("conferencePassword") {
            self.conferencePassword = dict["conferencePassword"] as! String
        }
        if dict.keys.contains("externalLinkUrl") {
            self.externalLinkUrl = dict["externalLinkUrl"] as! String
        }
        if dict.keys.contains("hostPassword") {
            self.hostPassword = dict["hostPassword"] as! String
        }
        if dict.keys.contains("phoneNumbers") {
            self.phoneNumbers = dict["phoneNumbers"] as! [String]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") {
            self.roomCode = dict["roomCode"] as! String
        }
    }
}

public class CreateVideoConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVideoConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVideoConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var description_: String?

    public var name: String?

    public var tenantContext: CreateWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateWorkspaceShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateWorkspaceResponseBody : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var requestId: String?

    public var url: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.workspaceId != nil {
            map["workspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("workspaceId") {
            self.workspaceId = dict["workspaceId"] as! String
        }
    }
}

public class CreateWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceDocHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateWorkspaceDocHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = CreateWorkspaceDocHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateWorkspaceDocShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateWorkspaceDocRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var docType: String?

    public var name: String?

    public var parentNodeId: String?

    public var templateId: String?

    public var templateType: String?

    public var tenantContext: CreateWorkspaceDocRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docType != nil {
            map["DocType"] = self.docType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocType") {
            self.docType = dict["DocType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentNodeId") {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = CreateWorkspaceDocRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocShrinkRequest : Tea.TeaModel {
    public var docType: String?

    public var name: String?

    public var parentNodeId: String?

    public var templateId: String?

    public var templateType: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docType != nil {
            map["DocType"] = self.docType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocType") {
            self.docType = dict["DocType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentNodeId") {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocResponseBody : Tea.TeaModel {
    public var dentryUuid: String?

    public var docKey: String?

    public var nodeId: String?

    public var requestId: String?

    public var url: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["dentryUuid"] = self.dentryUuid!
        }
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.nodeId != nil {
            map["nodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        if self.workspaceId != nil {
            map["workspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dentryUuid") {
            self.dentryUuid = dict["dentryUuid"] as! String
        }
        if dict.keys.contains("docKey") {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("nodeId") {
            self.nodeId = dict["nodeId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
        if dict.keys.contains("workspaceId") {
            self.workspaceId = dict["workspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceDocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkspaceDocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteColumnsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteColumnsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteColumnsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteColumnsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteColumnsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: DeleteColumnsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteColumnsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteColumnsShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteColumnsResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDriveSpaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteDriveSpaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteDriveSpaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteDriveSpaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteDriveSpaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var spaceId: String?

    public var tenantContext: DeleteDriveSpaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteDriveSpaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteDriveSpaceShrinkRequest : Tea.TeaModel {
    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteDriveSpaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class DeleteDriveSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDriveSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDriveSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteEventRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var pushNotification: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.pushNotification != nil {
            map["pushNotification"] = self.pushNotification!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("pushNotification") {
            self.pushNotification = dict["pushNotification"] as! Bool
        }
    }
}

public class DeleteEventResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: DeleteEventResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            var model = DeleteEventResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceId: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceId") {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class DeleteFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class DeleteFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: DeleteLiveRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteLiveShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteLiveResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteMeetingRoomRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var roomId: String?

    public var tenantContext: DeleteMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteMeetingRoomShrinkRequest : Tea.TeaModel {
    public var roomId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteMeetingRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var tenantContext: DeleteMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRowsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteRowsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteRowsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteRowsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteRowsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: DeleteRowsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteRowsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteRowsShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteRowsResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteRowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRowsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenegroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteScenegroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteScenegroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteScenegroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteScenegroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class DeleteScenegroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteScenegroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenegroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScenegroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var sheetId: String?

    public var tenantContext: DeleteSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteSheetShrinkRequest : Tea.TeaModel {
    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteSheetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteSubscribedCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class DeleteSubscribedCalendarResponseBody : Tea.TeaModel {
    public var result: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: DeleteTodoTaskRequest.TenantContext?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = DeleteTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteTodoTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") {
                self.memberType = dict["MemberType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [DeleteWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: DeleteWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [DeleteWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = DeleteWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = DeleteWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") {
                self.memberType = dict["MemberType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [DeleteWorkspaceMembersRequest.Members]?

    public var tenantContext: DeleteWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [DeleteWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = DeleteWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") {
            var model = DeleteWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteBatchTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExecuteBatchTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ExecuteBatchTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExecuteBatchTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExecuteBatchTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var outResult: String?

    public var remark: String?

    public var systemToken: String?

    public var taskInformationList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.outResult != nil {
            map["OutResult"] = self.outResult!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskInformationList != nil {
            map["TaskInformationList"] = self.taskInformationList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("OutResult") {
            self.outResult = dict["OutResult"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskInformationList") {
            self.taskInformationList = dict["TaskInformationList"] as! String
        }
    }
}

public class ExecuteBatchTaskResponseBody : Tea.TeaModel {
    public var failNumber: Int32?

    public var requestId: String?

    public var successNumber: Int32?

    public var total: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failNumber != nil {
            map["failNumber"] = self.failNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.successNumber != nil {
            map["successNumber"] = self.successNumber!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failNumber") {
            self.failNumber = dict["failNumber"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("successNumber") {
            self.successNumber = dict["successNumber"] as! Int32
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExecuteBatchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteBatchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteBatchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecutePlatformTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExecutePlatformTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ExecutePlatformTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExecutePlatformTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExecutePlatformTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var formDataJson: String?

    public var language: String?

    public var noExecuteExpressions: String?

    public var outResult: String?

    public var processInstanceId: String?

    public var remark: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.noExecuteExpressions != nil {
            map["NoExecuteExpressions"] = self.noExecuteExpressions!
        }
        if self.outResult != nil {
            map["OutResult"] = self.outResult!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormDataJson") {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NoExecuteExpressions") {
            self.noExecuteExpressions = dict["NoExecuteExpressions"] as! String
        }
        if dict.keys.contains("OutResult") {
            self.outResult = dict["OutResult"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ExecutePlatformTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExecutePlatformTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecutePlatformTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecutePlatformTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExecuteTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ExecuteTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExecuteTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExecuteTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var digitalSignUrl: String?

    public var formDataJson: String?

    public var language: String?

    public var noExecuteExpressions: String?

    public var outResult: String?

    public var processInstanceId: String?

    public var remark: String?

    public var systemToken: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.digitalSignUrl != nil {
            map["DigitalSignUrl"] = self.digitalSignUrl!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.noExecuteExpressions != nil {
            map["NoExecuteExpressions"] = self.noExecuteExpressions!
        }
        if self.outResult != nil {
            map["OutResult"] = self.outResult!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("DigitalSignUrl") {
            self.digitalSignUrl = dict["DigitalSignUrl"] as! String
        }
        if dict.keys.contains("FormDataJson") {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NoExecuteExpressions") {
            self.noExecuteExpressions = dict["NoExecuteExpressions"] as! String
        }
        if dict.keys.contains("OutResult") {
            self.outResult = dict["OutResult"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class ExecuteTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExecuteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecuteTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExpandGroupCapacityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExpandGroupCapacityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ExpandGroupCapacityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExpandGroupCapacityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExpandGroupCapacityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var openConversationId: String?

    public var tenantContext: ExpandGroupCapacityRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ExpandGroupCapacityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ExpandGroupCapacityShrinkRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ExpandGroupCapacityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExpandGroupCapacityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExpandGroupCapacityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExpandGroupCapacityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FinishTicketHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: FinishTicketHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = FinishTicketHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class FinishTicketShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class FinishTicketRequest : Tea.TeaModel {
    public class Notify : Tea.TeaModel {
        public var groupNoticeReceiverUserIds: [String]?

        public var noticeAllGroupMember: Bool?

        public var workNoticeReceiverUserIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupNoticeReceiverUserIds != nil {
                map["GroupNoticeReceiverUserIds"] = self.groupNoticeReceiverUserIds!
            }
            if self.noticeAllGroupMember != nil {
                map["NoticeAllGroupMember"] = self.noticeAllGroupMember!
            }
            if self.workNoticeReceiverUserIds != nil {
                map["WorkNoticeReceiverUserIds"] = self.workNoticeReceiverUserIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupNoticeReceiverUserIds") {
                self.groupNoticeReceiverUserIds = dict["GroupNoticeReceiverUserIds"] as! [String]
            }
            if dict.keys.contains("NoticeAllGroupMember") {
                self.noticeAllGroupMember = dict["NoticeAllGroupMember"] as! Bool
            }
            if dict.keys.contains("WorkNoticeReceiverUserIds") {
                self.workNoticeReceiverUserIds = dict["WorkNoticeReceiverUserIds"] as! [String]
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class TicketMemo : Tea.TeaModel {
        public class Attachments : Tea.TeaModel {
            public var fileName: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
            }
        }
        public var attachments: [FinishTicketRequest.TicketMemo.Attachments]?

        public var memo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachments != nil {
                var tmp : [Any] = []
                for k in self.attachments! {
                    tmp.append(k.toMap())
                }
                map["Attachments"] = tmp
            }
            if self.memo != nil {
                map["Memo"] = self.memo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attachments") {
                var tmp : [FinishTicketRequest.TicketMemo.Attachments] = []
                for v in dict["Attachments"] as! [Any] {
                    var model = FinishTicketRequest.TicketMemo.Attachments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachments = tmp
            }
            if dict.keys.contains("Memo") {
                self.memo = dict["Memo"] as! String
            }
        }
    }
    public var notify: FinishTicketRequest.Notify?

    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContext: FinishTicketRequest.TenantContext?

    public var ticketMemo: FinishTicketRequest.TicketMemo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notify?.validate()
        try self.tenantContext?.validate()
        try self.ticketMemo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notify != nil {
            map["Notify"] = self.notify?.toMap()
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.ticketMemo != nil {
            map["TicketMemo"] = self.ticketMemo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Notify") {
            var model = FinishTicketRequest.Notify()
            model.fromMap(dict["Notify"] as! [String: Any])
            self.notify = model
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = FinishTicketRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("TicketMemo") {
            var model = FinishTicketRequest.TicketMemo()
            model.fromMap(dict["TicketMemo"] as! [String: Any])
            self.ticketMemo = model
        }
    }
}

public class FinishTicketShrinkRequest : Tea.TeaModel {
    public var notifyShrink: String?

    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContextShrink: String?

    public var ticketMemoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notifyShrink != nil {
            map["Notify"] = self.notifyShrink!
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.ticketMemoShrink != nil {
            map["TicketMemo"] = self.ticketMemoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Notify") {
            self.notifyShrink = dict["Notify"] as! String
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("TicketMemo") {
            self.ticketMemoShrink = dict["TicketMemo"] as! String
        }
    }
}

public class FinishTicketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class FinishTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FinishTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FinishTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetActivityListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetActivityListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetActivityListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetActivityListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetActivityListRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processCode: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processCode != nil {
            map["ProcessCode"] = self.processCode!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessCode") {
            self.processCode = dict["ProcessCode"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetActivityListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var activityId: String?

        public var activityName: String?

        public var activityNameInEnglish: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.activityName != nil {
                map["ActivityName"] = self.activityName!
            }
            if self.activityNameInEnglish != nil {
                map["ActivityNameInEnglish"] = self.activityNameInEnglish!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("ActivityName") {
                self.activityName = dict["ActivityName"] as! String
            }
            if dict.keys.contains("ActivityNameInEnglish") {
                self.activityNameInEnglish = dict["ActivityNameInEnglish"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetActivityListResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [GetActivityListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetActivityListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetActivityListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetActivityListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetActivityListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAllSheetsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetAllSheetsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetAllSheetsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetAllSheetsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetAllSheetsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetAllSheetsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GetAllSheetsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetAllSheetsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetAllSheetsResponseBody : Tea.TeaModel {
    public class Value : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var requestId: String?

    public var value: [GetAllSheetsResponseBody.Value]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.value != nil {
            var tmp : [Any] = []
            for k in self.value! {
                tmp.append(k.toMap())
            }
            map["value"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("value") {
            var tmp : [GetAllSheetsResponseBody.Value] = []
            for v in dict["value"] as! [Any] {
                var model = GetAllSheetsResponseBody.Value()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.value = tmp
        }
    }
}

public class GetAllSheetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAllSheetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAllSheetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetConversaionSpaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetConversaionSpaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetConversaionSpaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetConversaionSpaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetConversaionSpaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var openConversationId: String?

    public var tenantContext: GetConversaionSpaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetConversaionSpaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetConversaionSpaceShrinkRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetConversaionSpaceResponseBody : Tea.TeaModel {
    public class Space : Tea.TeaModel {
        public var corpId: String?

        public var createTime: String?

        public var modifiedTime: String?

        public var spaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var space: GetConversaionSpaceResponseBody.Space?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.space?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.space != nil {
            map["space"] = self.space?.toMap()
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("space") {
            var model = GetConversaionSpaceResponseBody.Space()
            model.fromMap(dict["space"] as! [String: Any])
            self.space = model
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetConversaionSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConversaionSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetConversaionSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCorpAccomplishmentTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetCorpAccomplishmentTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetCorpAccomplishmentTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetCorpAccomplishmentTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetCorpAccomplishmentTasksRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetCorpAccomplishmentTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var activeTimeGMT: String?

        public var actualActionerId: String?

        public var appType: String?

        public var createTimeGMT: String?

        public var finishTimeGMT: String?

        public var originatorEmail: String?

        public var originatorId: String?

        public var originatorName: String?

        public var originatorNameInEnglish: String?

        public var originatorNickName: String?

        public var originatorNickNameInEnglish: String?

        public var originatorPhoto: String?

        public var outResult: String?

        public var outResultName: String?

        public var processInstanceId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.actualActionerId != nil {
                map["ActualActionerId"] = self.actualActionerId!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.originatorEmail != nil {
                map["OriginatorEmail"] = self.originatorEmail!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.originatorName != nil {
                map["OriginatorName"] = self.originatorName!
            }
            if self.originatorNameInEnglish != nil {
                map["OriginatorNameInEnglish"] = self.originatorNameInEnglish!
            }
            if self.originatorNickName != nil {
                map["OriginatorNickName"] = self.originatorNickName!
            }
            if self.originatorNickNameInEnglish != nil {
                map["OriginatorNickNameInEnglish"] = self.originatorNickNameInEnglish!
            }
            if self.originatorPhoto != nil {
                map["OriginatorPhoto"] = self.originatorPhoto!
            }
            if self.outResult != nil {
                map["OutResult"] = self.outResult!
            }
            if self.outResultName != nil {
                map["OutResultName"] = self.outResultName!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveTimeGMT") {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActualActionerId") {
                self.actualActionerId = dict["ActualActionerId"] as! String
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorEmail") {
                self.originatorEmail = dict["OriginatorEmail"] as! String
            }
            if dict.keys.contains("OriginatorId") {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("OriginatorName") {
                self.originatorName = dict["OriginatorName"] as! String
            }
            if dict.keys.contains("OriginatorNameInEnglish") {
                self.originatorNameInEnglish = dict["OriginatorNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorNickName") {
                self.originatorNickName = dict["OriginatorNickName"] as! String
            }
            if dict.keys.contains("OriginatorNickNameInEnglish") {
                self.originatorNickNameInEnglish = dict["OriginatorNickNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorPhoto") {
                self.originatorPhoto = dict["OriginatorPhoto"] as! String
            }
            if dict.keys.contains("OutResult") {
                self.outResult = dict["OutResult"] as! String
            }
            if dict.keys.contains("OutResultName") {
                self.outResultName = dict["OutResultName"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var data: [GetCorpAccomplishmentTasksResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [GetCorpAccomplishmentTasksResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetCorpAccomplishmentTasksResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetCorpAccomplishmentTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCorpAccomplishmentTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCorpAccomplishmentTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCorpTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetCorpTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetCorpTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetCorpTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetCorpTasksRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetCorpTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var activeTimeGMT: String?

        public var actualActionerId: String?

        public var appType: String?

        public var createTimeGMT: String?

        public var finishTimeGMT: String?

        public var originatorEmail: String?

        public var originatorId: String?

        public var originatorName: String?

        public var originatorNameInEnglish: String?

        public var originatorNickName: String?

        public var originatorNickNameEn: String?

        public var originatorNickNameInEnglish: String?

        public var originatorPhoto: String?

        public var outResult: String?

        public var outResultName: String?

        public var processInstanceId: String?

        public var status: String?

        public var taskId: String?

        public var taskType: String?

        public var title: String?

        public var titleInEnglish: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.actualActionerId != nil {
                map["ActualActionerId"] = self.actualActionerId!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.originatorEmail != nil {
                map["OriginatorEmail"] = self.originatorEmail!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.originatorName != nil {
                map["OriginatorName"] = self.originatorName!
            }
            if self.originatorNameInEnglish != nil {
                map["OriginatorNameInEnglish"] = self.originatorNameInEnglish!
            }
            if self.originatorNickName != nil {
                map["OriginatorNickName"] = self.originatorNickName!
            }
            if self.originatorNickNameEn != nil {
                map["OriginatorNickNameEn"] = self.originatorNickNameEn!
            }
            if self.originatorNickNameInEnglish != nil {
                map["OriginatorNickNameInEnglish"] = self.originatorNickNameInEnglish!
            }
            if self.originatorPhoto != nil {
                map["OriginatorPhoto"] = self.originatorPhoto!
            }
            if self.outResult != nil {
                map["OutResult"] = self.outResult!
            }
            if self.outResultName != nil {
                map["OutResultName"] = self.outResultName!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.titleInEnglish != nil {
                map["TitleInEnglish"] = self.titleInEnglish!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveTimeGMT") {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActualActionerId") {
                self.actualActionerId = dict["ActualActionerId"] as! String
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorEmail") {
                self.originatorEmail = dict["OriginatorEmail"] as! String
            }
            if dict.keys.contains("OriginatorId") {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("OriginatorName") {
                self.originatorName = dict["OriginatorName"] as! String
            }
            if dict.keys.contains("OriginatorNameInEnglish") {
                self.originatorNameInEnglish = dict["OriginatorNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorNickName") {
                self.originatorNickName = dict["OriginatorNickName"] as! String
            }
            if dict.keys.contains("OriginatorNickNameEn") {
                self.originatorNickNameEn = dict["OriginatorNickNameEn"] as! String
            }
            if dict.keys.contains("OriginatorNickNameInEnglish") {
                self.originatorNickNameInEnglish = dict["OriginatorNickNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorPhoto") {
                self.originatorPhoto = dict["OriginatorPhoto"] as! String
            }
            if dict.keys.contains("OutResult") {
                self.outResult = dict["OutResult"] as! String
            }
            if dict.keys.contains("OutResultName") {
                self.outResultName = dict["OutResultName"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("TitleInEnglish") {
                self.titleInEnglish = dict["TitleInEnglish"] as! String
            }
        }
    }
    public var data: [GetCorpTasksResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [GetCorpTasksResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetCorpTasksResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetCorpTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCorpTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCorpTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeptNoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetDeptNoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetDeptNoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetDeptNoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetDeptNoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetDeptNoRequest.TenantContext?

    public var deptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.deptId != nil {
            map["deptId"] = self.deptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GetDeptNoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("deptId") {
            self.deptId = dict["deptId"] as! String
        }
    }
}

public class GetDeptNoShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var deptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.deptId != nil {
            map["deptId"] = self.deptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("deptId") {
            self.deptId = dict["deptId"] as! String
        }
    }
}

public class GetDeptNoResponseBody : Tea.TeaModel {
    public var deptNo: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deptNo != nil {
            map["deptNo"] = self.deptNo!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("deptNo") {
            self.deptNo = dict["deptNo"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetDeptNoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeptNoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeptNoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDocContentHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetDocContentHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetDocContentHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetDocContentShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetDocContentRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryUuid: String?

    public var targetFormat: String?

    public var tenantContext: GetDocContentRequest.TenantContext?

    public var userToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.targetFormat != nil {
            map["TargetFormat"] = self.targetFormat!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userToken != nil {
            map["userToken"] = self.userToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("TargetFormat") {
            self.targetFormat = dict["TargetFormat"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetDocContentRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("userToken") {
            self.userToken = dict["userToken"] as! String
        }
    }
}

public class GetDocContentShrinkRequest : Tea.TeaModel {
    public var dentryUuid: String?

    public var targetFormat: String?

    public var tenantContextShrink: String?

    public var userToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.targetFormat != nil {
            map["TargetFormat"] = self.targetFormat!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userToken != nil {
            map["userToken"] = self.userToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("TargetFormat") {
            self.targetFormat = dict["TargetFormat"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("userToken") {
            self.userToken = dict["userToken"] as! String
        }
    }
}

public class GetDocContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetDocContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDocContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDocContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDocContentTakIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetDocContentTakIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetDocContentTakIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetDocContentTakIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetDocContentTakIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryUuid: String?

    public var generateCp: Bool?

    public var targetFormat: String?

    public var tenantContext: GetDocContentTakIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.generateCp != nil {
            map["GenerateCp"] = self.generateCp!
        }
        if self.targetFormat != nil {
            map["TargetFormat"] = self.targetFormat!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("GenerateCp") {
            self.generateCp = dict["GenerateCp"] as! Bool
        }
        if dict.keys.contains("TargetFormat") {
            self.targetFormat = dict["TargetFormat"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetDocContentTakIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetDocContentTakIdShrinkRequest : Tea.TeaModel {
    public var dentryUuid: String?

    public var generateCp: Bool?

    public var targetFormat: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.generateCp != nil {
            map["GenerateCp"] = self.generateCp!
        }
        if self.targetFormat != nil {
            map["TargetFormat"] = self.targetFormat!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("GenerateCp") {
            self.generateCp = dict["GenerateCp"] as! Bool
        }
        if dict.keys.contains("TargetFormat") {
            self.targetFormat = dict["TargetFormat"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetDocContentTakIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetDocContentTakIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDocContentTakIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDocContentTakIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetEventRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var maxAttendees: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MaxAttendees") {
            self.maxAttendees = dict["MaxAttendees"] as! Int64
        }
    }
}

public class GetEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsOptional") {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Categories : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class ExtendedProperties : Tea.TeaModel {
        public class SharedProperties : Tea.TeaModel {
            public var belongCorpId: String?

            public var sourceOpenCid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.belongCorpId != nil {
                    map["BelongCorpId"] = self.belongCorpId!
                }
                if self.sourceOpenCid != nil {
                    map["SourceOpenCid"] = self.sourceOpenCid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BelongCorpId") {
                    self.belongCorpId = dict["BelongCorpId"] as! String
                }
                if dict.keys.contains("SourceOpenCid") {
                    self.sourceOpenCid = dict["SourceOpenCid"] as! String
                }
            }
        }
        public var sharedProperties: GetEventResponseBody.ExtendedProperties.SharedProperties?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sharedProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sharedProperties != nil {
                map["SharedProperties"] = self.sharedProperties?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SharedProperties") {
                var model = GetEventResponseBody.ExtendedProperties.SharedProperties()
                model.fromMap(dict["SharedProperties"] as! [String: Any])
                self.sharedProperties = model
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public var meetingRooms: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.meetingRooms != nil {
                map["MeetingRooms"] = self.meetingRooms!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MeetingRooms") {
                self.meetingRooms = dict["MeetingRooms"] as! [String]
            }
        }
    }
    public class MeetingRooms : Tea.TeaModel {
        public var displayName: String?

        public var responseStatus: String?

        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var conferenceId: String?

        public var extraInfo: [String: Any]?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("ExtraInfo") {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class OriginStart : Tea.TeaModel {
        public var dateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: GetEventResponseBody.Recurrence.Pattern?

        public var range: GetEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") {
                var model = GetEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") {
                var model = GetEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class RichTextDescription : Tea.TeaModel {
        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Text") {
                self.text = dict["Text"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var attendees: [GetEventResponseBody.Attendees]?

    public var categories: [GetEventResponseBody.Categories]?

    public var createTime: String?

    public var description_: String?

    public var end: GetEventResponseBody.End?

    public var extendedProperties: GetEventResponseBody.ExtendedProperties?

    public var id: String?

    public var isAllDay: Bool?

    public var location: GetEventResponseBody.Location?

    public var meetingRooms: [GetEventResponseBody.MeetingRooms]?

    public var onlineMeetingInfo: GetEventResponseBody.OnlineMeetingInfo?

    public var organizer: GetEventResponseBody.Organizer?

    public var originStart: GetEventResponseBody.OriginStart?

    public var recurrence: GetEventResponseBody.Recurrence?

    public var reminders: [GetEventResponseBody.Reminders]?

    public var requestId: String?

    public var richTextDescription: GetEventResponseBody.RichTextDescription?

    public var seriesMasterId: String?

    public var start: GetEventResponseBody.Start?

    public var status: String?

    public var summary: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.extendedProperties?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.organizer?.validate()
        try self.originStart?.validate()
        try self.recurrence?.validate()
        try self.richTextDescription?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.categories != nil {
            var tmp : [Any] = []
            for k in self.categories! {
                tmp.append(k.toMap())
            }
            map["categories"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.extendedProperties != nil {
            map["extendedProperties"] = self.extendedProperties?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.meetingRooms != nil {
            var tmp : [Any] = []
            for k in self.meetingRooms! {
                tmp.append(k.toMap())
            }
            map["meetingRooms"] = tmp
        }
        if self.onlineMeetingInfo != nil {
            map["onlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.originStart != nil {
            map["originStart"] = self.originStart?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.richTextDescription != nil {
            map["richTextDescription"] = self.richTextDescription?.toMap()
        }
        if self.seriesMasterId != nil {
            map["seriesMasterId"] = self.seriesMasterId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") {
            var tmp : [GetEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = GetEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("categories") {
            var tmp : [GetEventResponseBody.Categories] = []
            for v in dict["categories"] as! [Any] {
                var model = GetEventResponseBody.Categories()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.categories = tmp
        }
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") {
            var model = GetEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("extendedProperties") {
            var model = GetEventResponseBody.ExtendedProperties()
            model.fromMap(dict["extendedProperties"] as! [String: Any])
            self.extendedProperties = model
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") {
            var model = GetEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("meetingRooms") {
            var tmp : [GetEventResponseBody.MeetingRooms] = []
            for v in dict["meetingRooms"] as! [Any] {
                var model = GetEventResponseBody.MeetingRooms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRooms = tmp
        }
        if dict.keys.contains("onlineMeetingInfo") {
            var model = GetEventResponseBody.OnlineMeetingInfo()
            model.fromMap(dict["onlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("organizer") {
            var model = GetEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("originStart") {
            var model = GetEventResponseBody.OriginStart()
            model.fromMap(dict["originStart"] as! [String: Any])
            self.originStart = model
        }
        if dict.keys.contains("recurrence") {
            var model = GetEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") {
            var tmp : [GetEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = GetEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("richTextDescription") {
            var model = GetEventResponseBody.RichTextDescription()
            model.fromMap(dict["richTextDescription"] as! [String: Any])
            self.richTextDescription = model
        }
        if dict.keys.contains("seriesMasterId") {
            self.seriesMasterId = dict["seriesMasterId"] as! String
        }
        if dict.keys.contains("start") {
            var model = GetEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("summary") {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("updateTime") {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class GetEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFieldDefByUuidHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFieldDefByUuidHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetFieldDefByUuidHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFieldDefByUuidShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFieldDefByUuidRequest : Tea.TeaModel {
    public var appType: String?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFieldDefByUuidResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var behavior: String?

        public var children: String?

        public var componentName: String?

        public var fieldId: String?

        public var label: Any?

        public var props: Any?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.behavior != nil {
                map["Behavior"] = self.behavior!
            }
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.fieldId != nil {
                map["FieldId"] = self.fieldId!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.props != nil {
                map["Props"] = self.props!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Behavior") {
                self.behavior = dict["Behavior"] as! String
            }
            if dict.keys.contains("Children") {
                self.children = dict["Children"] as! String
            }
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("FieldId") {
                self.fieldId = dict["FieldId"] as! String
            }
            if dict.keys.contains("Label") {
                self.label = dict["Label"] as! Any
            }
            if dict.keys.contains("Props") {
                self.props = dict["Props"] as! Any
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: [GetFieldDefByUuidResponseBody.Result]?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [GetFieldDefByUuidResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetFieldDefByUuidResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFieldDefByUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFieldDefByUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFieldDefByUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileDownloadInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFileDownloadInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetFileDownloadInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFileDownloadInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFileDownloadInfoRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var preferIntranet: Bool?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preferIntranet != nil {
                map["PreferIntranet"] = self.preferIntranet!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreferIntranet") {
                self.preferIntranet = dict["PreferIntranet"] as! Bool
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var option: GetFileDownloadInfoRequest.Option?

    public var spaceId: String?

    public var tenantContext: GetFileDownloadInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("Option") {
            var model = GetFileDownloadInfoRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetFileDownloadInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetFileDownloadInfoShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var optionShrink: String?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetFileDownloadInfoResponseBody : Tea.TeaModel {
    public class HeaderSignatureInfo : Tea.TeaModel {
        public var expirationSeconds: Int32?

        public var headers: [String: String]?

        public var internalResourceUrls: [String]?

        public var region: String?

        public var resourceUrls: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationSeconds != nil {
                map["ExpirationSeconds"] = self.expirationSeconds!
            }
            if self.headers != nil {
                map["Headers"] = self.headers!
            }
            if self.internalResourceUrls != nil {
                map["InternalResourceUrls"] = self.internalResourceUrls!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceUrls != nil {
                map["ResourceUrls"] = self.resourceUrls!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpirationSeconds") {
                self.expirationSeconds = dict["ExpirationSeconds"] as! Int32
            }
            if dict.keys.contains("Headers") {
                self.headers = dict["Headers"] as! [String: String]
            }
            if dict.keys.contains("InternalResourceUrls") {
                self.internalResourceUrls = dict["InternalResourceUrls"] as! [String]
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ResourceUrls") {
                self.resourceUrls = dict["ResourceUrls"] as! [String]
            }
        }
    }
    public var headerSignatureInfo: GetFileDownloadInfoResponseBody.HeaderSignatureInfo?

    public var protocol_: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headerSignatureInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headerSignatureInfo != nil {
            map["headerSignatureInfo"] = self.headerSignatureInfo?.toMap()
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headerSignatureInfo") {
            var model = GetFileDownloadInfoResponseBody.HeaderSignatureInfo()
            model.fromMap(dict["headerSignatureInfo"] as! [String: Any])
            self.headerSignatureInfo = model
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFileDownloadInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileDownloadInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileDownloadInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileUploadInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFileUploadInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetFileUploadInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFileUploadInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFileUploadInfoRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public class PreCheckParam : Tea.TeaModel {
            public var name: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
            }
        }
        public var preCheckParam: GetFileUploadInfoRequest.Option.PreCheckParam?

        public var preferIntranet: Bool?

        public var preferRegion: String?

        public var storageDriver: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.preCheckParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preCheckParam != nil {
                map["PreCheckParam"] = self.preCheckParam?.toMap()
            }
            if self.preferIntranet != nil {
                map["PreferIntranet"] = self.preferIntranet!
            }
            if self.preferRegion != nil {
                map["PreferRegion"] = self.preferRegion!
            }
            if self.storageDriver != nil {
                map["StorageDriver"] = self.storageDriver!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreCheckParam") {
                var model = GetFileUploadInfoRequest.Option.PreCheckParam()
                model.fromMap(dict["PreCheckParam"] as! [String: Any])
                self.preCheckParam = model
            }
            if dict.keys.contains("PreferIntranet") {
                self.preferIntranet = dict["PreferIntranet"] as! Bool
            }
            if dict.keys.contains("PreferRegion") {
                self.preferRegion = dict["PreferRegion"] as! String
            }
            if dict.keys.contains("StorageDriver") {
                self.storageDriver = dict["StorageDriver"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetFileUploadInfoRequest.Option?

    public var parentDentryUuid: String?

    public var protocol_: String?

    public var tenantContext: GetFileUploadInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.parentDentryUuid != nil {
            map["ParentDentryUuid"] = self.parentDentryUuid!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            var model = GetFileUploadInfoRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("ParentDentryUuid") {
            self.parentDentryUuid = dict["ParentDentryUuid"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetFileUploadInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetFileUploadInfoShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var parentDentryUuid: String?

    public var protocol_: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.parentDentryUuid != nil {
            map["ParentDentryUuid"] = self.parentDentryUuid!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("ParentDentryUuid") {
            self.parentDentryUuid = dict["ParentDentryUuid"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetFileUploadInfoResponseBody : Tea.TeaModel {
    public class HeaderSignatureInfo : Tea.TeaModel {
        public var expirationSeconds: Int32?

        public var headers: [String: String]?

        public var internalResourceUrls: [String]?

        public var region: String?

        public var resourceUrls: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationSeconds != nil {
                map["ExpirationSeconds"] = self.expirationSeconds!
            }
            if self.headers != nil {
                map["Headers"] = self.headers!
            }
            if self.internalResourceUrls != nil {
                map["InternalResourceUrls"] = self.internalResourceUrls!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceUrls != nil {
                map["ResourceUrls"] = self.resourceUrls!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpirationSeconds") {
                self.expirationSeconds = dict["ExpirationSeconds"] as! Int32
            }
            if dict.keys.contains("Headers") {
                self.headers = dict["Headers"] as! [String: String]
            }
            if dict.keys.contains("InternalResourceUrls") {
                self.internalResourceUrls = dict["InternalResourceUrls"] as! [String]
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ResourceUrls") {
                self.resourceUrls = dict["ResourceUrls"] as! [String]
            }
        }
    }
    public var headerSignatureInfo: GetFileUploadInfoResponseBody.HeaderSignatureInfo?

    public var protocol_: String?

    public var requestId: String?

    public var storageDriver: String?

    public var uploadKey: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headerSignatureInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headerSignatureInfo != nil {
            map["headerSignatureInfo"] = self.headerSignatureInfo?.toMap()
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.storageDriver != nil {
            map["storageDriver"] = self.storageDriver!
        }
        if self.uploadKey != nil {
            map["uploadKey"] = self.uploadKey!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headerSignatureInfo") {
            var model = GetFileUploadInfoResponseBody.HeaderSignatureInfo()
            model.fromMap(dict["headerSignatureInfo"] as! [String: Any])
            self.headerSignatureInfo = model
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("storageDriver") {
            self.storageDriver = dict["storageDriver"] as! String
        }
        if dict.keys.contains("uploadKey") {
            self.uploadKey = dict["uploadKey"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFileUploadInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileUploadInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileUploadInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFormComponentDefinitionListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFormComponentDefinitionListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetFormComponentDefinitionListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFormComponentDefinitionListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFormComponentDefinitionListRequest : Tea.TeaModel {
    public var appType: String?

    public var formUuid: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFormComponentDefinitionListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var componentName: String?

        public var fieldId: String?

        public var label: String?

        public var parentId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.fieldId != nil {
                map["FieldId"] = self.fieldId!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentName") {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("FieldId") {
                self.fieldId = dict["FieldId"] as! String
            }
            if dict.keys.contains("Label") {
                self.label = dict["Label"] as! String
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! String
            }
        }
    }
    public var result: [GetFormComponentDefinitionListResponseBody.Result]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") {
            var tmp : [GetFormComponentDefinitionListResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetFormComponentDefinitionListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFormComponentDefinitionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFormComponentDefinitionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFormComponentDefinitionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFormDataByIDHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFormDataByIDHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetFormDataByIDHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFormDataByIDShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFormDataByIDRequest : Tea.TeaModel {
    public var appType: String?

    public var id: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFormDataByIDResponseBody : Tea.TeaModel {
    public class Originator : Tea.TeaModel {
        public class Name : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var departmentName: String?

        public var email: String?

        public var name: GetFormDataByIDResponseBody.Originator.Name?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.name?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.departmentName != nil {
                map["DepartmentName"] = self.departmentName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.name != nil {
                map["Name"] = self.name?.toMap()
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DepartmentName") {
                self.departmentName = dict["DepartmentName"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Name") {
                var model = GetFormDataByIDResponseBody.Originator.Name()
                model.fromMap(dict["Name"] as! [String: Any])
                self.name = model
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var formData: [String: Any]?

    public var formInstId: String?

    public var modifiedTimeGMT: String?

    public var originator: GetFormDataByIDResponseBody.Originator?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.originator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.formData != nil {
            map["formData"] = self.formData!
        }
        if self.formInstId != nil {
            map["formInstId"] = self.formInstId!
        }
        if self.modifiedTimeGMT != nil {
            map["modifiedTimeGMT"] = self.modifiedTimeGMT!
        }
        if self.originator != nil {
            map["originator"] = self.originator?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("formData") {
            self.formData = dict["formData"] as! [String: Any]
        }
        if dict.keys.contains("formInstId") {
            self.formInstId = dict["formInstId"] as! String
        }
        if dict.keys.contains("modifiedTimeGMT") {
            self.modifiedTimeGMT = dict["modifiedTimeGMT"] as! String
        }
        if dict.keys.contains("originator") {
            var model = GetFormDataByIDResponseBody.Originator()
            model.fromMap(dict["originator"] as! [String: Any])
            self.originator = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFormDataByIDResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFormDataByIDResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFormDataByIDResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFormListInAppHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFormListInAppHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetFormListInAppHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFormListInAppShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFormListInAppRequest : Tea.TeaModel {
    public var appType: String?

    public var formTypes: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formTypes != nil {
            map["FormTypes"] = self.formTypes!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormTypes") {
            self.formTypes = dict["FormTypes"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFormListInAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Title : Tea.TeaModel {
            public var enUS: String?

            public var zhCN: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enUS != nil {
                    map["EnUS"] = self.enUS!
                }
                if self.zhCN != nil {
                    map["ZhCN"] = self.zhCN!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnUS") {
                    self.enUS = dict["EnUS"] as! String
                }
                if dict.keys.contains("ZhCN") {
                    self.zhCN = dict["ZhCN"] as! String
                }
            }
        }
        public var creator: String?

        public var formType: String?

        public var formUuid: String?

        public var gmtCreate: String?

        public var title: GetFormListInAppResponseBody.Data.Title?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.title?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.formType != nil {
                map["FormType"] = self.formType!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.title != nil {
                map["Title"] = self.title?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("FormType") {
                self.formType = dict["FormType"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("Title") {
                var model = GetFormListInAppResponseBody.Data.Title()
                model.fromMap(dict["Title"] as! [String: Any])
                self.title = model
            }
        }
    }
    public var currentPage: Int32?

    public var data: [GetFormListInAppResponseBody.Data]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("data") {
            var tmp : [GetFormListInAppResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetFormListInAppResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFormListInAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFormListInAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFormListInAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGroupLiveListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetGroupLiveListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetGroupLiveListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetGroupLiveListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetGroupLiveListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var openConversationId: String?

    public var startTime: Int64?

    public var tenantContext: GetGroupLiveListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = GetGroupLiveListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetGroupLiveListShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var openConversationId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetGroupLiveListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class GroupLiveList : Tea.TeaModel {
            public var anchorNickname: String?

            public var anchorUnionId: String?

            public var liveEndTime: Int64?

            public var liveStartTime: Int64?

            public var liveUuid: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.anchorNickname != nil {
                    map["AnchorNickname"] = self.anchorNickname!
                }
                if self.anchorUnionId != nil {
                    map["AnchorUnionId"] = self.anchorUnionId!
                }
                if self.liveEndTime != nil {
                    map["LiveEndTime"] = self.liveEndTime!
                }
                if self.liveStartTime != nil {
                    map["LiveStartTime"] = self.liveStartTime!
                }
                if self.liveUuid != nil {
                    map["LiveUuid"] = self.liveUuid!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnchorNickname") {
                    self.anchorNickname = dict["AnchorNickname"] as! String
                }
                if dict.keys.contains("AnchorUnionId") {
                    self.anchorUnionId = dict["AnchorUnionId"] as! String
                }
                if dict.keys.contains("LiveEndTime") {
                    self.liveEndTime = dict["LiveEndTime"] as! Int64
                }
                if dict.keys.contains("LiveStartTime") {
                    self.liveStartTime = dict["LiveStartTime"] as! Int64
                }
                if dict.keys.contains("LiveUuid") {
                    self.liveUuid = dict["LiveUuid"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var groupLiveList: [GetGroupLiveListResponseBody.Result.GroupLiveList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupLiveList != nil {
                var tmp : [Any] = []
                for k in self.groupLiveList! {
                    tmp.append(k.toMap())
                }
                map["GroupLiveList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupLiveList") {
                var tmp : [GetGroupLiveListResponseBody.Result.GroupLiveList] = []
                for v in dict["GroupLiveList"] as! [Any] {
                    var model = GetGroupLiveListResponseBody.Result.GroupLiveList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupLiveList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: GetGroupLiveListResponseBody.Result?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetGroupLiveListResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetGroupLiveListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGroupLiveListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGroupLiveListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInnerGroupMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInnerGroupMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetInnerGroupMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInnerGroupMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInnerGroupMembersRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var openConversationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OpenConversationId") {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
    }
}

public class GetInnerGroupMembersResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextToken: String?

    public var requestId: String?

    public var userIds: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.userIds != nil {
            map["userIds"] = self.userIds!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("userIds") {
            self.userIds = dict["userIds"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInnerGroupMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInnerGroupMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInnerGroupMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceByIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstanceByIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetInstanceByIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstanceByIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstanceByIdRequest : Tea.TeaModel {
    public var appType: String?

    public var id: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetInstanceByIdResponseBody : Tea.TeaModel {
    public class ActionExecutor : Tea.TeaModel {
        public class Name : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var deptName: String?

        public var email: String?

        public var name: GetInstanceByIdResponseBody.ActionExecutor.Name?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.name?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.name != nil {
                map["Name"] = self.name?.toMap()
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Name") {
                var model = GetInstanceByIdResponseBody.ActionExecutor.Name()
                model.fromMap(dict["Name"] as! [String: Any])
                self.name = model
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class Originator : Tea.TeaModel {
        public class Name : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var deptName: String?

        public var email: String?

        public var name: GetInstanceByIdResponseBody.Originator.Name?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.name?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.name != nil {
                map["Name"] = self.name?.toMap()
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Name") {
                var model = GetInstanceByIdResponseBody.Originator.Name()
                model.fromMap(dict["Name"] as! [String: Any])
                self.name = model
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var actionExecutor: [GetInstanceByIdResponseBody.ActionExecutor]?

    public var approvedResult: String?

    public var createTimeGMT: String?

    public var data: [String: Any]?

    public var formUuid: String?

    public var instanceStatus: String?

    public var modifiedTimeGMT: String?

    public var originator: GetInstanceByIdResponseBody.Originator?

    public var processCode: String?

    public var processInstanceId: String?

    public var requestId: String?

    public var title: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public var version: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.originator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionExecutor != nil {
            var tmp : [Any] = []
            for k in self.actionExecutor! {
                tmp.append(k.toMap())
            }
            map["actionExecutor"] = tmp
        }
        if self.approvedResult != nil {
            map["approvedResult"] = self.approvedResult!
        }
        if self.createTimeGMT != nil {
            map["createTimeGMT"] = self.createTimeGMT!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.formUuid != nil {
            map["formUuid"] = self.formUuid!
        }
        if self.instanceStatus != nil {
            map["instanceStatus"] = self.instanceStatus!
        }
        if self.modifiedTimeGMT != nil {
            map["modifiedTimeGMT"] = self.modifiedTimeGMT!
        }
        if self.originator != nil {
            map["originator"] = self.originator?.toMap()
        }
        if self.processCode != nil {
            map["processCode"] = self.processCode!
        }
        if self.processInstanceId != nil {
            map["processInstanceId"] = self.processInstanceId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("actionExecutor") {
            var tmp : [GetInstanceByIdResponseBody.ActionExecutor] = []
            for v in dict["actionExecutor"] as! [Any] {
                var model = GetInstanceByIdResponseBody.ActionExecutor()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.actionExecutor = tmp
        }
        if dict.keys.contains("approvedResult") {
            self.approvedResult = dict["approvedResult"] as! String
        }
        if dict.keys.contains("createTimeGMT") {
            self.createTimeGMT = dict["createTimeGMT"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! [String: Any]
        }
        if dict.keys.contains("formUuid") {
            self.formUuid = dict["formUuid"] as! String
        }
        if dict.keys.contains("instanceStatus") {
            self.instanceStatus = dict["instanceStatus"] as! String
        }
        if dict.keys.contains("modifiedTimeGMT") {
            self.modifiedTimeGMT = dict["modifiedTimeGMT"] as! String
        }
        if dict.keys.contains("originator") {
            var model = GetInstanceByIdResponseBody.Originator()
            model.fromMap(dict["originator"] as! [String: Any])
            self.originator = model
        }
        if dict.keys.contains("processCode") {
            self.processCode = dict["processCode"] as! String
        }
        if dict.keys.contains("processInstanceId") {
            self.processInstanceId = dict["processInstanceId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! Int64
        }
    }
}

public class GetInstanceByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstanceIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetInstanceIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstanceIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstanceIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var approvedResult: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var instanceStatus: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.approvedResult != nil {
            map["ApprovedResult"] = self.approvedResult!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.instanceStatus != nil {
            map["InstanceStatus"] = self.instanceStatus!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ApprovedResult") {
            self.approvedResult = dict["ApprovedResult"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("InstanceStatus") {
            self.instanceStatus = dict["InstanceStatus"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetInstanceIdListResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            self.data = dict["data"] as! [String]
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInstanceIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstancesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstancesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetInstancesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstancesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstancesRequest : Tea.TeaModel {
    public var appType: String?

    public var approvedResult: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var instanceStatus: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var orderConfigJson: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.approvedResult != nil {
            map["ApprovedResult"] = self.approvedResult!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.instanceStatus != nil {
            map["InstanceStatus"] = self.instanceStatus!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.orderConfigJson != nil {
            map["OrderConfigJson"] = self.orderConfigJson!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ApprovedResult") {
            self.approvedResult = dict["ApprovedResult"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("InstanceStatus") {
            self.instanceStatus = dict["InstanceStatus"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OrderConfigJson") {
            self.orderConfigJson = dict["OrderConfigJson"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ActionExecutor : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var deptName: String?

            public var email: String?

            public var name: GetInstancesResponseBody.Data.ActionExecutor.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") {
                    var model = GetInstancesResponseBody.Data.ActionExecutor.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var deptName: String?

            public var email: String?

            public var name: GetInstancesResponseBody.Data.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") {
                    var model = GetInstancesResponseBody.Data.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var actionExecutor: [GetInstancesResponseBody.Data.ActionExecutor]?

        public var approvedResult: String?

        public var createTimeGMT: String?

        public var data: [String: Any]?

        public var formUuid: String?

        public var instanceStatus: String?

        public var modifiedTimeGMT: String?

        public var originator: GetInstancesResponseBody.Data.Originator?

        public var processCode: String?

        public var processInstanceId: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionExecutor != nil {
                var tmp : [Any] = []
                for k in self.actionExecutor! {
                    tmp.append(k.toMap())
                }
                map["ActionExecutor"] = tmp
            }
            if self.approvedResult != nil {
                map["ApprovedResult"] = self.approvedResult!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionExecutor") {
                var tmp : [GetInstancesResponseBody.Data.ActionExecutor] = []
                for v in dict["ActionExecutor"] as! [Any] {
                    var model = GetInstancesResponseBody.Data.ActionExecutor()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actionExecutor = tmp
            }
            if dict.keys.contains("ApprovedResult") {
                self.approvedResult = dict["ApprovedResult"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! [String: Any]
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceStatus") {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Originator") {
                var model = GetInstancesResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("ProcessCode") {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [GetInstancesResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [GetInstancesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstancesByIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstancesByIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetInstancesByIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstancesByIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstancesByIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceIds: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceIds != nil {
            map["ProcessInstanceIds"] = self.processInstanceIds!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceIds") {
            self.processInstanceIds = dict["ProcessInstanceIds"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetInstancesByIdListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ActionExecutor : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var departmentName: String?

            public var email: String?

            public var name: GetInstancesByIdListResponseBody.Result.ActionExecutor.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.departmentName != nil {
                    map["DepartmentName"] = self.departmentName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DepartmentName") {
                    self.departmentName = dict["DepartmentName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") {
                    var model = GetInstancesByIdListResponseBody.Result.ActionExecutor.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var departmentName: String?

            public var email: String?

            public var name: GetInstancesByIdListResponseBody.Result.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.departmentName != nil {
                    map["DepartmentName"] = self.departmentName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DepartmentName") {
                    self.departmentName = dict["DepartmentName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") {
                    var model = GetInstancesByIdListResponseBody.Result.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var actionExecutor: [GetInstancesByIdListResponseBody.Result.ActionExecutor]?

        public var approvedResult: String?

        public var data: [String: Any]?

        public var formUuid: String?

        public var instanceStatus: String?

        public var originator: GetInstancesByIdListResponseBody.Result.Originator?

        public var processCode: String?

        public var processInstanceId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionExecutor != nil {
                var tmp : [Any] = []
                for k in self.actionExecutor! {
                    tmp.append(k.toMap())
                }
                map["ActionExecutor"] = tmp
            }
            if self.approvedResult != nil {
                map["ApprovedResult"] = self.approvedResult!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionExecutor") {
                var tmp : [GetInstancesByIdListResponseBody.Result.ActionExecutor] = []
                for v in dict["ActionExecutor"] as! [Any] {
                    var model = GetInstancesByIdListResponseBody.Result.ActionExecutor()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actionExecutor = tmp
            }
            if dict.keys.contains("ApprovedResult") {
                self.approvedResult = dict["ApprovedResult"] as! String
            }
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! [String: Any]
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceStatus") {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("Originator") {
                var model = GetInstancesByIdListResponseBody.Result.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("ProcessCode") {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetInstancesByIdListResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [GetInstancesByIdListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetInstancesByIdListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInstancesByIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstancesByIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstancesByIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLiveReplayUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetLiveReplayUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetLiveReplayUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetLiveReplayUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetLiveReplayUrlRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: GetLiveReplayUrlRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetLiveReplayUrlRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetLiveReplayUrlShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetLiveReplayUrlResponseBody : Tea.TeaModel {
    public var replayUrl: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.replayUrl != nil {
            map["replayUrl"] = self.replayUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("replayUrl") {
            self.replayUrl = dict["replayUrl"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetLiveReplayUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLiveReplayUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLiveReplayUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMeCorpSubmissionHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMeCorpSubmissionHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMeCorpSubmissionHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMeCorpSubmissionShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMeCorpSubmissionRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetMeCorpSubmissionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Actioner : Tea.TeaModel {
            public var buName: String?

            public var email: String?

            public var employeeType: String?

            public var employeeTypeInformation: String?

            public var humanResourceGroupWorkNumber: String?

            public var isSystemAdmin: Bool?

            public var level: String?

            public var name: String?

            public var nickName: String?

            public var orderNumber: String?

            public var personalPhoto: String?

            public var personalPhotoUrl: String?

            public var pinyinNameAll: String?

            public var pinyinNickName: String?

            public var state: String?

            public var superUserId: String?

            public var tbWang: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.buName != nil {
                    map["BuName"] = self.buName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.employeeType != nil {
                    map["EmployeeType"] = self.employeeType!
                }
                if self.employeeTypeInformation != nil {
                    map["EmployeeTypeInformation"] = self.employeeTypeInformation!
                }
                if self.humanResourceGroupWorkNumber != nil {
                    map["HumanResourceGroupWorkNumber"] = self.humanResourceGroupWorkNumber!
                }
                if self.isSystemAdmin != nil {
                    map["IsSystemAdmin"] = self.isSystemAdmin!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.orderNumber != nil {
                    map["OrderNumber"] = self.orderNumber!
                }
                if self.personalPhoto != nil {
                    map["PersonalPhoto"] = self.personalPhoto!
                }
                if self.personalPhotoUrl != nil {
                    map["PersonalPhotoUrl"] = self.personalPhotoUrl!
                }
                if self.pinyinNameAll != nil {
                    map["PinyinNameAll"] = self.pinyinNameAll!
                }
                if self.pinyinNickName != nil {
                    map["PinyinNickName"] = self.pinyinNickName!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.superUserId != nil {
                    map["SuperUserId"] = self.superUserId!
                }
                if self.tbWang != nil {
                    map["TbWang"] = self.tbWang!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BuName") {
                    self.buName = dict["BuName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("EmployeeType") {
                    self.employeeType = dict["EmployeeType"] as! String
                }
                if dict.keys.contains("EmployeeTypeInformation") {
                    self.employeeTypeInformation = dict["EmployeeTypeInformation"] as! String
                }
                if dict.keys.contains("HumanResourceGroupWorkNumber") {
                    self.humanResourceGroupWorkNumber = dict["HumanResourceGroupWorkNumber"] as! String
                }
                if dict.keys.contains("IsSystemAdmin") {
                    self.isSystemAdmin = dict["IsSystemAdmin"] as! Bool
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NickName") {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("OrderNumber") {
                    self.orderNumber = dict["OrderNumber"] as! String
                }
                if dict.keys.contains("PersonalPhoto") {
                    self.personalPhoto = dict["PersonalPhoto"] as! String
                }
                if dict.keys.contains("PersonalPhotoUrl") {
                    self.personalPhotoUrl = dict["PersonalPhotoUrl"] as! String
                }
                if dict.keys.contains("PinyinNameAll") {
                    self.pinyinNameAll = dict["PinyinNameAll"] as! String
                }
                if dict.keys.contains("PinyinNickName") {
                    self.pinyinNickName = dict["PinyinNickName"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("SuperUserId") {
                    self.superUserId = dict["SuperUserId"] as! String
                }
                if dict.keys.contains("TbWang") {
                    self.tbWang = dict["TbWang"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class CurrentActivityInstances : Tea.TeaModel {
            public var activityId: String?

            public var activityInstanceStatus: String?

            public var activityName: String?

            public var activityNameEn: String?

            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityId != nil {
                    map["ActivityId"] = self.activityId!
                }
                if self.activityInstanceStatus != nil {
                    map["ActivityInstanceStatus"] = self.activityInstanceStatus!
                }
                if self.activityName != nil {
                    map["ActivityName"] = self.activityName!
                }
                if self.activityNameEn != nil {
                    map["ActivityNameEn"] = self.activityNameEn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityId") {
                    self.activityId = dict["ActivityId"] as! String
                }
                if dict.keys.contains("ActivityInstanceStatus") {
                    self.activityInstanceStatus = dict["ActivityInstanceStatus"] as! String
                }
                if dict.keys.contains("ActivityName") {
                    self.activityName = dict["ActivityName"] as! String
                }
                if dict.keys.contains("ActivityNameEn") {
                    self.activityNameEn = dict["ActivityNameEn"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
            }
        }
        public var actioner: [GetMeCorpSubmissionResponseBody.Data.Actioner]?

        public var actionerId: [String]?

        public var actionerName: [String]?

        public var appType: String?

        public var createTimeGMT: String?

        public var currentActivityInstances: [GetMeCorpSubmissionResponseBody.Data.CurrentActivityInstances]?

        public var dataMap: [String: Any]?

        public var dataType: String?

        public var finishTimeGMT: String?

        public var formInstanceId: String?

        public var formUuid: String?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var originatorAvatar: String?

        public var originatorDisplayName: String?

        public var originatorId: String?

        public var processApprovedResult: String?

        public var processApprovedResultText: String?

        public var processCode: String?

        public var processId: Int64?

        public var processInstanceId: String?

        public var processInstanceStatus: String?

        public var processInstanceStatusText: String?

        public var processName: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actioner != nil {
                var tmp : [Any] = []
                for k in self.actioner! {
                    tmp.append(k.toMap())
                }
                map["Actioner"] = tmp
            }
            if self.actionerId != nil {
                map["ActionerId"] = self.actionerId!
            }
            if self.actionerName != nil {
                map["ActionerName"] = self.actionerName!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.currentActivityInstances != nil {
                var tmp : [Any] = []
                for k in self.currentActivityInstances! {
                    tmp.append(k.toMap())
                }
                map["CurrentActivityInstances"] = tmp
            }
            if self.dataMap != nil {
                map["DataMap"] = self.dataMap!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.originatorAvatar != nil {
                map["OriginatorAvatar"] = self.originatorAvatar!
            }
            if self.originatorDisplayName != nil {
                map["OriginatorDisplayName"] = self.originatorDisplayName!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.processApprovedResult != nil {
                map["ProcessApprovedResult"] = self.processApprovedResult!
            }
            if self.processApprovedResultText != nil {
                map["ProcessApprovedResultText"] = self.processApprovedResultText!
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.processInstanceStatus != nil {
                map["ProcessInstanceStatus"] = self.processInstanceStatus!
            }
            if self.processInstanceStatusText != nil {
                map["ProcessInstanceStatusText"] = self.processInstanceStatusText!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Actioner") {
                var tmp : [GetMeCorpSubmissionResponseBody.Data.Actioner] = []
                for v in dict["Actioner"] as! [Any] {
                    var model = GetMeCorpSubmissionResponseBody.Data.Actioner()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actioner = tmp
            }
            if dict.keys.contains("ActionerId") {
                self.actionerId = dict["ActionerId"] as! [String]
            }
            if dict.keys.contains("ActionerName") {
                self.actionerName = dict["ActionerName"] as! [String]
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CurrentActivityInstances") {
                var tmp : [GetMeCorpSubmissionResponseBody.Data.CurrentActivityInstances] = []
                for v in dict["CurrentActivityInstances"] as! [Any] {
                    var model = GetMeCorpSubmissionResponseBody.Data.CurrentActivityInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentActivityInstances = tmp
            }
            if dict.keys.contains("DataMap") {
                self.dataMap = dict["DataMap"] as! [String: Any]
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceValue") {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorAvatar") {
                self.originatorAvatar = dict["OriginatorAvatar"] as! String
            }
            if dict.keys.contains("OriginatorDisplayName") {
                self.originatorDisplayName = dict["OriginatorDisplayName"] as! String
            }
            if dict.keys.contains("OriginatorId") {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("ProcessApprovedResult") {
                self.processApprovedResult = dict["ProcessApprovedResult"] as! String
            }
            if dict.keys.contains("ProcessApprovedResultText") {
                self.processApprovedResultText = dict["ProcessApprovedResultText"] as! String
            }
            if dict.keys.contains("ProcessCode") {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessId") {
                self.processId = dict["ProcessId"] as! Int64
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatus") {
                self.processInstanceStatus = dict["ProcessInstanceStatus"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatusText") {
                self.processInstanceStatusText = dict["ProcessInstanceStatusText"] as! String
            }
            if dict.keys.contains("ProcessName") {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [GetMeCorpSubmissionResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [GetMeCorpSubmissionResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetMeCorpSubmissionResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMeCorpSubmissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMeCorpSubmissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMeCorpSubmissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMeetingRoomsScheduleHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMeetingRoomsScheduleHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMeetingRoomsScheduleHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMeetingRoomsScheduleShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleRequest : Tea.TeaModel {
    public var endTime: String?

    public var roomIds: [String]?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.roomIds != nil {
            map["RoomIds"] = self.roomIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RoomIds") {
            self.roomIds = dict["RoomIds"] as! [String]
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleShrinkRequest : Tea.TeaModel {
    public var endTime: String?

    public var roomIdsShrink: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.roomIdsShrink != nil {
            map["RoomIds"] = self.roomIdsShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RoomIds") {
            self.roomIdsShrink = dict["RoomIds"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleResponseBody : Tea.TeaModel {
    public class ScheduleInformation : Tea.TeaModel {
        public class ScheduleItems : Tea.TeaModel {
            public class End : Tea.TeaModel {
                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DateTime") {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public class Organizer : Tea.TeaModel {
                public var id: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                }
            }
            public class Start : Tea.TeaModel {
                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DateTime") {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public var end: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.End?

            public var eventId: String?

            public var organizer: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Organizer?

            public var start: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Start?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.end?.validate()
                try self.organizer?.validate()
                try self.start?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end?.toMap()
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.organizer != nil {
                    map["Organizer"] = self.organizer?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.End()
                    model.fromMap(dict["End"] as! [String: Any])
                    self.end = model
                }
                if dict.keys.contains("EventId") {
                    self.eventId = dict["EventId"] as! String
                }
                if dict.keys.contains("Organizer") {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Organizer()
                    model.fromMap(dict["Organizer"] as! [String: Any])
                    self.organizer = model
                }
                if dict.keys.contains("Start") {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Start()
                    model.fromMap(dict["Start"] as! [String: Any])
                    self.start = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var error: String?

        public var roomId: String?

        public var scheduleItems: [GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.scheduleItems != nil {
                var tmp : [Any] = []
                for k in self.scheduleItems! {
                    tmp.append(k.toMap())
                }
                map["ScheduleItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("ScheduleItems") {
                var tmp : [GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems] = []
                for v in dict["ScheduleItems"] as! [Any] {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scheduleItems = tmp
            }
        }
    }
    public var requestId: String?

    public var scheduleInformation: [GetMeetingRoomsScheduleResponseBody.ScheduleInformation]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.scheduleInformation != nil {
            var tmp : [Any] = []
            for k in self.scheduleInformation! {
                tmp.append(k.toMap())
            }
            map["scheduleInformation"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("scheduleInformation") {
            var tmp : [GetMeetingRoomsScheduleResponseBody.ScheduleInformation] = []
            for v in dict["scheduleInformation"] as! [Any] {
                var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scheduleInformation = tmp
        }
    }
}

public class GetMeetingRoomsScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMeetingRoomsScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMeetingRoomsScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMineWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMineWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMineWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMineWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMineWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: GetMineWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") {
            var model = GetMineWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMineWorkspaceShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMineWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetMineWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                var model = GetMineWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: GetMineWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") {
            var model = GetMineWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetMineWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMineWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMineWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiDimTableAllFieldsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMultiDimTableAllFieldsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMultiDimTableAllFieldsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMultiDimTableAllFieldsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMultiDimTableAllFieldsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var baseId: String?

    public var sheetIdOrName: String?

    public var tenantContext: GetMultiDimTableAllFieldsRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetMultiDimTableAllFieldsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMultiDimTableAllFieldsShrinkRequest : Tea.TeaModel {
    public var baseId: String?

    public var sheetIdOrName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMultiDimTableAllFieldsResponseBody : Tea.TeaModel {
    public class Value : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public var property: [String: Any]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.property != nil {
                map["Property"] = self.property!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Property") {
                self.property = dict["Property"] as! [String: Any]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var value: [GetMultiDimTableAllFieldsResponseBody.Value]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.value != nil {
            var tmp : [Any] = []
            for k in self.value! {
                tmp.append(k.toMap())
            }
            map["value"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("value") {
            var tmp : [GetMultiDimTableAllFieldsResponseBody.Value] = []
            for v in dict["value"] as! [Any] {
                var model = GetMultiDimTableAllFieldsResponseBody.Value()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.value = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMultiDimTableAllFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiDimTableAllFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiDimTableAllFieldsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiDimTableAllSheetsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMultiDimTableAllSheetsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMultiDimTableAllSheetsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMultiDimTableAllSheetsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMultiDimTableAllSheetsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var baseId: String?

    public var tenantContext: GetMultiDimTableAllSheetsRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetMultiDimTableAllSheetsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMultiDimTableAllSheetsShrinkRequest : Tea.TeaModel {
    public var baseId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMultiDimTableAllSheetsResponseBody : Tea.TeaModel {
    public class Value : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var requestId: String?

    public var value: [GetMultiDimTableAllSheetsResponseBody.Value]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.value != nil {
            var tmp : [Any] = []
            for k in self.value! {
                tmp.append(k.toMap())
            }
            map["value"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("value") {
            var tmp : [GetMultiDimTableAllSheetsResponseBody.Value] = []
            for v in dict["value"] as! [Any] {
                var model = GetMultiDimTableAllSheetsResponseBody.Value()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.value = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMultiDimTableAllSheetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiDimTableAllSheetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiDimTableAllSheetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiDimTableRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMultiDimTableRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMultiDimTableRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMultiDimTableRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMultiDimTableRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var baseId: String?

    public var recordId: String?

    public var sheetIdOrName: String?

    public var tenantContext: GetMultiDimTableRecordRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetMultiDimTableRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMultiDimTableRecordShrinkRequest : Tea.TeaModel {
    public var baseId: String?

    public var recordId: String?

    public var sheetIdOrName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMultiDimTableRecordResponseBody : Tea.TeaModel {
    public class CreatedBy : Tea.TeaModel {
        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class LastModifiedBy : Tea.TeaModel {
        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var createdBy: GetMultiDimTableRecordResponseBody.CreatedBy?

    public var createdTime: Int64?

    public var fields: [String: Any]?

    public var id: String?

    public var lastModifiedBy: GetMultiDimTableRecordResponseBody.LastModifiedBy?

    public var lastModifiedTime: Int64?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createdBy?.validate()
        try self.lastModifiedBy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdBy != nil {
            map["CreatedBy"] = self.createdBy?.toMap()
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.fields != nil {
            map["Fields"] = self.fields!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lastModifiedBy != nil {
            map["LastModifiedBy"] = self.lastModifiedBy?.toMap()
        }
        if self.lastModifiedTime != nil {
            map["LastModifiedTime"] = self.lastModifiedTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreatedBy") {
            var model = GetMultiDimTableRecordResponseBody.CreatedBy()
            model.fromMap(dict["CreatedBy"] as! [String: Any])
            self.createdBy = model
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! Int64
        }
        if dict.keys.contains("Fields") {
            self.fields = dict["Fields"] as! [String: Any]
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("LastModifiedBy") {
            var model = GetMultiDimTableRecordResponseBody.LastModifiedBy()
            model.fromMap(dict["LastModifiedBy"] as! [String: Any])
            self.lastModifiedBy = model
        }
        if dict.keys.contains("LastModifiedTime") {
            self.lastModifiedTime = dict["LastModifiedTime"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMultiDimTableRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiDimTableRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiDimTableRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiDimTableSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMultiDimTableSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMultiDimTableSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMultiDimTableSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMultiDimTableSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var baseId: String?

    public var sheetIdOrName: String?

    public var tenantContext: GetMultiDimTableSheetRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetMultiDimTableSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMultiDimTableSheetShrinkRequest : Tea.TeaModel {
    public var baseId: String?

    public var sheetIdOrName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMultiDimTableSheetResponseBody : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMultiDimTableSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiDimTableSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiDimTableSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultipartFileUploadInfosHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMultipartFileUploadInfosHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetMultipartFileUploadInfosHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMultipartFileUploadInfosShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMultipartFileUploadInfosRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var preferIntranet: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preferIntranet != nil {
                map["PreferIntranet"] = self.preferIntranet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreferIntranet") {
                self.preferIntranet = dict["PreferIntranet"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetMultipartFileUploadInfosRequest.Option?

    public var partNumbers: [Int32]?

    public var tenantContext: GetMultipartFileUploadInfosRequest.TenantContext?

    public var uploadKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.partNumbers != nil {
            map["PartNumbers"] = self.partNumbers!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.uploadKey != nil {
            map["UploadKey"] = self.uploadKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            var model = GetMultipartFileUploadInfosRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("PartNumbers") {
            self.partNumbers = dict["PartNumbers"] as! [Int32]
        }
        if dict.keys.contains("TenantContext") {
            var model = GetMultipartFileUploadInfosRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UploadKey") {
            self.uploadKey = dict["UploadKey"] as! String
        }
    }
}

public class GetMultipartFileUploadInfosShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var partNumbersShrink: String?

    public var tenantContextShrink: String?

    public var uploadKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.partNumbersShrink != nil {
            map["PartNumbers"] = self.partNumbersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.uploadKey != nil {
            map["UploadKey"] = self.uploadKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("PartNumbers") {
            self.partNumbersShrink = dict["PartNumbers"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UploadKey") {
            self.uploadKey = dict["UploadKey"] as! String
        }
    }
}

public class GetMultipartFileUploadInfosResponseBody : Tea.TeaModel {
    public class MultipartHeaderSignatureInfos : Tea.TeaModel {
        public class HeaderSignatureInfo : Tea.TeaModel {
            public var expirationSeconds: Int32?

            public var headers: [String: String]?

            public var internalResourceUrls: [String]?

            public var region: String?

            public var resourceUrls: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expirationSeconds != nil {
                    map["ExpirationSeconds"] = self.expirationSeconds!
                }
                if self.headers != nil {
                    map["Headers"] = self.headers!
                }
                if self.internalResourceUrls != nil {
                    map["InternalResourceUrls"] = self.internalResourceUrls!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceUrls != nil {
                    map["ResourceUrls"] = self.resourceUrls!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExpirationSeconds") {
                    self.expirationSeconds = dict["ExpirationSeconds"] as! Int32
                }
                if dict.keys.contains("Headers") {
                    self.headers = dict["Headers"] as! [String: String]
                }
                if dict.keys.contains("InternalResourceUrls") {
                    self.internalResourceUrls = dict["InternalResourceUrls"] as! [String]
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ResourceUrls") {
                    self.resourceUrls = dict["ResourceUrls"] as! [String]
                }
            }
        }
        public var headerSignatureInfo: GetMultipartFileUploadInfosResponseBody.MultipartHeaderSignatureInfos.HeaderSignatureInfo?

        public var partNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.headerSignatureInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerSignatureInfo != nil {
                map["HeaderSignatureInfo"] = self.headerSignatureInfo?.toMap()
            }
            if self.partNumber != nil {
                map["PartNumber"] = self.partNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HeaderSignatureInfo") {
                var model = GetMultipartFileUploadInfosResponseBody.MultipartHeaderSignatureInfos.HeaderSignatureInfo()
                model.fromMap(dict["HeaderSignatureInfo"] as! [String: Any])
                self.headerSignatureInfo = model
            }
            if dict.keys.contains("PartNumber") {
                self.partNumber = dict["PartNumber"] as! Int32
            }
        }
    }
    public var multipartHeaderSignatureInfos: [GetMultipartFileUploadInfosResponseBody.MultipartHeaderSignatureInfos]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.multipartHeaderSignatureInfos != nil {
            var tmp : [Any] = []
            for k in self.multipartHeaderSignatureInfos! {
                tmp.append(k.toMap())
            }
            map["multipartHeaderSignatureInfos"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("multipartHeaderSignatureInfos") {
            var tmp : [GetMultipartFileUploadInfosResponseBody.MultipartHeaderSignatureInfos] = []
            for v in dict["multipartHeaderSignatureInfos"] as! [Any] {
                var model = GetMultipartFileUploadInfosResponseBody.MultipartHeaderSignatureInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.multipartHeaderSignatureInfos = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMultipartFileUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultipartFileUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultipartFileUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNewestInnerGroupsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNewestInnerGroupsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetNewestInnerGroupsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNewestInnerGroupsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNewestInnerGroupsRequest : Tea.TeaModel {
    public var request: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.request = dict["Request"] as! [String: Any]
        }
    }
}

public class GetNewestInnerGroupsShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.requestShrink = dict["Request"] as! String
        }
    }
}

public class GetNewestInnerGroupsResponseBody : Tea.TeaModel {
    public class GroupInfos : Tea.TeaModel {
        public var icon: String?

        public var memberAmount: String?

        public var openConversationId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.memberAmount != nil {
                map["MemberAmount"] = self.memberAmount!
            }
            if self.openConversationId != nil {
                map["OpenConversationId"] = self.openConversationId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Icon") {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("MemberAmount") {
                self.memberAmount = dict["MemberAmount"] as! String
            }
            if dict.keys.contains("OpenConversationId") {
                self.openConversationId = dict["OpenConversationId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var groupInfos: [GetNewestInnerGroupsResponseBody.GroupInfos]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupInfos != nil {
            var tmp : [Any] = []
            for k in self.groupInfos! {
                tmp.append(k.toMap())
            }
            map["groupInfos"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("groupInfos") {
            var tmp : [GetNewestInnerGroupsResponseBody.GroupInfos] = []
            for v in dict["groupInfos"] as! [Any] {
                var model = GetNewestInnerGroupsResponseBody.GroupInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupInfos = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetNewestInnerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNewestInnerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNewestInnerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetNodeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var nodeId: String?

    public var tenantContext: GetNodeRequest.TenantContext?

    public var withPermissionRole: Bool?

    public var withStatisticalInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.withStatisticalInfo != nil {
            map["WithStatisticalInfo"] = self.withStatisticalInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetNodeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WithStatisticalInfo") {
            self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
        }
    }
}

public class GetNodeShrinkRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public var withStatisticalInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.withStatisticalInfo != nil {
            map["WithStatisticalInfo"] = self.withStatisticalInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WithStatisticalInfo") {
            self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodeResponseBody.Node.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") {
                var model = GetNodeResponseBody.Node.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var node: GetNodeResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("node") {
            var model = GetNodeResponseBody.Node()
            model.fromMap(dict["node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeByUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodeByUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetNodeByUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodeByUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodeByUrlRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public var withStatisticalInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            if self.withStatisticalInfo != nil {
                map["WithStatisticalInfo"] = self.withStatisticalInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
            if dict.keys.contains("WithStatisticalInfo") {
                self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetNodeByUrlRequest.Option?

    public var tenantContext: GetNodeByUrlRequest.TenantContext?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            var model = GetNodeByUrlRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") {
            var model = GetNodeByUrlRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetNodeByUrlShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var tenantContextShrink: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetNodeByUrlResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodeByUrlResponseBody.Node.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") {
                var model = GetNodeByUrlResponseBody.Node.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var node: GetNodeByUrlResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("node") {
            var model = GetNodeByUrlResponseBody.Node()
            model.fromMap(dict["node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodeByUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeByUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeByUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetNodesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodesRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public var withStatisticalInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            if self.withStatisticalInfo != nil {
                map["WithStatisticalInfo"] = self.withStatisticalInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
            if dict.keys.contains("WithStatisticalInfo") {
                self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var nodeIds: [String]?

    public var option: GetNodesRequest.Option?

    public var tenantContext: GetNodesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeIds") {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("Option") {
            var model = GetNodesRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") {
            var model = GetNodesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetNodesShrinkRequest : Tea.TeaModel {
    public var nodeIdsShrink: String?

    public var optionShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeIdsShrink != nil {
            map["NodeIds"] = self.nodeIdsShrink!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeIds") {
            self.nodeIdsShrink = dict["NodeIds"] as! String
        }
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodesResponseBody.Nodes.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") {
                var model = GetNodesResponseBody.Nodes.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nodes: [GetNodesResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["nodes"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nodes") {
            var tmp : [GetNodesResponseBody.Nodes] = []
            for v in dict["nodes"] as! [Any] {
                var model = GetNodesResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNotifyMeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNotifyMeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetNotifyMeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNotifyMeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNotifyMeRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var instanceCreateFromTimeGMT: Int64?

    public var instanceCreateToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.instanceCreateFromTimeGMT != nil {
            map["InstanceCreateFromTimeGMT"] = self.instanceCreateFromTimeGMT!
        }
        if self.instanceCreateToTimeGMT != nil {
            map["InstanceCreateToTimeGMT"] = self.instanceCreateToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("InstanceCreateFromTimeGMT") {
            self.instanceCreateFromTimeGMT = dict["InstanceCreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("InstanceCreateToTimeGMT") {
            self.instanceCreateToTimeGMT = dict["InstanceCreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetNotifyMeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var activityId: String?

        public var appType: String?

        public var corpId: String?

        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formInstanceId: String?

        public var instStatus: String?

        public var mobileUrl: String?

        public var modifiedTimeGMT: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.instStatus != nil {
                map["InstStatus"] = self.instStatus!
            }
            if self.mobileUrl != nil {
                map["MobileUrl"] = self.mobileUrl!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("InstStatus") {
                self.instStatus = dict["InstStatus"] as! String
            }
            if dict.keys.contains("MobileUrl") {
                self.mobileUrl = dict["MobileUrl"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
        }
    }
    public var data: [GetNotifyMeResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [GetNotifyMeResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetNotifyMeResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetNotifyMeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNotifyMeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNotifyMeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpenUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOpenUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetOpenUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOpenUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOpenUrlRequest : Tea.TeaModel {
    public var appType: String?

    public var fileUrl: String?

    public var language: String?

    public var systemToken: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetOpenUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
    }
}

public class GetOpenUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpenUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOpenUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOperationRecordsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOperationRecordsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetOperationRecordsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOperationRecordsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOperationRecordsRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetOperationRecordsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var action: String?

        public var actionExit: String?

        public var activeTimeGMT: String?

        public var activityId: String?

        public var dataId: Int64?

        public var digitalSign: String?

        public var files: String?

        public var operateTimeGMT: String?

        public var operateType: String?

        public var operatorDisplayName: String?

        public var operatorName: String?

        public var operatorNickName: String?

        public var operatorPhotoUrl: String?

        public var operatorStatus: String?

        public var operatorUserId: String?

        public var processInstanceId: String?

        public var remark: String?

        public var showName: String?

        public var size: Int32?

        public var taskExecuteType: String?

        public var taskHoldTimeGMT: Int64?

        public var taskId: String?

        public var taskType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.actionExit != nil {
                map["ActionExit"] = self.actionExit!
            }
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.digitalSign != nil {
                map["DigitalSign"] = self.digitalSign!
            }
            if self.files != nil {
                map["Files"] = self.files!
            }
            if self.operateTimeGMT != nil {
                map["OperateTimeGMT"] = self.operateTimeGMT!
            }
            if self.operateType != nil {
                map["OperateType"] = self.operateType!
            }
            if self.operatorDisplayName != nil {
                map["OperatorDisplayName"] = self.operatorDisplayName!
            }
            if self.operatorName != nil {
                map["OperatorName"] = self.operatorName!
            }
            if self.operatorNickName != nil {
                map["OperatorNickName"] = self.operatorNickName!
            }
            if self.operatorPhotoUrl != nil {
                map["OperatorPhotoUrl"] = self.operatorPhotoUrl!
            }
            if self.operatorStatus != nil {
                map["OperatorStatus"] = self.operatorStatus!
            }
            if self.operatorUserId != nil {
                map["OperatorUserId"] = self.operatorUserId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.taskExecuteType != nil {
                map["TaskExecuteType"] = self.taskExecuteType!
            }
            if self.taskHoldTimeGMT != nil {
                map["TaskHoldTimeGMT"] = self.taskHoldTimeGMT!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ActionExit") {
                self.actionExit = dict["ActionExit"] as! String
            }
            if dict.keys.contains("ActiveTimeGMT") {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActivityId") {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! Int64
            }
            if dict.keys.contains("DigitalSign") {
                self.digitalSign = dict["DigitalSign"] as! String
            }
            if dict.keys.contains("Files") {
                self.files = dict["Files"] as! String
            }
            if dict.keys.contains("OperateTimeGMT") {
                self.operateTimeGMT = dict["OperateTimeGMT"] as! String
            }
            if dict.keys.contains("OperateType") {
                self.operateType = dict["OperateType"] as! String
            }
            if dict.keys.contains("OperatorDisplayName") {
                self.operatorDisplayName = dict["OperatorDisplayName"] as! String
            }
            if dict.keys.contains("OperatorName") {
                self.operatorName = dict["OperatorName"] as! String
            }
            if dict.keys.contains("OperatorNickName") {
                self.operatorNickName = dict["OperatorNickName"] as! String
            }
            if dict.keys.contains("OperatorPhotoUrl") {
                self.operatorPhotoUrl = dict["OperatorPhotoUrl"] as! String
            }
            if dict.keys.contains("OperatorStatus") {
                self.operatorStatus = dict["OperatorStatus"] as! String
            }
            if dict.keys.contains("OperatorUserId") {
                self.operatorUserId = dict["OperatorUserId"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ShowName") {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TaskExecuteType") {
                self.taskExecuteType = dict["TaskExecuteType"] as! String
            }
            if dict.keys.contains("TaskHoldTimeGMT") {
                self.taskHoldTimeGMT = dict["TaskHoldTimeGMT"] as! Int64
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetOperationRecordsResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [GetOperationRecordsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetOperationRecordsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetOperationRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOperationRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOperationRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrgLiveListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOrgLiveListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetOrgLiveListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOrgLiveListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOrgLiveListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var corpId: String?

    public var endTime: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: Int64?

    public var tenantContext: GetOrgLiveListRequest.TenantContext?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = GetOrgLiveListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetOrgLiveListShrinkRequest : Tea.TeaModel {
    public var corpId: String?

    public var endTime: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetOrgLiveListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NewLive : Tea.TeaModel {
            public class LiveList : Tea.TeaModel {
                public var anchorNickname: String?

                public var anchorUnionId: String?

                public var anchorUserId: String?

                public var liveEndTime: Int64?

                public var liveStartTime: Int64?

                public var liveUuid: String?

                public var shareOpenConversationIds: [String]?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorNickname != nil {
                        map["AnchorNickname"] = self.anchorNickname!
                    }
                    if self.anchorUnionId != nil {
                        map["AnchorUnionId"] = self.anchorUnionId!
                    }
                    if self.anchorUserId != nil {
                        map["AnchorUserId"] = self.anchorUserId!
                    }
                    if self.liveEndTime != nil {
                        map["LiveEndTime"] = self.liveEndTime!
                    }
                    if self.liveStartTime != nil {
                        map["LiveStartTime"] = self.liveStartTime!
                    }
                    if self.liveUuid != nil {
                        map["LiveUuid"] = self.liveUuid!
                    }
                    if self.shareOpenConversationIds != nil {
                        map["ShareOpenConversationIds"] = self.shareOpenConversationIds!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorNickname") {
                        self.anchorNickname = dict["AnchorNickname"] as! String
                    }
                    if dict.keys.contains("AnchorUnionId") {
                        self.anchorUnionId = dict["AnchorUnionId"] as! String
                    }
                    if dict.keys.contains("AnchorUserId") {
                        self.anchorUserId = dict["AnchorUserId"] as! String
                    }
                    if dict.keys.contains("LiveEndTime") {
                        self.liveEndTime = dict["LiveEndTime"] as! Int64
                    }
                    if dict.keys.contains("LiveStartTime") {
                        self.liveStartTime = dict["LiveStartTime"] as! Int64
                    }
                    if dict.keys.contains("LiveUuid") {
                        self.liveUuid = dict["LiveUuid"] as! String
                    }
                    if dict.keys.contains("ShareOpenConversationIds") {
                        self.shareOpenConversationIds = dict["ShareOpenConversationIds"] as! [String]
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var hasMore: Bool?

            public var liveList: [GetOrgLiveListResponseBody.Result.NewLive.LiveList]?

            public var pageNumber: Int64?

            public var pageSize: Int64?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hasMore != nil {
                    map["HasMore"] = self.hasMore!
                }
                if self.liveList != nil {
                    var tmp : [Any] = []
                    for k in self.liveList! {
                        tmp.append(k.toMap())
                    }
                    map["LiveList"] = tmp
                }
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HasMore") {
                    self.hasMore = dict["HasMore"] as! Bool
                }
                if dict.keys.contains("LiveList") {
                    var tmp : [GetOrgLiveListResponseBody.Result.NewLive.LiveList] = []
                    for v in dict["LiveList"] as! [Any] {
                        var model = GetOrgLiveListResponseBody.Result.NewLive.LiveList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.liveList = tmp
                }
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int64
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int64
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int64
                }
            }
        }
        public class UpdateLive : Tea.TeaModel {
            public class LiveList : Tea.TeaModel {
                public var anchorNickname: String?

                public var anchorUnionId: String?

                public var anchorUserId: String?

                public var liveEndTime: Int64?

                public var liveStartTime: Int64?

                public var liveUuid: String?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorNickname != nil {
                        map["AnchorNickname"] = self.anchorNickname!
                    }
                    if self.anchorUnionId != nil {
                        map["AnchorUnionId"] = self.anchorUnionId!
                    }
                    if self.anchorUserId != nil {
                        map["AnchorUserId"] = self.anchorUserId!
                    }
                    if self.liveEndTime != nil {
                        map["LiveEndTime"] = self.liveEndTime!
                    }
                    if self.liveStartTime != nil {
                        map["LiveStartTime"] = self.liveStartTime!
                    }
                    if self.liveUuid != nil {
                        map["LiveUuid"] = self.liveUuid!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorNickname") {
                        self.anchorNickname = dict["AnchorNickname"] as! String
                    }
                    if dict.keys.contains("AnchorUnionId") {
                        self.anchorUnionId = dict["AnchorUnionId"] as! String
                    }
                    if dict.keys.contains("AnchorUserId") {
                        self.anchorUserId = dict["AnchorUserId"] as! String
                    }
                    if dict.keys.contains("LiveEndTime") {
                        self.liveEndTime = dict["LiveEndTime"] as! Int64
                    }
                    if dict.keys.contains("LiveStartTime") {
                        self.liveStartTime = dict["LiveStartTime"] as! Int64
                    }
                    if dict.keys.contains("LiveUuid") {
                        self.liveUuid = dict["LiveUuid"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var hasMore: Bool?

            public var liveList: [GetOrgLiveListResponseBody.Result.UpdateLive.LiveList]?

            public var pageNumber: Int64?

            public var pageSize: Int64?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hasMore != nil {
                    map["HasMore"] = self.hasMore!
                }
                if self.liveList != nil {
                    var tmp : [Any] = []
                    for k in self.liveList! {
                        tmp.append(k.toMap())
                    }
                    map["LiveList"] = tmp
                }
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HasMore") {
                    self.hasMore = dict["HasMore"] as! Bool
                }
                if dict.keys.contains("LiveList") {
                    var tmp : [GetOrgLiveListResponseBody.Result.UpdateLive.LiveList] = []
                    for v in dict["LiveList"] as! [Any] {
                        var model = GetOrgLiveListResponseBody.Result.UpdateLive.LiveList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.liveList = tmp
                }
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int64
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int64
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int64
                }
            }
        }
        public var newLive: GetOrgLiveListResponseBody.Result.NewLive?

        public var updateLive: GetOrgLiveListResponseBody.Result.UpdateLive?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.newLive?.validate()
            try self.updateLive?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.newLive != nil {
                map["NewLive"] = self.newLive?.toMap()
            }
            if self.updateLive != nil {
                map["UpdateLive"] = self.updateLive?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NewLive") {
                var model = GetOrgLiveListResponseBody.Result.NewLive()
                model.fromMap(dict["NewLive"] as! [String: Any])
                self.newLive = model
            }
            if dict.keys.contains("UpdateLive") {
                var model = GetOrgLiveListResponseBody.Result.UpdateLive()
                model.fromMap(dict["UpdateLive"] as! [String: Any])
                self.updateLive = model
            }
        }
    }
    public var requestId: String?

    public var result: GetOrgLiveListResponseBody.Result?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetOrgLiveListResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetOrgLiveListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrgLiveListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOrgLiveListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrgOrWebOpenDocContentTaskIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOrgOrWebOpenDocContentTaskIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetOrgOrWebOpenDocContentTaskIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOrgOrWebOpenDocContentTaskIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOrgOrWebOpenDocContentTaskIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryUuid: String?

    public var generateCp: Bool?

    public var scopeType: Int32?

    public var targetFormat: String?

    public var tenantContext: GetOrgOrWebOpenDocContentTaskIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.generateCp != nil {
            map["GenerateCp"] = self.generateCp!
        }
        if self.scopeType != nil {
            map["ScopeType"] = self.scopeType!
        }
        if self.targetFormat != nil {
            map["TargetFormat"] = self.targetFormat!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("GenerateCp") {
            self.generateCp = dict["GenerateCp"] as! Bool
        }
        if dict.keys.contains("ScopeType") {
            self.scopeType = dict["ScopeType"] as! Int32
        }
        if dict.keys.contains("TargetFormat") {
            self.targetFormat = dict["TargetFormat"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetOrgOrWebOpenDocContentTaskIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetOrgOrWebOpenDocContentTaskIdShrinkRequest : Tea.TeaModel {
    public var dentryUuid: String?

    public var generateCp: Bool?

    public var scopeType: Int32?

    public var targetFormat: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.generateCp != nil {
            map["GenerateCp"] = self.generateCp!
        }
        if self.scopeType != nil {
            map["ScopeType"] = self.scopeType!
        }
        if self.targetFormat != nil {
            map["TargetFormat"] = self.targetFormat!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("GenerateCp") {
            self.generateCp = dict["GenerateCp"] as! Bool
        }
        if dict.keys.contains("ScopeType") {
            self.scopeType = dict["ScopeType"] as! Int32
        }
        if dict.keys.contains("TargetFormat") {
            self.targetFormat = dict["TargetFormat"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetOrgOrWebOpenDocContentTaskIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetOrgOrWebOpenDocContentTaskIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrgOrWebOpenDocContentTaskIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOrgOrWebOpenDocContentTaskIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProcessDefinitionHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetProcessDefinitionHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetProcessDefinitionHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetProcessDefinitionShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetProcessDefinitionRequest : Tea.TeaModel {
    public var appType: String?

    public var corpId: String?

    public var groupId: String?

    public var language: String?

    public var nameSpace: String?

    public var orderNumber: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public var systemType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.nameSpace != nil {
            map["NameSpace"] = self.nameSpace!
        }
        if self.orderNumber != nil {
            map["OrderNumber"] = self.orderNumber!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NameSpace") {
            self.nameSpace = dict["NameSpace"] as! String
        }
        if dict.keys.contains("OrderNumber") {
            self.orderNumber = dict["OrderNumber"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("SystemType") {
            self.systemType = dict["SystemType"] as! String
        }
    }
}

public class GetProcessDefinitionResponseBody : Tea.TeaModel {
    public class Originator : Tea.TeaModel {
        public class MasterDataDepartments : Tea.TeaModel {
            public var deptName: String?

            public var deptNameInEnglish: String?

            public var deptNo: String?

            public var deptPath: String?

            public var humanSourceGroupOrderNumber: String?

            public var humanSourceGroupWorkNo: String?

            public var id: Int64?

            public var masterWorkNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.deptNameInEnglish != nil {
                    map["DeptNameInEnglish"] = self.deptNameInEnglish!
                }
                if self.deptNo != nil {
                    map["DeptNo"] = self.deptNo!
                }
                if self.deptPath != nil {
                    map["DeptPath"] = self.deptPath!
                }
                if self.humanSourceGroupOrderNumber != nil {
                    map["HumanSourceGroupOrderNumber"] = self.humanSourceGroupOrderNumber!
                }
                if self.humanSourceGroupWorkNo != nil {
                    map["HumanSourceGroupWorkNo"] = self.humanSourceGroupWorkNo!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.masterWorkNo != nil {
                    map["MasterWorkNo"] = self.masterWorkNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("DeptNameInEnglish") {
                    self.deptNameInEnglish = dict["DeptNameInEnglish"] as! String
                }
                if dict.keys.contains("DeptNo") {
                    self.deptNo = dict["DeptNo"] as! String
                }
                if dict.keys.contains("DeptPath") {
                    self.deptPath = dict["DeptPath"] as! String
                }
                if dict.keys.contains("HumanSourceGroupOrderNumber") {
                    self.humanSourceGroupOrderNumber = dict["HumanSourceGroupOrderNumber"] as! String
                }
                if dict.keys.contains("HumanSourceGroupWorkNo") {
                    self.humanSourceGroupWorkNo = dict["HumanSourceGroupWorkNo"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MasterWorkNo") {
                    self.masterWorkNo = dict["MasterWorkNo"] as! String
                }
            }
        }
        public var departmentDescription: String?

        public var displayEnName: String?

        public var displayName: String?

        public var masterDataDepartments: [GetProcessDefinitionResponseBody.Originator.MasterDataDepartments]?

        public var orderNumber: String?

        public var personalPhoto: String?

        public var status: String?

        public var tbWang: String?

        public var userId: String?

        public var userInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.departmentDescription != nil {
                map["DepartmentDescription"] = self.departmentDescription!
            }
            if self.displayEnName != nil {
                map["DisplayEnName"] = self.displayEnName!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.masterDataDepartments != nil {
                var tmp : [Any] = []
                for k in self.masterDataDepartments! {
                    tmp.append(k.toMap())
                }
                map["MasterDataDepartments"] = tmp
            }
            if self.orderNumber != nil {
                map["OrderNumber"] = self.orderNumber!
            }
            if self.personalPhoto != nil {
                map["PersonalPhoto"] = self.personalPhoto!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tbWang != nil {
                map["TbWang"] = self.tbWang!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userInfo != nil {
                map["UserInfo"] = self.userInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DepartmentDescription") {
                self.departmentDescription = dict["DepartmentDescription"] as! String
            }
            if dict.keys.contains("DisplayEnName") {
                self.displayEnName = dict["DisplayEnName"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MasterDataDepartments") {
                var tmp : [GetProcessDefinitionResponseBody.Originator.MasterDataDepartments] = []
                for v in dict["MasterDataDepartments"] as! [Any] {
                    var model = GetProcessDefinitionResponseBody.Originator.MasterDataDepartments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.masterDataDepartments = tmp
            }
            if dict.keys.contains("OrderNumber") {
                self.orderNumber = dict["OrderNumber"] as! String
            }
            if dict.keys.contains("PersonalPhoto") {
                self.personalPhoto = dict["PersonalPhoto"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TbWang") {
                self.tbWang = dict["TbWang"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserInfo") {
                self.userInfo = dict["UserInfo"] as! String
            }
        }
    }
    public class Owners : Tea.TeaModel {
        public class MasterDataDepartments : Tea.TeaModel {
            public var deptName: String?

            public var deptNameInEnglish: String?

            public var deptNo: String?

            public var deptPath: String?

            public var humanSourceGroupOrderNumber: String?

            public var humanSourceGroupWorkNo: String?

            public var id: Int64?

            public var masterWorkNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.deptNameInEnglish != nil {
                    map["DeptNameInEnglish"] = self.deptNameInEnglish!
                }
                if self.deptNo != nil {
                    map["DeptNo"] = self.deptNo!
                }
                if self.deptPath != nil {
                    map["DeptPath"] = self.deptPath!
                }
                if self.humanSourceGroupOrderNumber != nil {
                    map["HumanSourceGroupOrderNumber"] = self.humanSourceGroupOrderNumber!
                }
                if self.humanSourceGroupWorkNo != nil {
                    map["HumanSourceGroupWorkNo"] = self.humanSourceGroupWorkNo!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.masterWorkNo != nil {
                    map["MasterWorkNo"] = self.masterWorkNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("DeptNameInEnglish") {
                    self.deptNameInEnglish = dict["DeptNameInEnglish"] as! String
                }
                if dict.keys.contains("DeptNo") {
                    self.deptNo = dict["DeptNo"] as! String
                }
                if dict.keys.contains("DeptPath") {
                    self.deptPath = dict["DeptPath"] as! String
                }
                if dict.keys.contains("HumanSourceGroupOrderNumber") {
                    self.humanSourceGroupOrderNumber = dict["HumanSourceGroupOrderNumber"] as! String
                }
                if dict.keys.contains("HumanSourceGroupWorkNo") {
                    self.humanSourceGroupWorkNo = dict["HumanSourceGroupWorkNo"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MasterWorkNo") {
                    self.masterWorkNo = dict["MasterWorkNo"] as! String
                }
            }
        }
        public var departmentDescription: String?

        public var displayEnName: String?

        public var displayName: String?

        public var masterDataDepartments: [GetProcessDefinitionResponseBody.Owners.MasterDataDepartments]?

        public var orderNumber: String?

        public var personalPhoto: String?

        public var status: String?

        public var tbWang: String?

        public var userId: String?

        public var userInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.departmentDescription != nil {
                map["DepartmentDescription"] = self.departmentDescription!
            }
            if self.displayEnName != nil {
                map["DisplayEnName"] = self.displayEnName!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.masterDataDepartments != nil {
                var tmp : [Any] = []
                for k in self.masterDataDepartments! {
                    tmp.append(k.toMap())
                }
                map["MasterDataDepartments"] = tmp
            }
            if self.orderNumber != nil {
                map["OrderNumber"] = self.orderNumber!
            }
            if self.personalPhoto != nil {
                map["PersonalPhoto"] = self.personalPhoto!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tbWang != nil {
                map["TbWang"] = self.tbWang!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userInfo != nil {
                map["UserInfo"] = self.userInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DepartmentDescription") {
                self.departmentDescription = dict["DepartmentDescription"] as! String
            }
            if dict.keys.contains("DisplayEnName") {
                self.displayEnName = dict["DisplayEnName"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MasterDataDepartments") {
                var tmp : [GetProcessDefinitionResponseBody.Owners.MasterDataDepartments] = []
                for v in dict["MasterDataDepartments"] as! [Any] {
                    var model = GetProcessDefinitionResponseBody.Owners.MasterDataDepartments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.masterDataDepartments = tmp
            }
            if dict.keys.contains("OrderNumber") {
                self.orderNumber = dict["OrderNumber"] as! String
            }
            if dict.keys.contains("PersonalPhoto") {
                self.personalPhoto = dict["PersonalPhoto"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TbWang") {
                self.tbWang = dict["TbWang"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserInfo") {
                self.userInfo = dict["UserInfo"] as! String
            }
        }
    }
    public class Tasks : Tea.TeaModel {
        public class Activity : Tea.TeaModel {
            public var activityId: String?

            public var activityInstanceStatus: String?

            public var activityName: String?

            public var activityNameInEnglish: String?

            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityId != nil {
                    map["ActivityId"] = self.activityId!
                }
                if self.activityInstanceStatus != nil {
                    map["ActivityInstanceStatus"] = self.activityInstanceStatus!
                }
                if self.activityName != nil {
                    map["ActivityName"] = self.activityName!
                }
                if self.activityNameInEnglish != nil {
                    map["ActivityNameInEnglish"] = self.activityNameInEnglish!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityId") {
                    self.activityId = dict["ActivityId"] as! String
                }
                if dict.keys.contains("ActivityInstanceStatus") {
                    self.activityInstanceStatus = dict["ActivityInstanceStatus"] as! String
                }
                if dict.keys.contains("ActivityName") {
                    self.activityName = dict["ActivityName"] as! String
                }
                if dict.keys.contains("ActivityNameInEnglish") {
                    self.activityNameInEnglish = dict["ActivityNameInEnglish"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
            }
        }
        public var actionerId: String?

        public var activity: GetProcessDefinitionResponseBody.Tasks.Activity?

        public var status: String?

        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.activity?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionerId != nil {
                map["ActionerId"] = self.actionerId!
            }
            if self.activity != nil {
                map["Activity"] = self.activity?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionerId") {
                self.actionerId = dict["ActionerId"] as! String
            }
            if dict.keys.contains("Activity") {
                var model = GetProcessDefinitionResponseBody.Tasks.Activity()
                model.fromMap(dict["Activity"] as! [String: Any])
                self.activity = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! Int64
            }
        }
    }
    public var formUuid: String?

    public var originator: GetProcessDefinitionResponseBody.Originator?

    public var outResult: String?

    public var owners: [GetProcessDefinitionResponseBody.Owners]?

    public var processId: String?

    public var processInstanceId: String?

    public var requestId: String?

    public var status: String?

    public var tasks: [GetProcessDefinitionResponseBody.Tasks]?

    public var title: String?

    public var variables: [String: Any]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.originator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.formUuid != nil {
            map["formUuid"] = self.formUuid!
        }
        if self.originator != nil {
            map["originator"] = self.originator?.toMap()
        }
        if self.outResult != nil {
            map["outResult"] = self.outResult!
        }
        if self.owners != nil {
            var tmp : [Any] = []
            for k in self.owners! {
                tmp.append(k.toMap())
            }
            map["owners"] = tmp
        }
        if self.processId != nil {
            map["processId"] = self.processId!
        }
        if self.processInstanceId != nil {
            map["processInstanceId"] = self.processInstanceId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tasks != nil {
            var tmp : [Any] = []
            for k in self.tasks! {
                tmp.append(k.toMap())
            }
            map["tasks"] = tmp
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.variables != nil {
            map["variables"] = self.variables!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("formUuid") {
            self.formUuid = dict["formUuid"] as! String
        }
        if dict.keys.contains("originator") {
            var model = GetProcessDefinitionResponseBody.Originator()
            model.fromMap(dict["originator"] as! [String: Any])
            self.originator = model
        }
        if dict.keys.contains("outResult") {
            self.outResult = dict["outResult"] as! String
        }
        if dict.keys.contains("owners") {
            var tmp : [GetProcessDefinitionResponseBody.Owners] = []
            for v in dict["owners"] as! [Any] {
                var model = GetProcessDefinitionResponseBody.Owners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.owners = tmp
        }
        if dict.keys.contains("processId") {
            self.processId = dict["processId"] as! String
        }
        if dict.keys.contains("processInstanceId") {
            self.processInstanceId = dict["processInstanceId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("tasks") {
            var tmp : [GetProcessDefinitionResponseBody.Tasks] = []
            for v in dict["tasks"] as! [Any] {
                var model = GetProcessDefinitionResponseBody.Tasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tasks = tmp
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("variables") {
            self.variables = dict["variables"] as! [String: Any]
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetProcessDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProcessDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProcessDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRangeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetRangeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetRangeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetRangeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetRangeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var select: String?

    public var sheetId: String?

    public var tenantContext: GetRangeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.select != nil {
            map["Select"] = self.select!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("Select") {
            self.select = dict["Select"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetRangeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetRangeShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var select: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.select != nil {
            map["Select"] = self.select!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("Select") {
            self.select = dict["Select"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetRangeResponseBody : Tea.TeaModel {
    public class BackgroundColors : Tea.TeaModel {
        public var red: Int32?

        public var green: Int32?

        public var blue: Int32?

        public var hexString: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.red != nil {
                map["Red"] = self.red!
            }
            if self.green != nil {
                map["Green"] = self.green!
            }
            if self.blue != nil {
                map["Blue"] = self.blue!
            }
            if self.hexString != nil {
                map["HexString"] = self.hexString!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Red") {
                self.red = dict["Red"] as! Int32
            }
            if dict.keys.contains("Green") {
                self.green = dict["Green"] as! Int32
            }
            if dict.keys.contains("Blue") {
                self.blue = dict["Blue"] as! Int32
            }
            if dict.keys.contains("HexString") {
                self.hexString = dict["HexString"] as! String
            }
        }
    }
    public var backgroundColors: [[GetRangeResponseBody.BackgroundColors]]?

    public var displayValues: [[String]]?

    public var formulas: [[String]]?

    public var requestId: String?

    public var values: [[Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColors != nil {
            var tmp : [Any] = []
            for k in self.backgroundColors! {
                var l1 : [Any] = []
                for k1 in k {
                    l1.append(k1.toMap())
                }
                tmp.append(l1)
            }
            map["backgroundColors"] = tmp
        }
        if self.displayValues != nil {
            map["displayValues"] = self.displayValues!
        }
        if self.formulas != nil {
            map["formulas"] = self.formulas!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.values != nil {
            map["values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("backgroundColors") {
            var tmp : [[GetRangeResponseBody.BackgroundColors]] = []
            for v in dict["backgroundColors"] as! [Any] {
                var l1 : [GetRangeResponseBody.BackgroundColors] = []
                for v1 in v as! [Any] {
                    var model = GetRangeResponseBody.BackgroundColors()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp.append(l1)
            }
            self.backgroundColors = tmp
        }
        if dict.keys.contains("displayValues") {
            self.displayValues = dict["displayValues"] as! [[String]]
        }
        if dict.keys.contains("formulas") {
            self.formulas = dict["formulas"] as! [[String]]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("values") {
            self.values = dict["values"] as! [[Any]]
        }
    }
}

public class GetRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRelatedWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetRelatedWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetRelatedWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetRelatedWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetRelatedWorkspacesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var includeRecent: Bool?

    public var tenantContext: GetRelatedWorkspacesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeRecent != nil {
            map["IncludeRecent"] = self.includeRecent!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeRecent") {
            self.includeRecent = dict["IncludeRecent"] as! Bool
        }
        if dict.keys.contains("TenantContext") {
            var model = GetRelatedWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetRelatedWorkspacesShrinkRequest : Tea.TeaModel {
    public var includeRecent: Bool?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeRecent != nil {
            map["IncludeRecent"] = self.includeRecent!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeRecent") {
            self.includeRecent = dict["IncludeRecent"] as! Bool
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetRelatedWorkspacesResponseBody : Tea.TeaModel {
    public class Workspaces : Tea.TeaModel {
        public class RecentList : Tea.TeaModel {
            public var lastEditTime: Int64?

            public var name: String?

            public var nodeId: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lastEditTime != nil {
                    map["LastEditTime"] = self.lastEditTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LastEditTime") {
                    self.lastEditTime = dict["LastEditTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var deleted: Bool?

        public var name: String?

        public var owner: String?

        public var recentList: [GetRelatedWorkspacesResponseBody.Workspaces.RecentList]?

        public var role: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deleted != nil {
                map["Deleted"] = self.deleted!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.recentList != nil {
                var tmp : [Any] = []
                for k in self.recentList! {
                    tmp.append(k.toMap())
                }
                map["RecentList"] = tmp
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Deleted") {
                self.deleted = dict["Deleted"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("RecentList") {
                var tmp : [GetRelatedWorkspacesResponseBody.Workspaces.RecentList] = []
                for v in dict["RecentList"] as! [Any] {
                    var model = GetRelatedWorkspacesResponseBody.Workspaces.RecentList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recentList = tmp
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public var workspaces: [GetRelatedWorkspacesResponseBody.Workspaces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        if self.workspaces != nil {
            var tmp : [Any] = []
            for k in self.workspaces! {
                tmp.append(k.toMap())
            }
            map["workspaces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
        if dict.keys.contains("workspaces") {
            var tmp : [GetRelatedWorkspacesResponseBody.Workspaces] = []
            for v in dict["workspaces"] as! [Any] {
                var model = GetRelatedWorkspacesResponseBody.Workspaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspaces = tmp
        }
    }
}

public class GetRelatedWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRelatedWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRelatedWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetReportTemplateByNameHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetReportTemplateByNameHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetReportTemplateByNameHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetReportTemplateByNameShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetReportTemplateByNameRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var templateName: String?

    public var tenantContext: GetReportTemplateByNameRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetReportTemplateByNameRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetReportTemplateByNameShrinkRequest : Tea.TeaModel {
    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetReportTemplateByNameResponseBody : Tea.TeaModel {
    public class DefaultReceivedConvs : Tea.TeaModel {
        public var conversationId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conversationId != nil {
                map["ConversationId"] = self.conversationId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConversationId") {
                self.conversationId = dict["ConversationId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class DefaultReceivers : Tea.TeaModel {
        public var userName: String?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userid != nil {
                map["Userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("Userid") {
                self.userid = dict["Userid"] as! String
            }
        }
    }
    public class Fields : Tea.TeaModel {
        public var fieldName: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FieldName") {
                self.fieldName = dict["FieldName"] as! String
            }
            if dict.keys.contains("Sort") {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public var defaultReceivedConvs: [GetReportTemplateByNameResponseBody.DefaultReceivedConvs]?

    public var defaultReceivers: [GetReportTemplateByNameResponseBody.DefaultReceivers]?

    public var fields: [GetReportTemplateByNameResponseBody.Fields]?

    public var id: String?

    public var name: String?

    public var requestId: String?

    public var userName: String?

    public var userid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultReceivedConvs != nil {
            var tmp : [Any] = []
            for k in self.defaultReceivedConvs! {
                tmp.append(k.toMap())
            }
            map["defaultReceivedConvs"] = tmp
        }
        if self.defaultReceivers != nil {
            var tmp : [Any] = []
            for k in self.defaultReceivers! {
                tmp.append(k.toMap())
            }
            map["defaultReceivers"] = tmp
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        if self.userid != nil {
            map["userid"] = self.userid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("defaultReceivedConvs") {
            var tmp : [GetReportTemplateByNameResponseBody.DefaultReceivedConvs] = []
            for v in dict["defaultReceivedConvs"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.DefaultReceivedConvs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultReceivedConvs = tmp
        }
        if dict.keys.contains("defaultReceivers") {
            var tmp : [GetReportTemplateByNameResponseBody.DefaultReceivers] = []
            for v in dict["defaultReceivers"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.DefaultReceivers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultReceivers = tmp
        }
        if dict.keys.contains("fields") {
            var tmp : [GetReportTemplateByNameResponseBody.Fields] = []
            for v in dict["fields"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.Fields()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fields = tmp
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("userName") {
            self.userName = dict["userName"] as! String
        }
        if dict.keys.contains("userid") {
            self.userid = dict["userid"] as! String
        }
    }
}

public class GetReportTemplateByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReportTemplateByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetReportTemplateByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetReportUnReadCountHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetReportUnReadCountHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetReportUnReadCountHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetReportUnReadCountShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetReportUnReadCountRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: GetReportUnReadCountRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") {
            var model = GetReportUnReadCountRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetReportUnReadCountShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetReportUnReadCountResponseBody : Tea.TeaModel {
    public var count: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("count") {
            self.count = dict["count"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetReportUnReadCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReportUnReadCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetReportUnReadCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRunningTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetRunningTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetRunningTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetRunningTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetRunningTasksRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processCodes: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessCodes") {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetRunningTasksResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var activeTimeGMT: String?

        public var activityId: String?

        public var actualActionerId: String?

        public var createTimeGMT: String?

        public var finishTimeGMT: String?

        public var originatorId: String?

        public var processInstanceId: String?

        public var status: String?

        public var taskId: String?

        public var taskType: String?

        public var title: String?

        public var titleInEnglish: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.actualActionerId != nil {
                map["ActualActionerId"] = self.actualActionerId!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.titleInEnglish != nil {
                map["TitleInEnglish"] = self.titleInEnglish!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveTimeGMT") {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActivityId") {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("ActualActionerId") {
                self.actualActionerId = dict["ActualActionerId"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorId") {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("TitleInEnglish") {
                self.titleInEnglish = dict["TitleInEnglish"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetRunningTasksResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [GetRunningTasksResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetRunningTasksResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetRunningTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRunningTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRunningTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetScheduleHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetScheduleHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetScheduleHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetScheduleShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetScheduleRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: String?

    public var startTime: String?

    public var tenantContext: GetScheduleRequest.TenantContext?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetScheduleRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! [String]
        }
    }
}

public class GetScheduleShrinkRequest : Tea.TeaModel {
    public var endTime: String?

    public var startTime: String?

    public var tenantContextShrink: String?

    public var userIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userIdsShrink != nil {
            map["UserIds"] = self.userIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserIds") {
            self.userIdsShrink = dict["UserIds"] as! String
        }
    }
}

public class GetScheduleResponseBody : Tea.TeaModel {
    public class ScheduleInformation : Tea.TeaModel {
        public class ScheduleItems : Tea.TeaModel {
            public class End : Tea.TeaModel {
                public var date: String?

                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.date != nil {
                        map["Date"] = self.date!
                    }
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Date") {
                        self.date = dict["Date"] as! String
                    }
                    if dict.keys.contains("DateTime") {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public class Start : Tea.TeaModel {
                public var date: String?

                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.date != nil {
                        map["Date"] = self.date!
                    }
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Date") {
                        self.date = dict["Date"] as! String
                    }
                    if dict.keys.contains("DateTime") {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public var end: GetScheduleResponseBody.ScheduleInformation.ScheduleItems.End?

            public var start: GetScheduleResponseBody.ScheduleInformation.ScheduleItems.Start?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.end?.validate()
                try self.start?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    var model = GetScheduleResponseBody.ScheduleInformation.ScheduleItems.End()
                    model.fromMap(dict["End"] as! [String: Any])
                    self.end = model
                }
                if dict.keys.contains("Start") {
                    var model = GetScheduleResponseBody.ScheduleInformation.ScheduleItems.Start()
                    model.fromMap(dict["Start"] as! [String: Any])
                    self.start = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var error: String?

        public var scheduleItems: [GetScheduleResponseBody.ScheduleInformation.ScheduleItems]?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.scheduleItems != nil {
                var tmp : [Any] = []
                for k in self.scheduleItems! {
                    tmp.append(k.toMap())
                }
                map["ScheduleItems"] = tmp
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("ScheduleItems") {
                var tmp : [GetScheduleResponseBody.ScheduleInformation.ScheduleItems] = []
                for v in dict["ScheduleItems"] as! [Any] {
                    var model = GetScheduleResponseBody.ScheduleInformation.ScheduleItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scheduleItems = tmp
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var scheduleInformation: [GetScheduleResponseBody.ScheduleInformation]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.scheduleInformation != nil {
            var tmp : [Any] = []
            for k in self.scheduleInformation! {
                tmp.append(k.toMap())
            }
            map["scheduleInformation"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("scheduleInformation") {
            var tmp : [GetScheduleResponseBody.ScheduleInformation] = []
            for v in dict["scheduleInformation"] as! [Any] {
                var model = GetScheduleResponseBody.ScheduleInformation()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scheduleInformation = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var sheetId: String?

    public var tenantContext: GetSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetSheetShrinkRequest : Tea.TeaModel {
    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetSheetResponseBody : Tea.TeaModel {
    public var columnCount: Int64?

    public var id: String?

    public var lastNonEmptyColumn: Int64?

    public var lastNonEmptyRow: Int64?

    public var name: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnCount != nil {
            map["columnCount"] = self.columnCount!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastNonEmptyColumn != nil {
            map["lastNonEmptyColumn"] = self.lastNonEmptyColumn!
        }
        if self.lastNonEmptyRow != nil {
            map["lastNonEmptyRow"] = self.lastNonEmptyRow!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["rowCount"] = self.rowCount!
        }
        if self.visibility != nil {
            map["visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("columnCount") {
            self.columnCount = dict["columnCount"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("lastNonEmptyColumn") {
            self.lastNonEmptyColumn = dict["lastNonEmptyColumn"] as! Int64
        }
        if dict.keys.contains("lastNonEmptyRow") {
            self.lastNonEmptyRow = dict["lastNonEmptyRow"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("rowCount") {
            self.rowCount = dict["rowCount"] as! Int64
        }
        if dict.keys.contains("visibility") {
            self.visibility = dict["visibility"] as! String
        }
    }
}

public class GetSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSheetContentJobIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSheetContentJobIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetSheetContentJobIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSheetContentJobIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSheetContentJobIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryUuid: String?

    public var exportType: String?

    public var tenantContext: GetSheetContentJobIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("ExportType") {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetSheetContentJobIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetSheetContentJobIdShrinkRequest : Tea.TeaModel {
    public var dentryUuid: String?

    public var exportType: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryUuid != nil {
            map["DentryUuid"] = self.dentryUuid!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryUuid") {
            self.dentryUuid = dict["DentryUuid"] as! String
        }
        if dict.keys.contains("ExportType") {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetSheetContentJobIdResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var status: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["jobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("jobId") {
            self.jobId = dict["jobId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetSheetContentJobIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSheetContentJobIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSheetContentJobIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSpaceDirectoriesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSpaceDirectoriesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetSpaceDirectoriesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSpaceDirectoriesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSpaceDirectoriesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceId: String?

    public var tenantContext: GetSpaceDirectoriesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetSpaceDirectoriesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetSpaceDirectoriesShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetSpaceDirectoriesResponseBody : Tea.TeaModel {
    public class Children : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class LinkSourceInfo : Tea.TeaModel {
            public class IconUrl : Tea.TeaModel {
                public var line: String?

                public var small: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        map["Line"] = self.line!
                    }
                    if self.small != nil {
                        map["Small"] = self.small!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") {
                        self.line = dict["Line"] as! String
                    }
                    if dict.keys.contains("Small") {
                        self.small = dict["Small"] as! String
                    }
                }
            }
            public var extension_: String?

            public var iconUrl: GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo.IconUrl?

            public var id: String?

            public var linkType: Int64?

            public var spaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.iconUrl?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.iconUrl != nil {
                    map["IconUrl"] = self.iconUrl?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.linkType != nil {
                    map["LinkType"] = self.linkType!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("IconUrl") {
                    var model = GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo.IconUrl()
                    model.fromMap(dict["IconUrl"] as! [String: Any])
                    self.iconUrl = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LinkType") {
                    self.linkType = dict["LinkType"] as! Int64
                }
                if dict.keys.contains("SpaceId") {
                    self.spaceId = dict["SpaceId"] as! String
                }
            }
        }
        public class Space : Tea.TeaModel {
            public class HdIconVO : Tea.TeaModel {
                public var icon: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Icon") {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class IconVO : Tea.TeaModel {
                public var icon: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Icon") {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Owner : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var cover: String?

            public var description_: String?

            public var hdIconVO: GetSpaceDirectoriesResponseBody.Children.Space.HdIconVO?

            public var iconVO: GetSpaceDirectoriesResponseBody.Children.Space.IconVO?

            public var id: String?

            public var name: String?

            public var owner: GetSpaceDirectoriesResponseBody.Children.Space.Owner?

            public var recentList: [Any]?

            public var type: Int32?

            public var url: String?

            public var visitorInfo: GetSpaceDirectoriesResponseBody.Children.Space.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hdIconVO?.validate()
                try self.iconVO?.validate()
                try self.owner?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cover != nil {
                    map["Cover"] = self.cover!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hdIconVO != nil {
                    map["HdIconVO"] = self.hdIconVO?.toMap()
                }
                if self.iconVO != nil {
                    map["IconVO"] = self.iconVO?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner?.toMap()
                }
                if self.recentList != nil {
                    map["RecentList"] = self.recentList!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cover") {
                    self.cover = dict["Cover"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HdIconVO") {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.HdIconVO()
                    model.fromMap(dict["HdIconVO"] as! [String: Any])
                    self.hdIconVO = model
                }
                if dict.keys.contains("IconVO") {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.IconVO()
                    model.fromMap(dict["IconVO"] as! [String: Any])
                    self.iconVO = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.Owner()
                    model.fromMap(dict["Owner"] as! [String: Any])
                    self.owner = model
                }
                if dict.keys.contains("RecentList") {
                    self.recentList = dict["RecentList"] as! [Any]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public class Updater : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var contentType: String?

        public var createdTime: Int64?

        public var creator: GetSpaceDirectoriesResponseBody.Children.Creator?

        public var dentryId: String?

        public var dentryType: String?

        public var dentryUuid: String?

        public var docKey: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var linkSourceInfo: GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo?

        public var name: String?

        public var path: String?

        public var space: GetSpaceDirectoriesResponseBody.Children.Space?

        public var spaceId: String?

        public var statisticalInfo: GetSpaceDirectoriesResponseBody.Children.StatisticalInfo?

        public var updatedTime: Int64?

        public var updater: GetSpaceDirectoriesResponseBody.Children.Updater?

        public var url: String?

        public var visitorInfo: GetSpaceDirectoriesResponseBody.Children.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
            try self.linkSourceInfo?.validate()
            try self.space?.validate()
            try self.statisticalInfo?.validate()
            try self.updater?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator?.toMap()
            }
            if self.dentryId != nil {
                map["DentryId"] = self.dentryId!
            }
            if self.dentryType != nil {
                map["DentryType"] = self.dentryType!
            }
            if self.dentryUuid != nil {
                map["DentryUuid"] = self.dentryUuid!
            }
            if self.docKey != nil {
                map["DocKey"] = self.docKey!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.linkSourceInfo != nil {
                map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.space != nil {
                map["Space"] = self.space?.toMap()
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updater != nil {
                map["Updater"] = self.updater?.toMap()
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentType") {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                var model = GetSpaceDirectoriesResponseBody.Children.Creator()
                model.fromMap(dict["Creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("DentryId") {
                self.dentryId = dict["DentryId"] as! String
            }
            if dict.keys.contains("DentryType") {
                self.dentryType = dict["DentryType"] as! String
            }
            if dict.keys.contains("DentryUuid") {
                self.dentryUuid = dict["DentryUuid"] as! String
            }
            if dict.keys.contains("DocKey") {
                self.docKey = dict["DocKey"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("LinkSourceInfo") {
                var model = GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo()
                model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                self.linkSourceInfo = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Space") {
                var model = GetSpaceDirectoriesResponseBody.Children.Space()
                model.fromMap(dict["Space"] as! [String: Any])
                self.space = model
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
            if dict.keys.contains("StatisticalInfo") {
                var model = GetSpaceDirectoriesResponseBody.Children.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("Updater") {
                var model = GetSpaceDirectoriesResponseBody.Children.Updater()
                model.fromMap(dict["Updater"] as! [String: Any])
                self.updater = model
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") {
                var model = GetSpaceDirectoriesResponseBody.Children.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public var children: [GetSpaceDirectoriesResponseBody.Children]?

    public var hasMore: Bool?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["children"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("children") {
            var tmp : [GetSpaceDirectoriesResponseBody.Children] = []
            for v in dict["children"] as! [Any] {
                var model = GetSpaceDirectoriesResponseBody.Children()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.children = tmp
        }
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetSpaceDirectoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSpaceDirectoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSpaceDirectoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSubscribedCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class GetSubscribedCalendarResponseBody : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var corpIds: [String]?

        public var openConversationIds: [String]?

        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpIds != nil {
                map["CorpIds"] = self.corpIds!
            }
            if self.openConversationIds != nil {
                map["OpenConversationIds"] = self.openConversationIds!
            }
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpIds") {
                self.corpIds = dict["CorpIds"] as! [String]
            }
            if dict.keys.contains("OpenConversationIds") {
                self.openConversationIds = dict["OpenConversationIds"] as! [String]
            }
            if dict.keys.contains("UserIds") {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var author: String?

    public var calendarId: String?

    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var requestId: String?

    public var subscribeScope: GetSubscribedCalendarResponseBody.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.author != nil {
            map["author"] = self.author!
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.managers != nil {
            map["managers"] = self.managers!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.subscribeScope != nil {
            map["subscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("author") {
            self.author = dict["author"] as! String
        }
        if dict.keys.contains("calendarId") {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("managers") {
            self.managers = dict["managers"] as! [String]
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("subscribeScope") {
            var model = GetSubscribedCalendarResponseBody.SubscribeScope()
            model.fromMap(dict["subscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class GetSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskCopiesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTaskCopiesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetTaskCopiesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTaskCopiesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTaskCopiesRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetTaskCopiesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CurrentActivityInstances : Tea.TeaModel {
            public var activityId: String?

            public var activityInstanceStatus: String?

            public var activityName: String?

            public var activityNameInEnglish: String?

            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityId != nil {
                    map["ActivityId"] = self.activityId!
                }
                if self.activityInstanceStatus != nil {
                    map["ActivityInstanceStatus"] = self.activityInstanceStatus!
                }
                if self.activityName != nil {
                    map["ActivityName"] = self.activityName!
                }
                if self.activityNameInEnglish != nil {
                    map["ActivityNameInEnglish"] = self.activityNameInEnglish!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityId") {
                    self.activityId = dict["ActivityId"] as! String
                }
                if dict.keys.contains("ActivityInstanceStatus") {
                    self.activityInstanceStatus = dict["ActivityInstanceStatus"] as! String
                }
                if dict.keys.contains("ActivityName") {
                    self.activityName = dict["ActivityName"] as! String
                }
                if dict.keys.contains("ActivityNameInEnglish") {
                    self.activityNameInEnglish = dict["ActivityNameInEnglish"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
            }
        }
        public var actionExecutorId: [String]?

        public var actionExecutorName: [String]?

        public var appType: String?

        public var carbonActivityId: String?

        public var createTimeGMT: String?

        public var currentActivityInstances: [GetTaskCopiesResponseBody.Data.CurrentActivityInstances]?

        public var dataMap: [String: Any]?

        public var dataType: String?

        public var finishTimeGMT: String?

        public var formInstanceId: String?

        public var formUuid: String?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var originatorAvatar: String?

        public var originatorDisplayName: String?

        public var originatorId: String?

        public var processApprovedResult: String?

        public var processApprovedResultText: String?

        public var processCode: String?

        public var processId: Int64?

        public var processInstanceId: String?

        public var processInstanceStatus: String?

        public var processInstanceStatusText: String?

        public var processName: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionExecutorId != nil {
                map["ActionExecutorId"] = self.actionExecutorId!
            }
            if self.actionExecutorName != nil {
                map["ActionExecutorName"] = self.actionExecutorName!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.carbonActivityId != nil {
                map["CarbonActivityId"] = self.carbonActivityId!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.currentActivityInstances != nil {
                var tmp : [Any] = []
                for k in self.currentActivityInstances! {
                    tmp.append(k.toMap())
                }
                map["CurrentActivityInstances"] = tmp
            }
            if self.dataMap != nil {
                map["DataMap"] = self.dataMap!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.originatorAvatar != nil {
                map["OriginatorAvatar"] = self.originatorAvatar!
            }
            if self.originatorDisplayName != nil {
                map["OriginatorDisplayName"] = self.originatorDisplayName!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.processApprovedResult != nil {
                map["ProcessApprovedResult"] = self.processApprovedResult!
            }
            if self.processApprovedResultText != nil {
                map["ProcessApprovedResultText"] = self.processApprovedResultText!
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.processInstanceStatus != nil {
                map["ProcessInstanceStatus"] = self.processInstanceStatus!
            }
            if self.processInstanceStatusText != nil {
                map["ProcessInstanceStatusText"] = self.processInstanceStatusText!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionExecutorId") {
                self.actionExecutorId = dict["ActionExecutorId"] as! [String]
            }
            if dict.keys.contains("ActionExecutorName") {
                self.actionExecutorName = dict["ActionExecutorName"] as! [String]
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CarbonActivityId") {
                self.carbonActivityId = dict["CarbonActivityId"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CurrentActivityInstances") {
                var tmp : [GetTaskCopiesResponseBody.Data.CurrentActivityInstances] = []
                for v in dict["CurrentActivityInstances"] as! [Any] {
                    var model = GetTaskCopiesResponseBody.Data.CurrentActivityInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentActivityInstances = tmp
            }
            if dict.keys.contains("DataMap") {
                self.dataMap = dict["DataMap"] as! [String: Any]
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceValue") {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorAvatar") {
                self.originatorAvatar = dict["OriginatorAvatar"] as! String
            }
            if dict.keys.contains("OriginatorDisplayName") {
                self.originatorDisplayName = dict["OriginatorDisplayName"] as! String
            }
            if dict.keys.contains("OriginatorId") {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("ProcessApprovedResult") {
                self.processApprovedResult = dict["ProcessApprovedResult"] as! String
            }
            if dict.keys.contains("ProcessApprovedResultText") {
                self.processApprovedResultText = dict["ProcessApprovedResultText"] as! String
            }
            if dict.keys.contains("ProcessCode") {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessId") {
                self.processId = dict["ProcessId"] as! Int64
            }
            if dict.keys.contains("ProcessInstanceId") {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatus") {
                self.processInstanceStatus = dict["ProcessInstanceStatus"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatusText") {
                self.processInstanceStatusText = dict["ProcessInstanceStatusText"] as! String
            }
            if dict.keys.contains("ProcessName") {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [GetTaskCopiesResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [GetTaskCopiesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetTaskCopiesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetTaskCopiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskCopiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskCopiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateListByUserIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTemplateListByUserIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetTemplateListByUserIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTemplateListByUserIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTemplateListByUserIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var size: Int64?

    public var tenantContext: GetTemplateListByUserIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = GetTemplateListByUserIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetTemplateListByUserIdShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetTemplateListByUserIdResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var iconUrl: String?

        public var name: String?

        public var reportCode: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reportCode != nil {
                map["ReportCode"] = self.reportCode!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IconUrl") {
                self.iconUrl = dict["IconUrl"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ReportCode") {
                self.reportCode = dict["ReportCode"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var nextCursor: Int64?

    public var requestId: String?

    public var templateList: [GetTemplateListByUserIdResponseBody.TemplateList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["templateList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextCursor") {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("templateList") {
            var tmp : [GetTemplateListByUserIdResponseBody.TemplateList] = []
            for v in dict["templateList"] as! [Any] {
                var model = GetTemplateListByUserIdResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
    }
}

public class GetTemplateListByUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateListByUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplateListByUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTicketHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTicketHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetTicketHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTicketShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTicketRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContext: GetTicketRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetTicketRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetTicketShrinkRequest : Tea.TeaModel {
    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetTicketResponseBody : Tea.TeaModel {
    public class Creator : Tea.TeaModel {
        public var nickName: String?

        public var unionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.unionId != nil {
                map["UnionId"] = self.unionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("UnionId") {
                self.unionId = dict["UnionId"] as! String
            }
        }
    }
    public class Processor : Tea.TeaModel {
        public var nickName: String?

        public var unionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.unionId != nil {
                map["UnionId"] = self.unionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("UnionId") {
                self.unionId = dict["UnionId"] as! String
            }
        }
    }
    public class Takers : Tea.TeaModel {
        public var nickName: String?

        public var unionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.unionId != nil {
                map["UnionId"] = self.unionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("UnionId") {
                self.unionId = dict["UnionId"] as! String
            }
        }
    }
    public class Template : Tea.TeaModel {
        public var openTemplateBizId: String?

        public var openTemplateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.openTemplateBizId != nil {
                map["OpenTemplateBizId"] = self.openTemplateBizId!
            }
            if self.openTemplateId != nil {
                map["OpenTemplateId"] = self.openTemplateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OpenTemplateBizId") {
                self.openTemplateBizId = dict["OpenTemplateBizId"] as! String
            }
            if dict.keys.contains("OpenTemplateId") {
                self.openTemplateId = dict["OpenTemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var createTime: String?

    public var creator: GetTicketResponseBody.Creator?

    public var customFields: String?

    public var openConversationId: String?

    public var openTicketId: String?

    public var processor: GetTicketResponseBody.Processor?

    public var requestId: String?

    public var scene: String?

    public var sceneContext: String?

    public var stage: String?

    public var takers: [GetTicketResponseBody.Takers]?

    public var template: GetTicketResponseBody.Template?

    public var title: String?

    public var updateTime: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.creator?.validate()
        try self.processor?.validate()
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.creator != nil {
            map["creator"] = self.creator?.toMap()
        }
        if self.customFields != nil {
            map["customFields"] = self.customFields!
        }
        if self.openConversationId != nil {
            map["openConversationId"] = self.openConversationId!
        }
        if self.openTicketId != nil {
            map["openTicketId"] = self.openTicketId!
        }
        if self.processor != nil {
            map["processor"] = self.processor?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        if self.sceneContext != nil {
            map["sceneContext"] = self.sceneContext!
        }
        if self.stage != nil {
            map["stage"] = self.stage!
        }
        if self.takers != nil {
            var tmp : [Any] = []
            for k in self.takers! {
                tmp.append(k.toMap())
            }
            map["takers"] = tmp
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("creator") {
            var model = GetTicketResponseBody.Creator()
            model.fromMap(dict["creator"] as! [String: Any])
            self.creator = model
        }
        if dict.keys.contains("customFields") {
            self.customFields = dict["customFields"] as! String
        }
        if dict.keys.contains("openConversationId") {
            self.openConversationId = dict["openConversationId"] as! String
        }
        if dict.keys.contains("openTicketId") {
            self.openTicketId = dict["openTicketId"] as! String
        }
        if dict.keys.contains("processor") {
            var model = GetTicketResponseBody.Processor()
            model.fromMap(dict["processor"] as! [String: Any])
            self.processor = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("scene") {
            self.scene = dict["scene"] as! String
        }
        if dict.keys.contains("sceneContext") {
            self.sceneContext = dict["sceneContext"] as! String
        }
        if dict.keys.contains("stage") {
            self.stage = dict["stage"] as! String
        }
        if dict.keys.contains("takers") {
            var tmp : [GetTicketResponseBody.Takers] = []
            for v in dict["takers"] as! [Any] {
                var model = GetTicketResponseBody.Takers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.takers = tmp
        }
        if dict.keys.contains("template") {
            var model = GetTicketResponseBody.Template()
            model.fromMap(dict["template"] as! [String: Any])
            self.template = model
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("updateTime") {
            self.updateTime = dict["updateTime"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var taskId: String?

    public var tenantContext: GetTodoTaskRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = GetTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetTodoTaskShrinkRequest : Tea.TeaModel {
    public var taskId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetTodoTaskResponseBody : Tea.TeaModel {
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["AppUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["PcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppUrl") {
                self.appUrl = dict["AppUrl"] as! String
            }
            if dict.keys.contains("PcUrl") {
                self.pcUrl = dict["PcUrl"] as! String
            }
        }
    }
    public var bizTag: String?

    public var cardTypeId: String?

    public var createdTime: Int64?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: GetTodoTaskResponseBody.DetailUrl?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var finishTime: Int64?

    public var id: String?

    public var isOnlyShowExecutor: Bool?

    public var modifiedTime: Int64?

    public var modifierId: String?

    public var participantIds: [String]?

    public var priority: Int32?

    public var requestId: String?

    public var source: String?

    public var sourceId: String?

    public var startTime: Int64?

    public var subject: String?

    public var tenantId: String?

    public var tenantType: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailUrl?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizTag != nil {
            map["bizTag"] = self.bizTag!
        }
        if self.cardTypeId != nil {
            map["cardTypeId"] = self.cardTypeId!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.finishTime != nil {
            map["finishTime"] = self.finishTime!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.modifiedTime != nil {
            map["modifiedTime"] = self.modifiedTime!
        }
        if self.modifierId != nil {
            map["modifierId"] = self.modifierId!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tenantId != nil {
            map["tenantId"] = self.tenantId!
        }
        if self.tenantType != nil {
            map["tenantType"] = self.tenantType!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("bizTag") {
            self.bizTag = dict["bizTag"] as! String
        }
        if dict.keys.contains("cardTypeId") {
            self.cardTypeId = dict["cardTypeId"] as! String
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creatorId") {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") {
            var model = GetTodoTaskResponseBody.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("done") {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("finishTime") {
            self.finishTime = dict["finishTime"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("modifiedTime") {
            self.modifiedTime = dict["modifiedTime"] as! Int64
        }
        if dict.keys.contains("modifierId") {
            self.modifierId = dict["modifierId"] as! String
        }
        if dict.keys.contains("participantIds") {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("sourceId") {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("tenantId") {
            self.tenantId = dict["tenantId"] as! String
        }
        if dict.keys.contains("tenantType") {
            self.tenantType = dict["tenantType"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetUserHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetUserHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetUserShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetUserRequest.TenantContext?

    public var language: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GetUserRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("language") {
            self.language = dict["language"] as! String
        }
    }
}

public class GetUserShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var language: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("language") {
            self.language = dict["language"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class DeptOrderList : Tea.TeaModel {
        public var deptId: Int64?

        public var order: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptId != nil {
                map["deptId"] = self.deptId!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deptId") {
                self.deptId = dict["deptId"] as! Int64
            }
            if dict.keys.contains("order") {
                self.order = dict["order"] as! Int64
            }
        }
    }
    public class LeaderInDept : Tea.TeaModel {
        public var deptId: Int64?

        public var leader: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptId != nil {
                map["deptId"] = self.deptId!
            }
            if self.leader != nil {
                map["leader"] = self.leader!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deptId") {
                self.deptId = dict["deptId"] as! Int64
            }
            if dict.keys.contains("leader") {
                self.leader = dict["leader"] as! Bool
            }
        }
    }
    public class RoleList : Tea.TeaModel {
        public var groupName: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupName") {
                self.groupName = dict["groupName"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public class UnionEmpExt : Tea.TeaModel {
        public class UnionEmpMapList : Tea.TeaModel {
            public var cropId: String?

            public var userid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cropId != nil {
                    map["cropId"] = self.cropId!
                }
                if self.userid != nil {
                    map["userid"] = self.userid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cropId") {
                    self.cropId = dict["cropId"] as! String
                }
                if dict.keys.contains("userid") {
                    self.userid = dict["userid"] as! String
                }
            }
        }
        public var corpId: String?

        public var unionEmpMapList: [GetUserResponseBody.UnionEmpExt.UnionEmpMapList]?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["corpId"] = self.corpId!
            }
            if self.unionEmpMapList != nil {
                var tmp : [Any] = []
                for k in self.unionEmpMapList! {
                    tmp.append(k.toMap())
                }
                map["unionEmpMapList"] = tmp
            }
            if self.userid != nil {
                map["userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("corpId") {
                self.corpId = dict["corpId"] as! String
            }
            if dict.keys.contains("unionEmpMapList") {
                var tmp : [GetUserResponseBody.UnionEmpExt.UnionEmpMapList] = []
                for v in dict["unionEmpMapList"] as! [Any] {
                    var model = GetUserResponseBody.UnionEmpExt.UnionEmpMapList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.unionEmpMapList = tmp
            }
            if dict.keys.contains("userid") {
                self.userid = dict["userid"] as! String
            }
        }
    }
    public var active: Bool?

    public var admin: Bool?

    public var avatar: String?

    public var boss: Bool?

    public var deptIdList: [Int64]?

    public var deptOrderList: [GetUserResponseBody.DeptOrderList]?

    public var email: String?

    public var exclusiveAccount: Bool?

    public var exclusiveAccountCorpId: String?

    public var exclusiveAccountCorpName: String?

    public var exclusiveAccountType: String?

    public var extension_: String?

    public var hideMobile: Bool?

    public var hiredDate: Int64?

    public var jobNumber: String?

    public var leaderInDept: [GetUserResponseBody.LeaderInDept]?

    public var loginId: String?

    public var managerUserid: String?

    public var mobile: String?

    public var name: String?

    public var nickname: String?

    public var orgEmail: String?

    public var realAuthed: Bool?

    public var remark: String?

    public var requestId: String?

    public var roleList: [GetUserResponseBody.RoleList]?

    public var senior: Bool?

    public var stateCode: String?

    public var telephone: String?

    public var title: String?

    public var unionEmpExt: GetUserResponseBody.UnionEmpExt?

    public var unionid: String?

    public var userid: String?

    public var workPlace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.unionEmpExt?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["active"] = self.active!
        }
        if self.admin != nil {
            map["admin"] = self.admin!
        }
        if self.avatar != nil {
            map["avatar"] = self.avatar!
        }
        if self.boss != nil {
            map["boss"] = self.boss!
        }
        if self.deptIdList != nil {
            map["deptIdList"] = self.deptIdList!
        }
        if self.deptOrderList != nil {
            var tmp : [Any] = []
            for k in self.deptOrderList! {
                tmp.append(k.toMap())
            }
            map["deptOrderList"] = tmp
        }
        if self.email != nil {
            map["email"] = self.email!
        }
        if self.exclusiveAccount != nil {
            map["exclusiveAccount"] = self.exclusiveAccount!
        }
        if self.exclusiveAccountCorpId != nil {
            map["exclusiveAccountCorpId"] = self.exclusiveAccountCorpId!
        }
        if self.exclusiveAccountCorpName != nil {
            map["exclusiveAccountCorpName"] = self.exclusiveAccountCorpName!
        }
        if self.exclusiveAccountType != nil {
            map["exclusiveAccountType"] = self.exclusiveAccountType!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hideMobile != nil {
            map["hideMobile"] = self.hideMobile!
        }
        if self.hiredDate != nil {
            map["hiredDate"] = self.hiredDate!
        }
        if self.jobNumber != nil {
            map["jobNumber"] = self.jobNumber!
        }
        if self.leaderInDept != nil {
            var tmp : [Any] = []
            for k in self.leaderInDept! {
                tmp.append(k.toMap())
            }
            map["leaderInDept"] = tmp
        }
        if self.loginId != nil {
            map["loginId"] = self.loginId!
        }
        if self.managerUserid != nil {
            map["managerUserid"] = self.managerUserid!
        }
        if self.mobile != nil {
            map["mobile"] = self.mobile!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.nickname != nil {
            map["nickname"] = self.nickname!
        }
        if self.orgEmail != nil {
            map["orgEmail"] = self.orgEmail!
        }
        if self.realAuthed != nil {
            map["realAuthed"] = self.realAuthed!
        }
        if self.remark != nil {
            map["remark"] = self.remark!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roleList != nil {
            var tmp : [Any] = []
            for k in self.roleList! {
                tmp.append(k.toMap())
            }
            map["roleList"] = tmp
        }
        if self.senior != nil {
            map["senior"] = self.senior!
        }
        if self.stateCode != nil {
            map["stateCode"] = self.stateCode!
        }
        if self.telephone != nil {
            map["telephone"] = self.telephone!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.unionEmpExt != nil {
            map["unionEmpExt"] = self.unionEmpExt?.toMap()
        }
        if self.unionid != nil {
            map["unionid"] = self.unionid!
        }
        if self.userid != nil {
            map["userid"] = self.userid!
        }
        if self.workPlace != nil {
            map["workPlace"] = self.workPlace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("active") {
            self.active = dict["active"] as! Bool
        }
        if dict.keys.contains("admin") {
            self.admin = dict["admin"] as! Bool
        }
        if dict.keys.contains("avatar") {
            self.avatar = dict["avatar"] as! String
        }
        if dict.keys.contains("boss") {
            self.boss = dict["boss"] as! Bool
        }
        if dict.keys.contains("deptIdList") {
            self.deptIdList = dict["deptIdList"] as! [Int64]
        }
        if dict.keys.contains("deptOrderList") {
            var tmp : [GetUserResponseBody.DeptOrderList] = []
            for v in dict["deptOrderList"] as! [Any] {
                var model = GetUserResponseBody.DeptOrderList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deptOrderList = tmp
        }
        if dict.keys.contains("email") {
            self.email = dict["email"] as! String
        }
        if dict.keys.contains("exclusiveAccount") {
            self.exclusiveAccount = dict["exclusiveAccount"] as! Bool
        }
        if dict.keys.contains("exclusiveAccountCorpId") {
            self.exclusiveAccountCorpId = dict["exclusiveAccountCorpId"] as! String
        }
        if dict.keys.contains("exclusiveAccountCorpName") {
            self.exclusiveAccountCorpName = dict["exclusiveAccountCorpName"] as! String
        }
        if dict.keys.contains("exclusiveAccountType") {
            self.exclusiveAccountType = dict["exclusiveAccountType"] as! String
        }
        if dict.keys.contains("extension") {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hideMobile") {
            self.hideMobile = dict["hideMobile"] as! Bool
        }
        if dict.keys.contains("hiredDate") {
            self.hiredDate = dict["hiredDate"] as! Int64
        }
        if dict.keys.contains("jobNumber") {
            self.jobNumber = dict["jobNumber"] as! String
        }
        if dict.keys.contains("leaderInDept") {
            var tmp : [GetUserResponseBody.LeaderInDept] = []
            for v in dict["leaderInDept"] as! [Any] {
                var model = GetUserResponseBody.LeaderInDept()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.leaderInDept = tmp
        }
        if dict.keys.contains("loginId") {
            self.loginId = dict["loginId"] as! String
        }
        if dict.keys.contains("managerUserid") {
            self.managerUserid = dict["managerUserid"] as! String
        }
        if dict.keys.contains("mobile") {
            self.mobile = dict["mobile"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("nickname") {
            self.nickname = dict["nickname"] as! String
        }
        if dict.keys.contains("orgEmail") {
            self.orgEmail = dict["orgEmail"] as! String
        }
        if dict.keys.contains("realAuthed") {
            self.realAuthed = dict["realAuthed"] as! Bool
        }
        if dict.keys.contains("remark") {
            self.remark = dict["remark"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roleList") {
            var tmp : [GetUserResponseBody.RoleList] = []
            for v in dict["roleList"] as! [Any] {
                var model = GetUserResponseBody.RoleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.roleList = tmp
        }
        if dict.keys.contains("senior") {
            self.senior = dict["senior"] as! Bool
        }
        if dict.keys.contains("stateCode") {
            self.stateCode = dict["stateCode"] as! String
        }
        if dict.keys.contains("telephone") {
            self.telephone = dict["telephone"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("unionEmpExt") {
            var model = GetUserResponseBody.UnionEmpExt()
            model.fromMap(dict["unionEmpExt"] as! [String: Any])
            self.unionEmpExt = model
        }
        if dict.keys.contains("unionid") {
            self.unionid = dict["unionid"] as! String
        }
        if dict.keys.contains("userid") {
            self.userid = dict["userid"] as! String
        }
        if dict.keys.contains("workPlace") {
            self.workPlace = dict["workPlace"] as! String
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetUserIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetUserIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetUserIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetUserIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetUserIdRequest.TenantContext?

    public var unionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.unionId != nil {
            map["UnionId"] = self.unionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GetUserIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UnionId") {
            self.unionId = dict["UnionId"] as! String
        }
    }
}

public class GetUserIdShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var unionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.unionId != nil {
            map["UnionId"] = self.unionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UnionId") {
            self.unionId = dict["UnionId"] as! String
        }
    }
}

public class GetUserIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var userId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserIdByOrgIdAndStaffIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetUserIdByOrgIdAndStaffIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetUserIdByOrgIdAndStaffIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetUserIdByOrgIdAndStaffIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetUserIdByOrgIdAndStaffIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var orgId: Int64?

    public var tenantContext: GetUserIdByOrgIdAndStaffIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgId != nil {
            map["OrgId"] = self.orgId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrgId") {
            self.orgId = dict["OrgId"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = GetUserIdByOrgIdAndStaffIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetUserIdByOrgIdAndStaffIdShrinkRequest : Tea.TeaModel {
    public var orgId: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgId != nil {
            map["OrgId"] = self.orgId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrgId") {
            self.orgId = dict["OrgId"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetUserIdByOrgIdAndStaffIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var userId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetUserIdByOrgIdAndStaffIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserIdByOrgIdAndStaffIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserIdByOrgIdAndStaffIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserLatestPlanHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetUserLatestPlanHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetUserLatestPlanHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetUserLatestPlanShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetUserLatestPlanRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetUserLatestPlanRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GetUserLatestPlanRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetUserLatestPlanShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetUserLatestPlanResponseBody : Tea.TeaModel {
    public var accountHandleStatus: Int32?

    public var accountHandleTime: String?

    public var accountType: Int32?

    public var agreementFirstSignTime: String?

    public var agreementLastSignTime: String?

    public var agreementStatus: Int32?

    public var dataHandleEndTime: String?

    public var dataHandleStartTime: String?

    public var dataHandleStatus: Int32?

    public var exclusivePlan: Int32?

    public var newAccountUid: Int64?

    public var requestId: String?

    public var status: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountHandleStatus != nil {
            map["accountHandleStatus"] = self.accountHandleStatus!
        }
        if self.accountHandleTime != nil {
            map["accountHandleTime"] = self.accountHandleTime!
        }
        if self.accountType != nil {
            map["accountType"] = self.accountType!
        }
        if self.agreementFirstSignTime != nil {
            map["agreementFirstSignTime"] = self.agreementFirstSignTime!
        }
        if self.agreementLastSignTime != nil {
            map["agreementLastSignTime"] = self.agreementLastSignTime!
        }
        if self.agreementStatus != nil {
            map["agreementStatus"] = self.agreementStatus!
        }
        if self.dataHandleEndTime != nil {
            map["dataHandleEndTime"] = self.dataHandleEndTime!
        }
        if self.dataHandleStartTime != nil {
            map["dataHandleStartTime"] = self.dataHandleStartTime!
        }
        if self.dataHandleStatus != nil {
            map["dataHandleStatus"] = self.dataHandleStatus!
        }
        if self.exclusivePlan != nil {
            map["exclusivePlan"] = self.exclusivePlan!
        }
        if self.newAccountUid != nil {
            map["newAccountUid"] = self.newAccountUid!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accountHandleStatus") {
            self.accountHandleStatus = dict["accountHandleStatus"] as! Int32
        }
        if dict.keys.contains("accountHandleTime") {
            self.accountHandleTime = dict["accountHandleTime"] as! String
        }
        if dict.keys.contains("accountType") {
            self.accountType = dict["accountType"] as! Int32
        }
        if dict.keys.contains("agreementFirstSignTime") {
            self.agreementFirstSignTime = dict["agreementFirstSignTime"] as! String
        }
        if dict.keys.contains("agreementLastSignTime") {
            self.agreementLastSignTime = dict["agreementLastSignTime"] as! String
        }
        if dict.keys.contains("agreementStatus") {
            self.agreementStatus = dict["agreementStatus"] as! Int32
        }
        if dict.keys.contains("dataHandleEndTime") {
            self.dataHandleEndTime = dict["dataHandleEndTime"] as! String
        }
        if dict.keys.contains("dataHandleStartTime") {
            self.dataHandleStartTime = dict["dataHandleStartTime"] as! String
        }
        if dict.keys.contains("dataHandleStatus") {
            self.dataHandleStatus = dict["dataHandleStatus"] as! Int32
        }
        if dict.keys.contains("exclusivePlan") {
            self.exclusivePlan = dict["exclusivePlan"] as! Int32
        }
        if dict.keys.contains("newAccountUid") {
            self.newAccountUid = dict["newAccountUid"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetUserLatestPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserLatestPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserLatestPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetWorkspaceRequest.TenantContext?

    public var withPermissionRole: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GetWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetWorkspaceShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                var model = GetWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: GetWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") {
            var model = GetWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GetWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetWorkspacesRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetWorkspacesRequest.Option?

    public var tenantContext: GetWorkspacesRequest.TenantContext?

    public var workspaceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceIds != nil {
            map["WorkspaceIds"] = self.workspaceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            var model = GetWorkspacesRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") {
            var model = GetWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceIds") {
            self.workspaceIds = dict["WorkspaceIds"] as! [String]
        }
    }
}

public class GetWorkspacesShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var tenantContextShrink: String?

    public var workspaceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceIdsShrink != nil {
            map["WorkspaceIds"] = self.workspaceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceIds") {
            self.workspaceIdsShrink = dict["WorkspaceIds"] as! String
        }
    }
}

public class GetWorkspacesResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetWorkspacesResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                var model = GetWorkspacesResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: [GetWorkspacesResponseBody.Workspace]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            var tmp : [Any] = []
            for k in self.workspace! {
                tmp.append(k.toMap())
            }
            map["workspace"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") {
            var tmp : [GetWorkspacesResponseBody.Workspace] = []
            for v in dict["workspace"] as! [Any] {
                var model = GetWorkspacesResponseBody.Workspace()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspace = tmp
        }
    }
}

public class GetWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GrantHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = GrantHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GrantHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GrantHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GrantHonorRequest.TenantContext?

    public var expirationTime: Int64?

    public var grantReason: String?

    public var granterName: String?

    public var honorId: String?

    public var noticeAnnouncer: Bool?

    public var noticeSingle: Bool?

    public var openConversationIds: [String]?

    public var orgId: Int64?

    public var receiverUserIds: [String]?

    public var senderUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.expirationTime != nil {
            map["expirationTime"] = self.expirationTime!
        }
        if self.grantReason != nil {
            map["grantReason"] = self.grantReason!
        }
        if self.granterName != nil {
            map["granterName"] = self.granterName!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.noticeAnnouncer != nil {
            map["noticeAnnouncer"] = self.noticeAnnouncer!
        }
        if self.noticeSingle != nil {
            map["noticeSingle"] = self.noticeSingle!
        }
        if self.openConversationIds != nil {
            map["openConversationIds"] = self.openConversationIds!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.receiverUserIds != nil {
            map["receiverUserIds"] = self.receiverUserIds!
        }
        if self.senderUserId != nil {
            map["senderUserId"] = self.senderUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = GrantHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("expirationTime") {
            self.expirationTime = dict["expirationTime"] as! Int64
        }
        if dict.keys.contains("grantReason") {
            self.grantReason = dict["grantReason"] as! String
        }
        if dict.keys.contains("granterName") {
            self.granterName = dict["granterName"] as! String
        }
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("noticeAnnouncer") {
            self.noticeAnnouncer = dict["noticeAnnouncer"] as! Bool
        }
        if dict.keys.contains("noticeSingle") {
            self.noticeSingle = dict["noticeSingle"] as! Bool
        }
        if dict.keys.contains("openConversationIds") {
            self.openConversationIds = dict["openConversationIds"] as! [String]
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("receiverUserIds") {
            self.receiverUserIds = dict["receiverUserIds"] as! [String]
        }
        if dict.keys.contains("senderUserId") {
            self.senderUserId = dict["senderUserId"] as! String
        }
    }
}

public class GrantHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var expirationTime: Int64?

    public var grantReason: String?

    public var granterName: String?

    public var honorId: String?

    public var noticeAnnouncer: Bool?

    public var noticeSingle: Bool?

    public var openConversationIdsShrink: String?

    public var orgId: Int64?

    public var receiverUserIdsShrink: String?

    public var senderUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.expirationTime != nil {
            map["expirationTime"] = self.expirationTime!
        }
        if self.grantReason != nil {
            map["grantReason"] = self.grantReason!
        }
        if self.granterName != nil {
            map["granterName"] = self.granterName!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.noticeAnnouncer != nil {
            map["noticeAnnouncer"] = self.noticeAnnouncer!
        }
        if self.noticeSingle != nil {
            map["noticeSingle"] = self.noticeSingle!
        }
        if self.openConversationIdsShrink != nil {
            map["openConversationIds"] = self.openConversationIdsShrink!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.receiverUserIdsShrink != nil {
            map["receiverUserIds"] = self.receiverUserIdsShrink!
        }
        if self.senderUserId != nil {
            map["senderUserId"] = self.senderUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("expirationTime") {
            self.expirationTime = dict["expirationTime"] as! Int64
        }
        if dict.keys.contains("grantReason") {
            self.grantReason = dict["grantReason"] as! String
        }
        if dict.keys.contains("granterName") {
            self.granterName = dict["granterName"] as! String
        }
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("noticeAnnouncer") {
            self.noticeAnnouncer = dict["noticeAnnouncer"] as! Bool
        }
        if dict.keys.contains("noticeSingle") {
            self.noticeSingle = dict["noticeSingle"] as! Bool
        }
        if dict.keys.contains("openConversationIds") {
            self.openConversationIdsShrink = dict["openConversationIds"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("receiverUserIds") {
            self.receiverUserIdsShrink = dict["receiverUserIds"] as! String
        }
        if dict.keys.contains("senderUserId") {
            self.senderUserId = dict["senderUserId"] as! String
        }
    }
}

public class GrantHonorResponseBody : Tea.TeaModel {
    public var failedUserIds: [String]?

    public var requestId: String?

    public var successUserIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedUserIds != nil {
            map["failedUserIds"] = self.failedUserIds!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.successUserIds != nil {
            map["successUserIds"] = self.successUserIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failedUserIds") {
            self.failedUserIds = dict["failedUserIds"] as! [String]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("successUserIds") {
            self.successUserIds = dict["successUserIds"] as! [String]
        }
    }
}

public class GrantHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GrantHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitMultipartFileUploadHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InitMultipartFileUploadHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = InitMultipartFileUploadHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InitMultipartFileUploadShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InitMultipartFileUploadRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public class PreCheckParam : Tea.TeaModel {
            public var md5: String?

            public var name: String?

            public var parentId: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.md5 != nil {
                    map["Md5"] = self.md5!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Md5") {
                    self.md5 = dict["Md5"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
            }
        }
        public var preCheckParam: InitMultipartFileUploadRequest.Option.PreCheckParam?

        public var preferRegion: String?

        public var storageDriver: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.preCheckParam?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preCheckParam != nil {
                map["PreCheckParam"] = self.preCheckParam?.toMap()
            }
            if self.preferRegion != nil {
                map["PreferRegion"] = self.preferRegion!
            }
            if self.storageDriver != nil {
                map["StorageDriver"] = self.storageDriver!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreCheckParam") {
                var model = InitMultipartFileUploadRequest.Option.PreCheckParam()
                model.fromMap(dict["PreCheckParam"] as! [String: Any])
                self.preCheckParam = model
            }
            if dict.keys.contains("PreferRegion") {
                self.preferRegion = dict["PreferRegion"] as! String
            }
            if dict.keys.contains("StorageDriver") {
                self.storageDriver = dict["StorageDriver"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: InitMultipartFileUploadRequest.Option?

    public var parentDentryUuid: String?

    public var tenantContext: InitMultipartFileUploadRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.parentDentryUuid != nil {
            map["ParentDentryUuid"] = self.parentDentryUuid!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            var model = InitMultipartFileUploadRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("ParentDentryUuid") {
            self.parentDentryUuid = dict["ParentDentryUuid"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = InitMultipartFileUploadRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class InitMultipartFileUploadShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var parentDentryUuid: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.parentDentryUuid != nil {
            map["ParentDentryUuid"] = self.parentDentryUuid!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("ParentDentryUuid") {
            self.parentDentryUuid = dict["ParentDentryUuid"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class InitMultipartFileUploadResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var storageDriver: String?

    public var uploadKey: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.storageDriver != nil {
            map["storageDriver"] = self.storageDriver!
        }
        if self.uploadKey != nil {
            map["uploadKey"] = self.uploadKey!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("storageDriver") {
            self.storageDriver = dict["storageDriver"] as! String
        }
        if dict.keys.contains("uploadKey") {
            self.uploadKey = dict["uploadKey"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class InitMultipartFileUploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitMultipartFileUploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitMultipartFileUploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertColumnsBeforeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InsertColumnsBeforeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = InsertColumnsBeforeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InsertColumnsBeforeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InsertColumnsBeforeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: InsertColumnsBeforeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = InsertColumnsBeforeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertColumnsBeforeShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertColumnsBeforeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InsertColumnsBeforeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertColumnsBeforeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InsertColumnsBeforeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertRowsBeforeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InsertRowsBeforeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = InsertRowsBeforeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InsertRowsBeforeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InsertRowsBeforeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: InsertRowsBeforeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = InsertRowsBeforeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertRowsBeforeShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertRowsBeforeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InsertRowsBeforeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertRowsBeforeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InsertRowsBeforeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InviteUsersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InviteUsersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = InviteUsersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InviteUsersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InviteUsersRequest : Tea.TeaModel {
    public class InviteeList : Tea.TeaModel {
        public var nick: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nick != nil {
                map["Nick"] = self.nick!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nick") {
                self.nick = dict["Nick"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class PhoneInviteeList : Tea.TeaModel {
        public var inviteClient: Bool?

        public var nick: String?

        public var phoneNumber: String?

        public var statusCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inviteClient != nil {
                map["InviteClient"] = self.inviteClient!
            }
            if self.nick != nil {
                map["Nick"] = self.nick!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InviteClient") {
                self.inviteClient = dict["InviteClient"] as! Bool
            }
            if dict.keys.contains("Nick") {
                self.nick = dict["Nick"] as! String
            }
            if dict.keys.contains("PhoneNumber") {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("StatusCode") {
                self.statusCode = dict["StatusCode"] as! String
            }
        }
    }
    public var inviteeList: [InviteUsersRequest.InviteeList]?

    public var tenantContext: InviteUsersRequest.TenantContext?

    public var conferenceId: String?

    public var phoneInviteeList: [InviteUsersRequest.PhoneInviteeList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inviteeList != nil {
            var tmp : [Any] = []
            for k in self.inviteeList! {
                tmp.append(k.toMap())
            }
            map["InviteeList"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.phoneInviteeList != nil {
            var tmp : [Any] = []
            for k in self.phoneInviteeList! {
                tmp.append(k.toMap())
            }
            map["phoneInviteeList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InviteeList") {
            var tmp : [InviteUsersRequest.InviteeList] = []
            for v in dict["InviteeList"] as! [Any] {
                var model = InviteUsersRequest.InviteeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inviteeList = tmp
        }
        if dict.keys.contains("TenantContext") {
            var model = InviteUsersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("phoneInviteeList") {
            var tmp : [InviteUsersRequest.PhoneInviteeList] = []
            for v in dict["phoneInviteeList"] as! [Any] {
                var model = InviteUsersRequest.PhoneInviteeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.phoneInviteeList = tmp
        }
    }
}

public class InviteUsersShrinkRequest : Tea.TeaModel {
    public var inviteeListShrink: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public var phoneInviteeListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inviteeListShrink != nil {
            map["InviteeList"] = self.inviteeListShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.phoneInviteeListShrink != nil {
            map["phoneInviteeList"] = self.phoneInviteeListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InviteeList") {
            self.inviteeListShrink = dict["InviteeList"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("phoneInviteeList") {
            self.phoneInviteeListShrink = dict["phoneInviteeList"] as! String
        }
    }
}

public class InviteUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class InviteUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InviteUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InviteUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InvokeAssistantHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
    }
}

public class InvokeAssistantRequest : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class CardCallback : Tea.TeaModel {
            public var content: String?

            public var templateId: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public class DingCard : Tea.TeaModel {
            public var cardDesc: String?

            public var content: String?

            public var contentType: String?

            public var finished: Bool?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardDesc != nil {
                    map["cardDesc"] = self.cardDesc!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.contentType != nil {
                    map["contentType"] = self.contentType!
                }
                if self.finished != nil {
                    map["finished"] = self.finished!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardDesc") {
                    self.cardDesc = dict["cardDesc"] as! String
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("contentType") {
                    self.contentType = dict["contentType"] as! String
                }
                if dict.keys.contains("finished") {
                    self.finished = dict["finished"] as! Bool
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
            }
        }
        public class ImageUrl : Tea.TeaModel {
            public var detail: String?

            public var imageDesc: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail!
                }
                if self.imageDesc != nil {
                    map["imageDesc"] = self.imageDesc!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    self.detail = dict["detail"] as! String
                }
                if dict.keys.contains("imageDesc") {
                    self.imageDesc = dict["imageDesc"] as! String
                }
                if dict.keys.contains("url") {
                    self.url = dict["url"] as! String
                }
            }
        }
        public class Markdown : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class Text : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var cardCallback: InvokeAssistantRequest.Content.CardCallback?

        public var dingCard: InvokeAssistantRequest.Content.DingCard?

        public var imageUrl: InvokeAssistantRequest.Content.ImageUrl?

        public var markdown: InvokeAssistantRequest.Content.Markdown?

        public var text: InvokeAssistantRequest.Content.Text?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cardCallback?.validate()
            try self.dingCard?.validate()
            try self.imageUrl?.validate()
            try self.markdown?.validate()
            try self.text?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardCallback != nil {
                map["cardCallback"] = self.cardCallback?.toMap()
            }
            if self.dingCard != nil {
                map["dingCard"] = self.dingCard?.toMap()
            }
            if self.imageUrl != nil {
                map["imageUrl"] = self.imageUrl?.toMap()
            }
            if self.markdown != nil {
                map["markdown"] = self.markdown?.toMap()
            }
            if self.text != nil {
                map["text"] = self.text?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cardCallback") {
                var model = InvokeAssistantRequest.Content.CardCallback()
                model.fromMap(dict["cardCallback"] as! [String: Any])
                self.cardCallback = model
            }
            if dict.keys.contains("dingCard") {
                var model = InvokeAssistantRequest.Content.DingCard()
                model.fromMap(dict["dingCard"] as! [String: Any])
                self.dingCard = model
            }
            if dict.keys.contains("imageUrl") {
                var model = InvokeAssistantRequest.Content.ImageUrl()
                model.fromMap(dict["imageUrl"] as! [String: Any])
                self.imageUrl = model
            }
            if dict.keys.contains("markdown") {
                var model = InvokeAssistantRequest.Content.Markdown()
                model.fromMap(dict["markdown"] as! [String: Any])
                self.markdown = model
            }
            if dict.keys.contains("text") {
                var model = InvokeAssistantRequest.Content.Text()
                model.fromMap(dict["text"] as! [String: Any])
                self.text = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public class History : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class CardCallback : Tea.TeaModel {
                public var content: String?

                public var templateId: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.templateId != nil {
                        map["templateId"] = self.templateId!
                    }
                    if self.userId != nil {
                        map["userId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("templateId") {
                        self.templateId = dict["templateId"] as! String
                    }
                    if dict.keys.contains("userId") {
                        self.userId = dict["userId"] as! String
                    }
                }
            }
            public class DingCard : Tea.TeaModel {
                public var cardDesc: String?

                public var content: String?

                public var contentType: String?

                public var finished: Bool?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cardDesc != nil {
                        map["cardDesc"] = self.cardDesc!
                    }
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.contentType != nil {
                        map["contentType"] = self.contentType!
                    }
                    if self.finished != nil {
                        map["finished"] = self.finished!
                    }
                    if self.templateId != nil {
                        map["templateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cardDesc") {
                        self.cardDesc = dict["cardDesc"] as! String
                    }
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("contentType") {
                        self.contentType = dict["contentType"] as! String
                    }
                    if dict.keys.contains("finished") {
                        self.finished = dict["finished"] as! Bool
                    }
                    if dict.keys.contains("templateId") {
                        self.templateId = dict["templateId"] as! String
                    }
                }
            }
            public class ImageUrl : Tea.TeaModel {
                public var detail: String?

                public var imageDesc: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        map["detail"] = self.detail!
                    }
                    if self.imageDesc != nil {
                        map["imageDesc"] = self.imageDesc!
                    }
                    if self.url != nil {
                        map["url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("detail") {
                        self.detail = dict["detail"] as! String
                    }
                    if dict.keys.contains("imageDesc") {
                        self.imageDesc = dict["imageDesc"] as! String
                    }
                    if dict.keys.contains("url") {
                        self.url = dict["url"] as! String
                    }
                }
            }
            public class Markdown : Tea.TeaModel {
                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public class Text : Tea.TeaModel {
                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var cardCallback: InvokeAssistantRequest.History.Content.CardCallback?

            public var dingCard: InvokeAssistantRequest.History.Content.DingCard?

            public var imageUrl: InvokeAssistantRequest.History.Content.ImageUrl?

            public var markdown: InvokeAssistantRequest.History.Content.Markdown?

            public var text: InvokeAssistantRequest.History.Content.Text?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cardCallback?.validate()
                try self.dingCard?.validate()
                try self.imageUrl?.validate()
                try self.markdown?.validate()
                try self.text?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardCallback != nil {
                    map["cardCallback"] = self.cardCallback?.toMap()
                }
                if self.dingCard != nil {
                    map["dingCard"] = self.dingCard?.toMap()
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl?.toMap()
                }
                if self.markdown != nil {
                    map["markdown"] = self.markdown?.toMap()
                }
                if self.text != nil {
                    map["text"] = self.text?.toMap()
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardCallback") {
                    var model = InvokeAssistantRequest.History.Content.CardCallback()
                    model.fromMap(dict["cardCallback"] as! [String: Any])
                    self.cardCallback = model
                }
                if dict.keys.contains("dingCard") {
                    var model = InvokeAssistantRequest.History.Content.DingCard()
                    model.fromMap(dict["dingCard"] as! [String: Any])
                    self.dingCard = model
                }
                if dict.keys.contains("imageUrl") {
                    var model = InvokeAssistantRequest.History.Content.ImageUrl()
                    model.fromMap(dict["imageUrl"] as! [String: Any])
                    self.imageUrl = model
                }
                if dict.keys.contains("markdown") {
                    var model = InvokeAssistantRequest.History.Content.Markdown()
                    model.fromMap(dict["markdown"] as! [String: Any])
                    self.markdown = model
                }
                if dict.keys.contains("text") {
                    var model = InvokeAssistantRequest.History.Content.Text()
                    model.fromMap(dict["text"] as! [String: Any])
                    self.text = model
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var content: [InvokeAssistantRequest.History.Content]?

        public var role: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["content"] = tmp
            }
            if self.role != nil {
                map["role"] = self.role!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                var tmp : [InvokeAssistantRequest.History.Content] = []
                for v in dict["content"] as! [Any] {
                    var model = InvokeAssistantRequest.History.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("role") {
                self.role = dict["role"] as! String
            }
        }
    }
    public var assistantId: String?

    public var content: [InvokeAssistantRequest.Content]?

    public var history: [InvokeAssistantRequest.History]?

    public var sessionId: String?

    public var stream: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistantId != nil {
            map["assistantId"] = self.assistantId!
        }
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["content"] = tmp
        }
        if self.history != nil {
            var tmp : [Any] = []
            for k in self.history! {
                tmp.append(k.toMap())
            }
            map["history"] = tmp
        }
        if self.sessionId != nil {
            map["sessionId"] = self.sessionId!
        }
        if self.stream != nil {
            map["stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assistantId") {
            self.assistantId = dict["assistantId"] as! String
        }
        if dict.keys.contains("content") {
            var tmp : [InvokeAssistantRequest.Content] = []
            for v in dict["content"] as! [Any] {
                var model = InvokeAssistantRequest.Content()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.content = tmp
        }
        if dict.keys.contains("history") {
            var tmp : [InvokeAssistantRequest.History] = []
            for v in dict["history"] as! [Any] {
                var model = InvokeAssistantRequest.History()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.history = tmp
        }
        if dict.keys.contains("sessionId") {
            self.sessionId = dict["sessionId"] as! String
        }
        if dict.keys.contains("stream") {
            self.stream = dict["stream"] as! Bool
        }
    }
}

public class InvokeAssistantResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class CardCallback : Tea.TeaModel {
            public var content: String?

            public var templateId: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public class DingCard : Tea.TeaModel {
            public var cardDesc: String?

            public var content: String?

            public var contentType: String?

            public var finished: Bool?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardDesc != nil {
                    map["cardDesc"] = self.cardDesc!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.contentType != nil {
                    map["contentType"] = self.contentType!
                }
                if self.finished != nil {
                    map["finished"] = self.finished!
                }
                if self.templateId != nil {
                    map["templateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardDesc") {
                    self.cardDesc = dict["cardDesc"] as! String
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("contentType") {
                    self.contentType = dict["contentType"] as! String
                }
                if dict.keys.contains("finished") {
                    self.finished = dict["finished"] as! Bool
                }
                if dict.keys.contains("templateId") {
                    self.templateId = dict["templateId"] as! String
                }
            }
        }
        public class ImageUrl : Tea.TeaModel {
            public var detail: String?

            public var imageDesc: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail!
                }
                if self.imageDesc != nil {
                    map["imageDesc"] = self.imageDesc!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    self.detail = dict["detail"] as! String
                }
                if dict.keys.contains("imageDesc") {
                    self.imageDesc = dict["imageDesc"] as! String
                }
                if dict.keys.contains("url") {
                    self.url = dict["url"] as! String
                }
            }
        }
        public class Markdown : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class Text : Tea.TeaModel {
            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var cardCallback: InvokeAssistantResponseBody.Content.CardCallback?

        public var dingCard: InvokeAssistantResponseBody.Content.DingCard?

        public var imageUrl: InvokeAssistantResponseBody.Content.ImageUrl?

        public var markdown: InvokeAssistantResponseBody.Content.Markdown?

        public var text: InvokeAssistantResponseBody.Content.Text?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cardCallback?.validate()
            try self.dingCard?.validate()
            try self.imageUrl?.validate()
            try self.markdown?.validate()
            try self.text?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cardCallback != nil {
                map["cardCallback"] = self.cardCallback?.toMap()
            }
            if self.dingCard != nil {
                map["dingCard"] = self.dingCard?.toMap()
            }
            if self.imageUrl != nil {
                map["imageUrl"] = self.imageUrl?.toMap()
            }
            if self.markdown != nil {
                map["markdown"] = self.markdown?.toMap()
            }
            if self.text != nil {
                map["text"] = self.text?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cardCallback") {
                var model = InvokeAssistantResponseBody.Content.CardCallback()
                model.fromMap(dict["cardCallback"] as! [String: Any])
                self.cardCallback = model
            }
            if dict.keys.contains("dingCard") {
                var model = InvokeAssistantResponseBody.Content.DingCard()
                model.fromMap(dict["dingCard"] as! [String: Any])
                self.dingCard = model
            }
            if dict.keys.contains("imageUrl") {
                var model = InvokeAssistantResponseBody.Content.ImageUrl()
                model.fromMap(dict["imageUrl"] as! [String: Any])
                self.imageUrl = model
            }
            if dict.keys.contains("markdown") {
                var model = InvokeAssistantResponseBody.Content.Markdown()
                model.fromMap(dict["markdown"] as! [String: Any])
                self.markdown = model
            }
            if dict.keys.contains("text") {
                var model = InvokeAssistantResponseBody.Content.Text()
                model.fromMap(dict["text"] as! [String: Any])
                self.text = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var content: [InvokeAssistantResponseBody.Content]?

    public var requestId: String?

    public var sessionId: String?

    public var streamEnd: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["content"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sessionId != nil {
            map["sessionId"] = self.sessionId!
        }
        if self.streamEnd != nil {
            map["streamEnd"] = self.streamEnd!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            var tmp : [InvokeAssistantResponseBody.Content] = []
            for v in dict["content"] as! [Any] {
                var model = InvokeAssistantResponseBody.Content()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.content = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("sessionId") {
            self.sessionId = dict["sessionId"] as! String
        }
        if dict.keys.contains("streamEnd") {
            self.streamEnd = dict["streamEnd"] as! Bool
        }
    }
}

public class InvokeAssistantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InvokeAssistantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InvokeAssistantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InvokeSkillHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InvokeSkillHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = InvokeSkillHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InvokeSkillShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InvokeSkillRequest : Tea.TeaModel {
    public var params: [String: Any]?

    public var skillId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.skillId != nil {
            map["SkillId"] = self.skillId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String: Any]
        }
        if dict.keys.contains("SkillId") {
            self.skillId = dict["SkillId"] as! String
        }
    }
}

public class InvokeSkillShrinkRequest : Tea.TeaModel {
    public var paramsShrink: String?

    public var skillId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paramsShrink != nil {
            map["Params"] = self.paramsShrink!
        }
        if self.skillId != nil {
            map["SkillId"] = self.skillId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Params") {
            self.paramsShrink = dict["Params"] as! String
        }
        if dict.keys.contains("SkillId") {
            self.skillId = dict["SkillId"] as! String
        }
    }
}

public class InvokeSkillResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! [String: Any]
        }
    }
}

public class InvokeSkillResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InvokeSkillResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InvokeSkillResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListApplicationHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListApplicationHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListApplicationShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListApplicationRequest : Tea.TeaModel {
    public var appFilter: String?

    public var appNameSearchKeyword: String?

    public var corpId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appFilter != nil {
            map["AppFilter"] = self.appFilter!
        }
        if self.appNameSearchKeyword != nil {
            map["AppNameSearchKeyword"] = self.appNameSearchKeyword!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppFilter") {
            self.appFilter = dict["AppFilter"] as! String
        }
        if dict.keys.contains("AppNameSearchKeyword") {
            self.appNameSearchKeyword = dict["AppNameSearchKeyword"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class ListApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appConfig: String?

        public var appType: String?

        public var applicationStatus: String?

        public var corpId: String?

        public var creatorUserId: String?

        public var description_: String?

        public var icon: String?

        public var inexistence: String?

        public var name: String?

        public var subCorpId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appConfig != nil {
                map["AppConfig"] = self.appConfig!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.applicationStatus != nil {
                map["ApplicationStatus"] = self.applicationStatus!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.inexistence != nil {
                map["Inexistence"] = self.inexistence!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.subCorpId != nil {
                map["SubCorpId"] = self.subCorpId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppConfig") {
                self.appConfig = dict["AppConfig"] as! String
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("ApplicationStatus") {
                self.applicationStatus = dict["ApplicationStatus"] as! String
            }
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("CreatorUserId") {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("Inexistence") {
                self.inexistence = dict["Inexistence"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SubCorpId") {
                self.subCorpId = dict["SubCorpId"] as! String
            }
        }
    }
    public var data: [ListApplicationResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [ListApplicationResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListApplicationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCalendarsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListCalendarsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListCalendarsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListCalendarsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListCalendarsRequest : Tea.TeaModel {
    public var request: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.request = dict["Request"] as! [String: Any]
        }
    }
}

public class ListCalendarsShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.requestShrink = dict["Request"] as! String
        }
    }
}

public class ListCalendarsResponseBody : Tea.TeaModel {
    public class Response : Tea.TeaModel {
        public class Calendars : Tea.TeaModel {
            public var description_: String?

            public var ETag: String?

            public var id: String?

            public var privilege: String?

            public var summary: String?

            public var timeZone: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ETag != nil {
                    map["ETag"] = self.ETag!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.privilege != nil {
                    map["Privilege"] = self.privilege!
                }
                if self.summary != nil {
                    map["Summary"] = self.summary!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ETag") {
                    self.ETag = dict["ETag"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Privilege") {
                    self.privilege = dict["Privilege"] as! String
                }
                if dict.keys.contains("Summary") {
                    self.summary = dict["Summary"] as! String
                }
                if dict.keys.contains("TimeZone") {
                    self.timeZone = dict["TimeZone"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var calendars: [ListCalendarsResponseBody.Response.Calendars]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.calendars != nil {
                var tmp : [Any] = []
                for k in self.calendars! {
                    tmp.append(k.toMap())
                }
                map["Calendars"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Calendars") {
                var tmp : [ListCalendarsResponseBody.Response.Calendars] = []
                for v in dict["Calendars"] as! [Any] {
                    var model = ListCalendarsResponseBody.Response.Calendars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.calendars = tmp
            }
        }
    }
    public var requestId: String?

    public var response: ListCalendarsResponseBody.Response?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.response?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.response != nil {
            map["response"] = self.response?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("response") {
            var model = ListCalendarsResponseBody.Response()
            model.fromMap(dict["response"] as! [String: Any])
            self.response = model
        }
    }
}

public class ListCalendarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCalendarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCalendarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDentriesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListDentriesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListDentriesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListDentriesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListDentriesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var order: String?

    public var orderBy: String?

    public var parentId: String?

    public var spaceId: String?

    public var tenantContext: ListDentriesRequest.TenantContext?

    public var withThumbnail: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withThumbnail != nil {
            map["WithThumbnail"] = self.withThumbnail!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListDentriesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithThumbnail") {
            self.withThumbnail = dict["WithThumbnail"] as! Bool
        }
    }
}

public class ListDentriesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var order: String?

    public var orderBy: String?

    public var parentId: String?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public var withThumbnail: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withThumbnail != nil {
            map["WithThumbnail"] = self.withThumbnail!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! String
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithThumbnail") {
            self.withThumbnail = dict["WithThumbnail"] as! Bool
        }
    }
}

public class ListDentriesResponseBody : Tea.TeaModel {
    public class Dentries : Tea.TeaModel {
        public class Properties : Tea.TeaModel {
            public var readOnly: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
            }
        }
        public class Thumbnail : Tea.TeaModel {
            public var height: Int32?

            public var url: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var appProperties: [String: [DentriesAppPropertiesValue]]?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var id: String?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var parentId: String?

        public var partitionType: String?

        public var path: String?

        public var properties: ListDentriesResponseBody.Dentries.Properties?

        public var size: Int64?

        public var spaceId: String?

        public var status: String?

        public var storageDriver: String?

        public var thumbnail: ListDentriesResponseBody.Dentries.Thumbnail?

        public var type: String?

        public var uuid: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.properties?.validate()
            try self.thumbnail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appProperties != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.appProperties! {
                    var l1 : [Any] = []
                    for k1 in v {
                        l1.append(k1.toMap())
                    }
                    tmp[k] = l1
                }
                map["AppProperties"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.partitionType != nil {
                map["PartitionType"] = self.partitionType!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.properties != nil {
                map["Properties"] = self.properties?.toMap()
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageDriver != nil {
                map["StorageDriver"] = self.storageDriver!
            }
            if self.thumbnail != nil {
                map["Thumbnail"] = self.thumbnail?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppProperties") {
                var tmp : [String: [DentriesAppPropertiesValue]] = [:]
                for (k, v) in dict["AppProperties"] as! [String: Any] {
                    var l1 : [DentriesAppPropertiesValue] = []
                    for v1 in v as! [Any] {
                        var model = DentriesAppPropertiesValue()
                        if v1 != nil {
                            model.fromMap(v1 as! [String: Any])
                        }
                        l1.append(model)
                    }
                    tmp[k] = l1
                }
                self.appProperties = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! String
            }
            if dict.keys.contains("PartitionType") {
                self.partitionType = dict["PartitionType"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Properties") {
                var model = ListDentriesResponseBody.Dentries.Properties()
                model.fromMap(dict["Properties"] as! [String: Any])
                self.properties = model
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageDriver") {
                self.storageDriver = dict["StorageDriver"] as! String
            }
            if dict.keys.contains("Thumbnail") {
                var model = ListDentriesResponseBody.Dentries.Thumbnail()
                model.fromMap(dict["Thumbnail"] as! [String: Any])
                self.thumbnail = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var dentries: [ListDentriesResponseBody.Dentries]?

    public var nextToken: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentries != nil {
            var tmp : [Any] = []
            for k in self.dentries! {
                tmp.append(k.toMap())
            }
            map["dentries"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dentries") {
            var tmp : [ListDentriesResponseBody.Dentries] = []
            for v in dict["dentries"] as! [Any] {
                var model = ListDentriesResponseBody.Dentries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dentries = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListDentriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDentriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDentriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDriveSpacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListDriveSpacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListDriveSpacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListDriveSpacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListDriveSpacesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceType: String?

    public var tenantContext: ListDriveSpacesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceType != nil {
            map["SpaceType"] = self.spaceType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceType") {
            self.spaceType = dict["SpaceType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListDriveSpacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListDriveSpacesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceType: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceType != nil {
            map["SpaceType"] = self.spaceType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceType") {
            self.spaceType = dict["SpaceType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListDriveSpacesResponseBody : Tea.TeaModel {
    public class Spaces : Tea.TeaModel {
        public var createTime: String?

        public var modifyTime: String?

        public var permissionMode: String?

        public var quota: Int64?

        public var spaceId: String?

        public var spaceName: String?

        public var spaceType: String?

        public var usedQuota: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.permissionMode != nil {
                map["PermissionMode"] = self.permissionMode!
            }
            if self.quota != nil {
                map["Quota"] = self.quota!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            if self.spaceName != nil {
                map["SpaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["SpaceType"] = self.spaceType!
            }
            if self.usedQuota != nil {
                map["UsedQuota"] = self.usedQuota!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("PermissionMode") {
                self.permissionMode = dict["PermissionMode"] as! String
            }
            if dict.keys.contains("Quota") {
                self.quota = dict["Quota"] as! Int64
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
            if dict.keys.contains("SpaceName") {
                self.spaceName = dict["SpaceName"] as! String
            }
            if dict.keys.contains("SpaceType") {
                self.spaceType = dict["SpaceType"] as! String
            }
            if dict.keys.contains("UsedQuota") {
                self.usedQuota = dict["UsedQuota"] as! Int64
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var spaces: [ListDriveSpacesResponseBody.Spaces]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.spaces != nil {
            var tmp : [Any] = []
            for k in self.spaces! {
                tmp.append(k.toMap())
            }
            map["spaces"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("spaces") {
            var tmp : [ListDriveSpacesResponseBody.Spaces] = []
            for v in dict["spaces"] as! [Any] {
                var model = ListDriveSpacesResponseBody.Spaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spaces = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListDriveSpacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDriveSpacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDriveSpacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListEventsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListEventsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListEventsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListEventsRequest : Tea.TeaModel {
    public var calendarId: String?

    public var maxAttendees: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var seriesMasterId: String?

    public var showDeleted: Bool?

    public var syncToken: String?

    public var timeMax: String?

    public var timeMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.seriesMasterId != nil {
            map["SeriesMasterId"] = self.seriesMasterId!
        }
        if self.showDeleted != nil {
            map["ShowDeleted"] = self.showDeleted!
        }
        if self.syncToken != nil {
            map["SyncToken"] = self.syncToken!
        }
        if self.timeMax != nil {
            map["TimeMax"] = self.timeMax!
        }
        if self.timeMin != nil {
            map["TimeMin"] = self.timeMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("MaxAttendees") {
            self.maxAttendees = dict["MaxAttendees"] as! Int32
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SeriesMasterId") {
            self.seriesMasterId = dict["SeriesMasterId"] as! String
        }
        if dict.keys.contains("ShowDeleted") {
            self.showDeleted = dict["ShowDeleted"] as! Bool
        }
        if dict.keys.contains("SyncToken") {
            self.syncToken = dict["SyncToken"] as! String
        }
        if dict.keys.contains("TimeMax") {
            self.timeMax = dict["TimeMax"] as! String
        }
        if dict.keys.contains("TimeMin") {
            self.timeMin = dict["TimeMin"] as! String
        }
    }
}

public class ListEventsResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class Attendees : Tea.TeaModel {
            public var displayName: String?

            public var isOptional: Bool?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.isOptional != nil {
                    map["IsOptional"] = self.isOptional!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("IsOptional") {
                    self.isOptional = dict["IsOptional"] as! Bool
                }
                if dict.keys.contains("ResponseStatus") {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class Categories : Tea.TeaModel {
            public var displayName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
            }
        }
        public class End : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public class ExtendedProperties : Tea.TeaModel {
            public class SharedProperties : Tea.TeaModel {
                public var belongCorpId: String?

                public var sourceOpenCid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.belongCorpId != nil {
                        map["BelongCorpId"] = self.belongCorpId!
                    }
                    if self.sourceOpenCid != nil {
                        map["SourceOpenCid"] = self.sourceOpenCid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BelongCorpId") {
                        self.belongCorpId = dict["BelongCorpId"] as! String
                    }
                    if dict.keys.contains("SourceOpenCid") {
                        self.sourceOpenCid = dict["SourceOpenCid"] as! String
                    }
                }
            }
            public var sharedProperties: ListEventsResponseBody.Events.ExtendedProperties.SharedProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sharedProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sharedProperties != nil {
                    map["SharedProperties"] = self.sharedProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SharedProperties") {
                    var model = ListEventsResponseBody.Events.ExtendedProperties.SharedProperties()
                    model.fromMap(dict["SharedProperties"] as! [String: Any])
                    self.sharedProperties = model
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var displayName: String?

            public var meetingRooms: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.meetingRooms != nil {
                    map["MeetingRooms"] = self.meetingRooms!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("MeetingRooms") {
                    self.meetingRooms = dict["MeetingRooms"] as! [String]
                }
            }
        }
        public class MeetingRooms : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var roomId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.roomId != nil {
                    map["RoomId"] = self.roomId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("RoomId") {
                    self.roomId = dict["RoomId"] as! String
                }
            }
        }
        public class OnlineMeetingInfo : Tea.TeaModel {
            public var conferenceId: String?

            public var extraInfo: [String: Any]?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conferenceId != nil {
                    map["ConferenceId"] = self.conferenceId!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConferenceId") {
                    self.conferenceId = dict["ConferenceId"] as! String
                }
                if dict.keys.contains("ExtraInfo") {
                    self.extraInfo = dict["ExtraInfo"] as! [String: Any]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Organizer : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class OriginStart : Tea.TeaModel {
            public var dateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
            }
        }
        public class Recurrence : Tea.TeaModel {
            public class Pattern : Tea.TeaModel {
                public var dayOfMonth: Int32?

                public var daysOfWeek: String?

                public var index: String?

                public var interval: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dayOfMonth != nil {
                        map["DayOfMonth"] = self.dayOfMonth!
                    }
                    if self.daysOfWeek != nil {
                        map["DaysOfWeek"] = self.daysOfWeek!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DayOfMonth") {
                        self.dayOfMonth = dict["DayOfMonth"] as! Int32
                    }
                    if dict.keys.contains("DaysOfWeek") {
                        self.daysOfWeek = dict["DaysOfWeek"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Range : Tea.TeaModel {
                public var endDate: String?

                public var numberOfOccurrences: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.numberOfOccurrences != nil {
                        map["NumberOfOccurrences"] = self.numberOfOccurrences!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndDate") {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("NumberOfOccurrences") {
                        self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pattern: ListEventsResponseBody.Events.Recurrence.Pattern?

            public var range: ListEventsResponseBody.Events.Recurrence.Range?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pattern?.validate()
                try self.range?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pattern != nil {
                    map["Pattern"] = self.pattern?.toMap()
                }
                if self.range != nil {
                    map["Range"] = self.range?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Pattern") {
                    var model = ListEventsResponseBody.Events.Recurrence.Pattern()
                    model.fromMap(dict["Pattern"] as! [String: Any])
                    self.pattern = model
                }
                if dict.keys.contains("Range") {
                    var model = ListEventsResponseBody.Events.Recurrence.Range()
                    model.fromMap(dict["Range"] as! [String: Any])
                    self.range = model
                }
            }
        }
        public class Reminders : Tea.TeaModel {
            public var method: String?

            public var minutes: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.minutes != nil {
                    map["Minutes"] = self.minutes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Minutes") {
                    self.minutes = dict["Minutes"] as! String
                }
            }
        }
        public class RichTextDescription : Tea.TeaModel {
            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class Start : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var attendees: [ListEventsResponseBody.Events.Attendees]?

        public var categories: [ListEventsResponseBody.Events.Categories]?

        public var createTime: String?

        public var description_: String?

        public var end: ListEventsResponseBody.Events.End?

        public var extendedProperties: ListEventsResponseBody.Events.ExtendedProperties?

        public var id: String?

        public var isAllDay: Bool?

        public var location: ListEventsResponseBody.Events.Location?

        public var meetingRooms: [ListEventsResponseBody.Events.MeetingRooms]?

        public var onlineMeetingInfo: ListEventsResponseBody.Events.OnlineMeetingInfo?

        public var organizer: ListEventsResponseBody.Events.Organizer?

        public var originStart: ListEventsResponseBody.Events.OriginStart?

        public var recurrence: ListEventsResponseBody.Events.Recurrence?

        public var reminders: [ListEventsResponseBody.Events.Reminders]?

        public var richTextDescription: ListEventsResponseBody.Events.RichTextDescription?

        public var seriesMasterId: String?

        public var start: ListEventsResponseBody.Events.Start?

        public var status: String?

        public var summary: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.end?.validate()
            try self.extendedProperties?.validate()
            try self.location?.validate()
            try self.onlineMeetingInfo?.validate()
            try self.organizer?.validate()
            try self.originStart?.validate()
            try self.recurrence?.validate()
            try self.richTextDescription?.validate()
            try self.start?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendees != nil {
                var tmp : [Any] = []
                for k in self.attendees! {
                    tmp.append(k.toMap())
                }
                map["Attendees"] = tmp
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.end != nil {
                map["End"] = self.end?.toMap()
            }
            if self.extendedProperties != nil {
                map["ExtendedProperties"] = self.extendedProperties?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAllDay != nil {
                map["IsAllDay"] = self.isAllDay!
            }
            if self.location != nil {
                map["Location"] = self.location?.toMap()
            }
            if self.meetingRooms != nil {
                var tmp : [Any] = []
                for k in self.meetingRooms! {
                    tmp.append(k.toMap())
                }
                map["MeetingRooms"] = tmp
            }
            if self.onlineMeetingInfo != nil {
                map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
            }
            if self.organizer != nil {
                map["Organizer"] = self.organizer?.toMap()
            }
            if self.originStart != nil {
                map["OriginStart"] = self.originStart?.toMap()
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence?.toMap()
            }
            if self.reminders != nil {
                var tmp : [Any] = []
                for k in self.reminders! {
                    tmp.append(k.toMap())
                }
                map["Reminders"] = tmp
            }
            if self.richTextDescription != nil {
                map["RichTextDescription"] = self.richTextDescription?.toMap()
            }
            if self.seriesMasterId != nil {
                map["SeriesMasterId"] = self.seriesMasterId!
            }
            if self.start != nil {
                map["Start"] = self.start?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attendees") {
                var tmp : [ListEventsResponseBody.Events.Attendees] = []
                for v in dict["Attendees"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Attendees()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attendees = tmp
            }
            if dict.keys.contains("Categories") {
                var tmp : [ListEventsResponseBody.Events.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("End") {
                var model = ListEventsResponseBody.Events.End()
                model.fromMap(dict["End"] as! [String: Any])
                self.end = model
            }
            if dict.keys.contains("ExtendedProperties") {
                var model = ListEventsResponseBody.Events.ExtendedProperties()
                model.fromMap(dict["ExtendedProperties"] as! [String: Any])
                self.extendedProperties = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsAllDay") {
                self.isAllDay = dict["IsAllDay"] as! Bool
            }
            if dict.keys.contains("Location") {
                var model = ListEventsResponseBody.Events.Location()
                model.fromMap(dict["Location"] as! [String: Any])
                self.location = model
            }
            if dict.keys.contains("MeetingRooms") {
                var tmp : [ListEventsResponseBody.Events.MeetingRooms] = []
                for v in dict["MeetingRooms"] as! [Any] {
                    var model = ListEventsResponseBody.Events.MeetingRooms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.meetingRooms = tmp
            }
            if dict.keys.contains("OnlineMeetingInfo") {
                var model = ListEventsResponseBody.Events.OnlineMeetingInfo()
                model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
                self.onlineMeetingInfo = model
            }
            if dict.keys.contains("Organizer") {
                var model = ListEventsResponseBody.Events.Organizer()
                model.fromMap(dict["Organizer"] as! [String: Any])
                self.organizer = model
            }
            if dict.keys.contains("OriginStart") {
                var model = ListEventsResponseBody.Events.OriginStart()
                model.fromMap(dict["OriginStart"] as! [String: Any])
                self.originStart = model
            }
            if dict.keys.contains("Recurrence") {
                var model = ListEventsResponseBody.Events.Recurrence()
                model.fromMap(dict["Recurrence"] as! [String: Any])
                self.recurrence = model
            }
            if dict.keys.contains("Reminders") {
                var tmp : [ListEventsResponseBody.Events.Reminders] = []
                for v in dict["Reminders"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Reminders()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reminders = tmp
            }
            if dict.keys.contains("RichTextDescription") {
                var model = ListEventsResponseBody.Events.RichTextDescription()
                model.fromMap(dict["RichTextDescription"] as! [String: Any])
                self.richTextDescription = model
            }
            if dict.keys.contains("SeriesMasterId") {
                self.seriesMasterId = dict["SeriesMasterId"] as! String
            }
            if dict.keys.contains("Start") {
                var model = ListEventsResponseBody.Events.Start()
                model.fromMap(dict["Start"] as! [String: Any])
                self.start = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var events: [ListEventsResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public var syncToken: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["events"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.syncToken != nil {
            map["syncToken"] = self.syncToken!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("events") {
            var tmp : [ListEventsResponseBody.Events] = []
            for v in dict["events"] as! [Any] {
                var model = ListEventsResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("syncToken") {
            self.syncToken = dict["syncToken"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventsViewHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListEventsViewHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListEventsViewHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListEventsViewShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListEventsViewRequest : Tea.TeaModel {
    public var calendarId: String?

    public var maxAttendees: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var timeMax: String?

    public var timeMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.timeMax != nil {
            map["TimeMax"] = self.timeMax!
        }
        if self.timeMin != nil {
            map["TimeMin"] = self.timeMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("MaxAttendees") {
            self.maxAttendees = dict["MaxAttendees"] as! Int32
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TimeMax") {
            self.timeMax = dict["TimeMax"] as! String
        }
        if dict.keys.contains("TimeMin") {
            self.timeMin = dict["TimeMin"] as! String
        }
    }
}

public class ListEventsViewResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class Attendees : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var isOptional: Bool?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isOptional != nil {
                    map["IsOptional"] = self.isOptional!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IsOptional") {
                    self.isOptional = dict["IsOptional"] as! Bool
                }
                if dict.keys.contains("ResponseStatus") {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class Categories : Tea.TeaModel {
            public var displayName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
            }
        }
        public class End : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public class ExtendedProperties : Tea.TeaModel {
            public class SharedProperties : Tea.TeaModel {
                public var belongCorpId: String?

                public var sourceOpenCid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.belongCorpId != nil {
                        map["BelongCorpId"] = self.belongCorpId!
                    }
                    if self.sourceOpenCid != nil {
                        map["SourceOpenCid"] = self.sourceOpenCid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BelongCorpId") {
                        self.belongCorpId = dict["BelongCorpId"] as! String
                    }
                    if dict.keys.contains("SourceOpenCid") {
                        self.sourceOpenCid = dict["SourceOpenCid"] as! String
                    }
                }
            }
            public var sharedProperties: ListEventsViewResponseBody.Events.ExtendedProperties.SharedProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sharedProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sharedProperties != nil {
                    map["SharedProperties"] = self.sharedProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SharedProperties") {
                    var model = ListEventsViewResponseBody.Events.ExtendedProperties.SharedProperties()
                    model.fromMap(dict["SharedProperties"] as! [String: Any])
                    self.sharedProperties = model
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var displayName: String?

            public var meetingRooms: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.meetingRooms != nil {
                    map["MeetingRooms"] = self.meetingRooms!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("MeetingRooms") {
                    self.meetingRooms = dict["MeetingRooms"] as! [String]
                }
            }
        }
        public class MeetingRooms : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var roomId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.roomId != nil {
                    map["RoomId"] = self.roomId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("RoomId") {
                    self.roomId = dict["RoomId"] as! String
                }
            }
        }
        public class OnlineMeetingInfo : Tea.TeaModel {
            public var conferenceId: String?

            public var extraInfo: [String: Any]?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conferenceId != nil {
                    map["ConferenceId"] = self.conferenceId!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConferenceId") {
                    self.conferenceId = dict["ConferenceId"] as! String
                }
                if dict.keys.contains("ExtraInfo") {
                    self.extraInfo = dict["ExtraInfo"] as! [String: Any]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Organizer : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ResponseStatus") {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class OriginStart : Tea.TeaModel {
            public var dateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
            }
        }
        public class Recurrence : Tea.TeaModel {
            public class Pattern : Tea.TeaModel {
                public var dayOfMonth: Int32?

                public var daysOfWeek: String?

                public var index: String?

                public var interval: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dayOfMonth != nil {
                        map["DayOfMonth"] = self.dayOfMonth!
                    }
                    if self.daysOfWeek != nil {
                        map["DaysOfWeek"] = self.daysOfWeek!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DayOfMonth") {
                        self.dayOfMonth = dict["DayOfMonth"] as! Int32
                    }
                    if dict.keys.contains("DaysOfWeek") {
                        self.daysOfWeek = dict["DaysOfWeek"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Range : Tea.TeaModel {
                public var endDate: String?

                public var numberOfOccurrences: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.numberOfOccurrences != nil {
                        map["NumberOfOccurrences"] = self.numberOfOccurrences!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndDate") {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("NumberOfOccurrences") {
                        self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pattern: ListEventsViewResponseBody.Events.Recurrence.Pattern?

            public var range: ListEventsViewResponseBody.Events.Recurrence.Range?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pattern?.validate()
                try self.range?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pattern != nil {
                    map["Pattern"] = self.pattern?.toMap()
                }
                if self.range != nil {
                    map["Range"] = self.range?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Pattern") {
                    var model = ListEventsViewResponseBody.Events.Recurrence.Pattern()
                    model.fromMap(dict["Pattern"] as! [String: Any])
                    self.pattern = model
                }
                if dict.keys.contains("Range") {
                    var model = ListEventsViewResponseBody.Events.Recurrence.Range()
                    model.fromMap(dict["Range"] as! [String: Any])
                    self.range = model
                }
            }
        }
        public class RichTextDescription : Tea.TeaModel {
            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class Start : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var attendees: [ListEventsViewResponseBody.Events.Attendees]?

        public var categories: [ListEventsViewResponseBody.Events.Categories]?

        public var createTime: String?

        public var description_: String?

        public var end: ListEventsViewResponseBody.Events.End?

        public var extendedProperties: ListEventsViewResponseBody.Events.ExtendedProperties?

        public var id: String?

        public var isAllDay: Bool?

        public var location: ListEventsViewResponseBody.Events.Location?

        public var meetingRooms: [ListEventsViewResponseBody.Events.MeetingRooms]?

        public var onlineMeetingInfo: ListEventsViewResponseBody.Events.OnlineMeetingInfo?

        public var organizer: ListEventsViewResponseBody.Events.Organizer?

        public var originStart: ListEventsViewResponseBody.Events.OriginStart?

        public var recurrence: ListEventsViewResponseBody.Events.Recurrence?

        public var richTextDescription: ListEventsViewResponseBody.Events.RichTextDescription?

        public var seriesMasterId: String?

        public var start: ListEventsViewResponseBody.Events.Start?

        public var status: String?

        public var summary: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.end?.validate()
            try self.extendedProperties?.validate()
            try self.location?.validate()
            try self.onlineMeetingInfo?.validate()
            try self.organizer?.validate()
            try self.originStart?.validate()
            try self.recurrence?.validate()
            try self.richTextDescription?.validate()
            try self.start?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendees != nil {
                var tmp : [Any] = []
                for k in self.attendees! {
                    tmp.append(k.toMap())
                }
                map["Attendees"] = tmp
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.end != nil {
                map["End"] = self.end?.toMap()
            }
            if self.extendedProperties != nil {
                map["ExtendedProperties"] = self.extendedProperties?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAllDay != nil {
                map["IsAllDay"] = self.isAllDay!
            }
            if self.location != nil {
                map["Location"] = self.location?.toMap()
            }
            if self.meetingRooms != nil {
                var tmp : [Any] = []
                for k in self.meetingRooms! {
                    tmp.append(k.toMap())
                }
                map["MeetingRooms"] = tmp
            }
            if self.onlineMeetingInfo != nil {
                map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
            }
            if self.organizer != nil {
                map["Organizer"] = self.organizer?.toMap()
            }
            if self.originStart != nil {
                map["OriginStart"] = self.originStart?.toMap()
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence?.toMap()
            }
            if self.richTextDescription != nil {
                map["RichTextDescription"] = self.richTextDescription?.toMap()
            }
            if self.seriesMasterId != nil {
                map["SeriesMasterId"] = self.seriesMasterId!
            }
            if self.start != nil {
                map["Start"] = self.start?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attendees") {
                var tmp : [ListEventsViewResponseBody.Events.Attendees] = []
                for v in dict["Attendees"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.Attendees()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attendees = tmp
            }
            if dict.keys.contains("Categories") {
                var tmp : [ListEventsViewResponseBody.Events.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("End") {
                var model = ListEventsViewResponseBody.Events.End()
                model.fromMap(dict["End"] as! [String: Any])
                self.end = model
            }
            if dict.keys.contains("ExtendedProperties") {
                var model = ListEventsViewResponseBody.Events.ExtendedProperties()
                model.fromMap(dict["ExtendedProperties"] as! [String: Any])
                self.extendedProperties = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsAllDay") {
                self.isAllDay = dict["IsAllDay"] as! Bool
            }
            if dict.keys.contains("Location") {
                var model = ListEventsViewResponseBody.Events.Location()
                model.fromMap(dict["Location"] as! [String: Any])
                self.location = model
            }
            if dict.keys.contains("MeetingRooms") {
                var tmp : [ListEventsViewResponseBody.Events.MeetingRooms] = []
                for v in dict["MeetingRooms"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.MeetingRooms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.meetingRooms = tmp
            }
            if dict.keys.contains("OnlineMeetingInfo") {
                var model = ListEventsViewResponseBody.Events.OnlineMeetingInfo()
                model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
                self.onlineMeetingInfo = model
            }
            if dict.keys.contains("Organizer") {
                var model = ListEventsViewResponseBody.Events.Organizer()
                model.fromMap(dict["Organizer"] as! [String: Any])
                self.organizer = model
            }
            if dict.keys.contains("OriginStart") {
                var model = ListEventsViewResponseBody.Events.OriginStart()
                model.fromMap(dict["OriginStart"] as! [String: Any])
                self.originStart = model
            }
            if dict.keys.contains("Recurrence") {
                var model = ListEventsViewResponseBody.Events.Recurrence()
                model.fromMap(dict["Recurrence"] as! [String: Any])
                self.recurrence = model
            }
            if dict.keys.contains("RichTextDescription") {
                var model = ListEventsViewResponseBody.Events.RichTextDescription()
                model.fromMap(dict["RichTextDescription"] as! [String: Any])
                self.richTextDescription = model
            }
            if dict.keys.contains("SeriesMasterId") {
                self.seriesMasterId = dict["SeriesMasterId"] as! String
            }
            if dict.keys.contains("Start") {
                var model = ListEventsViewResponseBody.Events.Start()
                model.fromMap(dict["Start"] as! [String: Any])
                self.start = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var events: [ListEventsViewResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["events"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("events") {
            var tmp : [ListEventsViewResponseBody.Events] = []
            for v in dict["events"] as! [Any] {
                var model = ListEventsViewResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListEventsViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventsViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventsViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFormRemarksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListFormRemarksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListFormRemarksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListFormRemarksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListFormRemarksRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ListFormRemarksShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ListFormRemarksResponseBody : Tea.TeaModel {
    public var formRemarkVoMap: [String: Any]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.formRemarkVoMap != nil {
            map["formRemarkVoMap"] = self.formRemarkVoMap!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("formRemarkVoMap") {
            self.formRemarkVoMap = dict["formRemarkVoMap"] as! [String: Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListFormRemarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFormRemarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFormRemarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMessageHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
    }
}

public class ListMessageRequest : Tea.TeaModel {
    public var assistantId: String?

    public var limit: Int32?

    public var order: String?

    public var originalAssistantid: String?

    public var runId: String?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistantId != nil {
            map["assistantId"] = self.assistantId!
        }
        if self.limit != nil {
            map["limit"] = self.limit!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.originalAssistantid != nil {
            map["originalAssistantid"] = self.originalAssistantid!
        }
        if self.runId != nil {
            map["runId"] = self.runId!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assistantId") {
            self.assistantId = dict["assistantId"] as! String
        }
        if dict.keys.contains("limit") {
            self.limit = dict["limit"] as! Int32
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("originalAssistantid") {
            self.originalAssistantid = dict["originalAssistantid"] as! String
        }
        if dict.keys.contains("runId") {
            self.runId = dict["runId"] as! String
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class ListMessageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class CardCallback : Tea.TeaModel {
                public var content: String?

                public var templateId: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.templateId != nil {
                        map["templateId"] = self.templateId!
                    }
                    if self.userId != nil {
                        map["userId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("templateId") {
                        self.templateId = dict["templateId"] as! String
                    }
                    if dict.keys.contains("userId") {
                        self.userId = dict["userId"] as! String
                    }
                }
            }
            public class DingCard : Tea.TeaModel {
                public var cardDesc: String?

                public var content: String?

                public var contentType: String?

                public var finished: Bool?

                public var templateId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cardDesc != nil {
                        map["cardDesc"] = self.cardDesc!
                    }
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.contentType != nil {
                        map["contentType"] = self.contentType!
                    }
                    if self.finished != nil {
                        map["finished"] = self.finished!
                    }
                    if self.templateId != nil {
                        map["templateId"] = self.templateId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cardDesc") {
                        self.cardDesc = dict["cardDesc"] as! String
                    }
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("contentType") {
                        self.contentType = dict["contentType"] as! String
                    }
                    if dict.keys.contains("finished") {
                        self.finished = dict["finished"] as! Bool
                    }
                    if dict.keys.contains("templateId") {
                        self.templateId = dict["templateId"] as! String
                    }
                }
            }
            public class ImageUrl : Tea.TeaModel {
                public var detail: String?

                public var imageDesc: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        map["detail"] = self.detail!
                    }
                    if self.imageDesc != nil {
                        map["imageDesc"] = self.imageDesc!
                    }
                    if self.url != nil {
                        map["url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("detail") {
                        self.detail = dict["detail"] as! String
                    }
                    if dict.keys.contains("imageDesc") {
                        self.imageDesc = dict["imageDesc"] as! String
                    }
                    if dict.keys.contains("url") {
                        self.url = dict["url"] as! String
                    }
                }
            }
            public class Markdown : Tea.TeaModel {
                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public class Text : Tea.TeaModel {
                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var cardCallback: ListMessageResponseBody.Data.Content.CardCallback?

            public var dingCard: ListMessageResponseBody.Data.Content.DingCard?

            public var imageUrl: ListMessageResponseBody.Data.Content.ImageUrl?

            public var markdown: ListMessageResponseBody.Data.Content.Markdown?

            public var text: ListMessageResponseBody.Data.Content.Text?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cardCallback?.validate()
                try self.dingCard?.validate()
                try self.imageUrl?.validate()
                try self.markdown?.validate()
                try self.text?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cardCallback != nil {
                    map["cardCallback"] = self.cardCallback?.toMap()
                }
                if self.dingCard != nil {
                    map["dingCard"] = self.dingCard?.toMap()
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl?.toMap()
                }
                if self.markdown != nil {
                    map["markdown"] = self.markdown?.toMap()
                }
                if self.text != nil {
                    map["text"] = self.text?.toMap()
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cardCallback") {
                    var model = ListMessageResponseBody.Data.Content.CardCallback()
                    model.fromMap(dict["cardCallback"] as! [String: Any])
                    self.cardCallback = model
                }
                if dict.keys.contains("dingCard") {
                    var model = ListMessageResponseBody.Data.Content.DingCard()
                    model.fromMap(dict["dingCard"] as! [String: Any])
                    self.dingCard = model
                }
                if dict.keys.contains("imageUrl") {
                    var model = ListMessageResponseBody.Data.Content.ImageUrl()
                    model.fromMap(dict["imageUrl"] as! [String: Any])
                    self.imageUrl = model
                }
                if dict.keys.contains("markdown") {
                    var model = ListMessageResponseBody.Data.Content.Markdown()
                    model.fromMap(dict["markdown"] as! [String: Any])
                    self.markdown = model
                }
                if dict.keys.contains("text") {
                    var model = ListMessageResponseBody.Data.Content.Text()
                    model.fromMap(dict["text"] as! [String: Any])
                    self.text = model
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var content: [ListMessageResponseBody.Data.Content]?

        public var createAt: Int64?

        public var id: String?

        public var metadata: [String: Any]?

        public var object: String?

        public var role: String?

        public var runId: String?

        public var threadId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["content"] = tmp
            }
            if self.createAt != nil {
                map["createAt"] = self.createAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.metadata != nil {
                map["metadata"] = self.metadata!
            }
            if self.object != nil {
                map["object"] = self.object!
            }
            if self.role != nil {
                map["role"] = self.role!
            }
            if self.runId != nil {
                map["runId"] = self.runId!
            }
            if self.threadId != nil {
                map["threadId"] = self.threadId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                var tmp : [ListMessageResponseBody.Data.Content] = []
                for v in dict["content"] as! [Any] {
                    var model = ListMessageResponseBody.Data.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("createAt") {
                self.createAt = dict["createAt"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("metadata") {
                self.metadata = dict["metadata"] as! [String: Any]
            }
            if dict.keys.contains("object") {
                self.object = dict["object"] as! String
            }
            if dict.keys.contains("role") {
                self.role = dict["role"] as! String
            }
            if dict.keys.contains("runId") {
                self.runId = dict["runId"] as! String
            }
            if dict.keys.contains("threadId") {
                self.threadId = dict["threadId"] as! String
            }
        }
    }
    public var data: [ListMessageResponseBody.Data]?

    public var object: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [ListMessageResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListMessageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("object") {
            self.object = dict["object"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMessageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMultiDimTableRecordsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListMultiDimTableRecordsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListMultiDimTableRecordsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListMultiDimTableRecordsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListMultiDimTableRecordsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var field: String?

            public var operator_: String?

            public var value: [Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.field != nil {
                    map["Field"] = self.field!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Field") {
                    self.field = dict["Field"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! [Any]
                }
            }
        }
        public var combination: String?

        public var conditions: [ListMultiDimTableRecordsRequest.Filter.Conditions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.combination != nil {
                map["Combination"] = self.combination!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Combination") {
                self.combination = dict["Combination"] as! String
            }
            if dict.keys.contains("Conditions") {
                var tmp : [ListMultiDimTableRecordsRequest.Filter.Conditions] = []
                for v in dict["Conditions"] as! [Any] {
                    var model = ListMultiDimTableRecordsRequest.Filter.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var baseId: String?

    public var filter: ListMultiDimTableRecordsRequest.Filter?

    public var maxResults: Int32?

    public var nextToken: String?

    public var sheetIdOrName: String?

    public var tenantContext: ListMultiDimTableRecordsRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filter?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.filter != nil {
            map["Filter"] = self.filter?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("Filter") {
            var model = ListMultiDimTableRecordsRequest.Filter()
            model.fromMap(dict["Filter"] as! [String: Any])
            self.filter = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListMultiDimTableRecordsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListMultiDimTableRecordsShrinkRequest : Tea.TeaModel {
    public var baseId: String?

    public var filterShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var sheetIdOrName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseId != nil {
            map["BaseId"] = self.baseId!
        }
        if self.filterShrink != nil {
            map["Filter"] = self.filterShrink!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.sheetIdOrName != nil {
            map["SheetIdOrName"] = self.sheetIdOrName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseId") {
            self.baseId = dict["BaseId"] as! String
        }
        if dict.keys.contains("Filter") {
            self.filterShrink = dict["Filter"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SheetIdOrName") {
            self.sheetIdOrName = dict["SheetIdOrName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListMultiDimTableRecordsResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public class CreatedBy : Tea.TeaModel {
            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class LastModifiedBy : Tea.TeaModel {
            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createdBy: ListMultiDimTableRecordsResponseBody.Records.CreatedBy?

        public var createdTime: Int64?

        public var fields: [String: Any]?

        public var id: String?

        public var lastModifiedBy: ListMultiDimTableRecordsResponseBody.Records.LastModifiedBy?

        public var lastModifiedTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.createdBy?.validate()
            try self.lastModifiedBy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdBy != nil {
                map["CreatedBy"] = self.createdBy?.toMap()
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.fields != nil {
                map["Fields"] = self.fields!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lastModifiedBy != nil {
                map["LastModifiedBy"] = self.lastModifiedBy?.toMap()
            }
            if self.lastModifiedTime != nil {
                map["LastModifiedTime"] = self.lastModifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedBy") {
                var model = ListMultiDimTableRecordsResponseBody.Records.CreatedBy()
                model.fromMap(dict["CreatedBy"] as! [String: Any])
                self.createdBy = model
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Fields") {
                self.fields = dict["Fields"] as! [String: Any]
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LastModifiedBy") {
                var model = ListMultiDimTableRecordsResponseBody.Records.LastModifiedBy()
                model.fromMap(dict["LastModifiedBy"] as! [String: Any])
                self.lastModifiedBy = model
            }
            if dict.keys.contains("LastModifiedTime") {
                self.lastModifiedTime = dict["LastModifiedTime"] as! Int64
            }
        }
    }
    public var hasMore: Bool?

    public var nextToken: String?

    public var records: [ListMultiDimTableRecordsResponseBody.Records]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["records"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("records") {
            var tmp : [ListMultiDimTableRecordsResponseBody.Records] = []
            for v in dict["records"] as! [Any] {
                var model = ListMultiDimTableRecordsResponseBody.Records()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.records = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListMultiDimTableRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMultiDimTableRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMultiDimTableRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNavigationByFormTypeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListNavigationByFormTypeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListNavigationByFormTypeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListNavigationByFormTypeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListNavigationByFormTypeRequest : Tea.TeaModel {
    public var appType: String?

    public var formType: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formType != nil {
            map["FormType"] = self.formType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormType") {
            self.formType = dict["FormType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ListNavigationByFormTypeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Title : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var formUuid: String?

        public var processCode: String?

        public var title: ListNavigationByFormTypeResponseBody.Result.Title?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.title?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.title != nil {
                map["Title"] = self.title?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("ProcessCode") {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("Title") {
                var model = ListNavigationByFormTypeResponseBody.Result.Title()
                model.fromMap(dict["Title"] as! [String: Any])
                self.title = model
            }
        }
    }
    public var requestId: String?

    public var result: [ListNavigationByFormTypeResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListNavigationByFormTypeResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListNavigationByFormTypeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListNavigationByFormTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNavigationByFormTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNavigationByFormTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListNodesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListNodesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListNodesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var parentNodeId: String?

    public var tenantContext: ListNodesRequest.TenantContext?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentNodeId") {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListNodesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListNodesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var parentNodeId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentNodeId") {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: ListNodesResponseBody.Nodes.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") {
                var model = ListNodesResponseBody.Nodes.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var nodes: [ListNodesResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["nodes"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("nodes") {
            var tmp : [ListNodesResponseBody.Nodes] = []
            for v in dict["nodes"] as! [Any] {
                var model = ListNodesResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var cursor: Int64?

    public var endTime: Int64?

    public var modifiedEndTime: Int64?

    public var modifiedStartTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContext: ListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modifiedEndTime != nil {
            map["ModifiedEndTime"] = self.modifiedEndTime!
        }
        if self.modifiedStartTime != nil {
            map["ModifiedStartTime"] = self.modifiedStartTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedEndTime") {
            self.modifiedEndTime = dict["ModifiedEndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedStartTime") {
            self.modifiedStartTime = dict["ModifiedStartTime"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListReportShrinkRequest : Tea.TeaModel {
    public var cursor: Int64?

    public var endTime: Int64?

    public var modifiedEndTime: Int64?

    public var modifiedStartTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modifiedEndTime != nil {
            map["ModifiedEndTime"] = self.modifiedEndTime!
        }
        if self.modifiedStartTime != nil {
            map["ModifiedStartTime"] = self.modifiedStartTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedEndTime") {
            self.modifiedEndTime = dict["ModifiedEndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedStartTime") {
            self.modifiedStartTime = dict["ModifiedStartTime"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListReportResponseBody : Tea.TeaModel {
    public class DataList : Tea.TeaModel {
        public class Contents : Tea.TeaModel {
            public var key: String?

            public var sort: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.sort != nil {
                    map["Sort"] = self.sort!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Sort") {
                    self.sort = dict["Sort"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var contents: [ListReportResponseBody.DataList.Contents]?

        public var createTime: Int64?

        public var creatorId: String?

        public var creatorName: String?

        public var deptName: String?

        public var images: [String]?

        public var latitude: String?

        public var longitude: String?

        public var modifiedTime: Int64?

        public var remark: String?

        public var reportId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contents != nil {
                var tmp : [Any] = []
                for k in self.contents! {
                    tmp.append(k.toMap())
                }
                map["Contents"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.images != nil {
                map["Images"] = self.images!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contents") {
                var tmp : [ListReportResponseBody.DataList.Contents] = []
                for v in dict["Contents"] as! [Any] {
                    var model = ListReportResponseBody.DataList.Contents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contents = tmp
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DeptName") {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Images") {
                self.images = dict["Images"] as! [String]
            }
            if dict.keys.contains("Latitude") {
                self.latitude = dict["Latitude"] as! String
            }
            if dict.keys.contains("Longitude") {
                self.longitude = dict["Longitude"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! Int64
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ReportId") {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var dataList: [ListReportResponseBody.DataList]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataList != nil {
            var tmp : [Any] = []
            for k in self.dataList! {
                tmp.append(k.toMap())
            }
            map["dataList"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataList") {
            var tmp : [ListReportResponseBody.DataList] = []
            for v in dict["dataList"] as! [Any] {
                var model = ListReportResponseBody.DataList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataList = tmp
        }
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int64
        }
    }
}

public class ListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListTableDataByFormInstanceIdTableIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListTableDataByFormInstanceIdTableIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceId: String?

    public var formUuid: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var systemToken: String?

    public var tableFieldId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.tableFieldId != nil {
            map["TableFieldId"] = self.tableFieldId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceId") {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TableFieldId") {
            self.tableFieldId = dict["TableFieldId"] as! String
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            self.data = dict["data"] as! [String]
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTableDataByFormInstanceIdTableIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTableDataByFormInstanceIdTableIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTeamsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListTeamsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListTeamsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListTeamsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListTeamsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContext: ListTeamsRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListTeamsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListTeamsShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListTeamsResponseBody : Tea.TeaModel {
    public class Teams : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: ListTeamsResponseBody.Teams.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var teamId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                var model = ListTeamsResponseBody.Teams.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var teams: [ListTeamsResponseBody.Teams]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.teams != nil {
            var tmp : [Any] = []
            for k in self.teams! {
                tmp.append(k.toMap())
            }
            map["teams"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("teams") {
            var tmp : [ListTeamsResponseBody.Teams] = []
            for v in dict["teams"] as! [Any] {
                var model = ListTeamsResponseBody.Teams()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.teams = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListTeamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTeamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTeamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTemplateHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListTemplateHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListTemplateHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListTemplateShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListTemplateRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var templateType: String?

    public var tenantContext: ListTemplateRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListTemplateRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListTemplateShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var templateType: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListTemplateResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var coverUrl: String?

        public var createTime: Int64?

        public var docType: String?

        public var id: String?

        public var templateType: String?

        public var title: String?

        public var updateTime: Int64?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverUrl != nil {
                map["CoverUrl"] = self.coverUrl!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.docType != nil {
                map["DocType"] = self.docType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverUrl") {
                self.coverUrl = dict["CoverUrl"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DocType") {
                self.docType = dict["DocType"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var hasMore: Bool?

    public var nextToken: String?

    public var requestId: String?

    public var templateList: [ListTemplateResponseBody.TemplateList]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["templateList"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("templateList") {
            var tmp : [ListTemplateResponseBody.TemplateList] = []
            for v in dict["templateList"] as! [Any] {
                var model = ListTemplateResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTicketOperateRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListTicketOperateRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListTicketOperateRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListTicketOperateRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListTicketOperateRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContext: ListTicketOperateRecordRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListTicketOperateRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListTicketOperateRecordShrinkRequest : Tea.TeaModel {
    public var openTeamId: String?

    public var openTicketId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListTicketOperateRecordResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public class Operator_ : Tea.TeaModel {
            public var nickName: String?

            public var unionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.unionId != nil {
                    map["UnionId"] = self.unionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NickName") {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("UnionId") {
                    self.unionId = dict["UnionId"] as! String
                }
            }
        }
        public class TicketMemo : Tea.TeaModel {
            public class Attachments : Tea.TeaModel {
                public var fileName: String?

                public var key: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FileName") {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                }
            }
            public var attachments: [ListTicketOperateRecordResponseBody.Records.TicketMemo.Attachments]?

            public var memo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attachments != nil {
                    var tmp : [Any] = []
                    for k in self.attachments! {
                        tmp.append(k.toMap())
                    }
                    map["Attachments"] = tmp
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Attachments") {
                    var tmp : [ListTicketOperateRecordResponseBody.Records.TicketMemo.Attachments] = []
                    for v in dict["Attachments"] as! [Any] {
                        var model = ListTicketOperateRecordResponseBody.Records.TicketMemo.Attachments()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.attachments = tmp
                }
                if dict.keys.contains("Memo") {
                    self.memo = dict["Memo"] as! String
                }
            }
        }
        public var openTicketId: String?

        public var operateData: String?

        public var operateTime: String?

        public var operation: String?

        public var operationDisplayName: String?

        public var operator_: ListTicketOperateRecordResponseBody.Records.Operator_?

        public var ticketMemo: ListTicketOperateRecordResponseBody.Records.TicketMemo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.operator_?.validate()
            try self.ticketMemo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.openTicketId != nil {
                map["OpenTicketId"] = self.openTicketId!
            }
            if self.operateData != nil {
                map["OperateData"] = self.operateData!
            }
            if self.operateTime != nil {
                map["OperateTime"] = self.operateTime!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.operationDisplayName != nil {
                map["OperationDisplayName"] = self.operationDisplayName!
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_?.toMap()
            }
            if self.ticketMemo != nil {
                map["TicketMemo"] = self.ticketMemo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OpenTicketId") {
                self.openTicketId = dict["OpenTicketId"] as! String
            }
            if dict.keys.contains("OperateData") {
                self.operateData = dict["OperateData"] as! String
            }
            if dict.keys.contains("OperateTime") {
                self.operateTime = dict["OperateTime"] as! String
            }
            if dict.keys.contains("Operation") {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("OperationDisplayName") {
                self.operationDisplayName = dict["OperationDisplayName"] as! String
            }
            if dict.keys.contains("Operator") {
                var model = ListTicketOperateRecordResponseBody.Records.Operator_()
                model.fromMap(dict["Operator"] as! [String: Any])
                self.operator_ = model
            }
            if dict.keys.contains("TicketMemo") {
                var model = ListTicketOperateRecordResponseBody.Records.TicketMemo()
                model.fromMap(dict["TicketMemo"] as! [String: Any])
                self.ticketMemo = model
            }
        }
    }
    public var records: [ListTicketOperateRecordResponseBody.Records]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["records"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("records") {
            var tmp : [ListTicketOperateRecordResponseBody.Records] = []
            for v in dict["records"] as! [Any] {
                var model = ListTicketOperateRecordResponseBody.Records()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.records = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListTicketOperateRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTicketOperateRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTicketOperateRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ListWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListWorkspacesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var teamId: String?

    public var tenantContext: ListWorkspacesRequest.TenantContext?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.teamId != nil {
            map["TeamId"] = self.teamId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("TeamId") {
            self.teamId = dict["TeamId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = ListWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListWorkspacesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var teamId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.teamId != nil {
            map["TeamId"] = self.teamId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("TeamId") {
            self.teamId = dict["TeamId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListWorkspacesResponseBody : Tea.TeaModel {
    public class Workspaces : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: ListWorkspacesResponseBody.Workspaces.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") {
                var model = ListWorkspacesResponseBody.Workspaces.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var workspaces: [ListWorkspacesResponseBody.Workspaces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspaces != nil {
            var tmp : [Any] = []
            for k in self.workspaces! {
                tmp.append(k.toMap())
            }
            map["workspaces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspaces") {
            var tmp : [ListWorkspacesResponseBody.Workspaces] = []
            for v in dict["workspaces"] as! [Any] {
                var model = ListWorkspacesResponseBody.Workspaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspaces = tmp
        }
    }
}

public class ListWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PatchEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: PatchEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = PatchEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class PatchEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class PatchEventRequest : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public class CardInstances : Tea.TeaModel {
        public var outTrackId: String?

        public var scenario: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.outTrackId != nil {
                map["OutTrackId"] = self.outTrackId!
            }
            if self.scenario != nil {
                map["Scenario"] = self.scenario!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OutTrackId") {
                self.outTrackId = dict["OutTrackId"] as! String
            }
            if dict.keys.contains("Scenario") {
                self.scenario = dict["Scenario"] as! String
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayName") {
                self.displayName = dict["displayName"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["dayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["daysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.interval != nil {
                    map["interval"] = self.interval!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dayOfMonth") {
                    self.dayOfMonth = dict["dayOfMonth"] as! Int32
                }
                if dict.keys.contains("daysOfWeek") {
                    self.daysOfWeek = dict["daysOfWeek"] as! String
                }
                if dict.keys.contains("index") {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("interval") {
                    self.interval = dict["interval"] as! Int32
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["endDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["numberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("endDate") {
                    self.endDate = dict["endDate"] as! String
                }
                if dict.keys.contains("numberOfOccurrences") {
                    self.numberOfOccurrences = dict["numberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var pattern: PatchEventRequest.Recurrence.Pattern?

        public var range: PatchEventRequest.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("pattern") {
                var model = PatchEventRequest.Recurrence.Pattern()
                model.fromMap(dict["pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("range") {
                var model = PatchEventRequest.Recurrence.Range()
                model.fromMap(dict["range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["method"] = self.method!
            }
            if self.minutes != nil {
                map["minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("method") {
                self.method = dict["method"] as! String
            }
            if dict.keys.contains("minutes") {
                self.minutes = dict["minutes"] as! Int32
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public var attendees: [PatchEventRequest.Attendees]?

    public var calendarId: String?

    public var cardInstances: [PatchEventRequest.CardInstances]?

    public var description_: String?

    public var end: PatchEventRequest.End?

    public var eventId: String?

    public var extra: [String: String]?

    public var isAllDay: Bool?

    public var location: PatchEventRequest.Location?

    public var recurrence: PatchEventRequest.Recurrence?

    public var reminders: [PatchEventRequest.Reminders]?

    public var start: PatchEventRequest.Start?

    public var summary: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["Attendees"] = tmp
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.cardInstances != nil {
            var tmp : [Any] = []
            for k in self.cardInstances! {
                tmp.append(k.toMap())
            }
            map["CardInstances"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.end != nil {
            map["End"] = self.end?.toMap()
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.extra != nil {
            map["Extra"] = self.extra!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["Location"] = self.location?.toMap()
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["Reminders"] = tmp
        }
        if self.start != nil {
            map["Start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") {
            var tmp : [PatchEventRequest.Attendees] = []
            for v in dict["Attendees"] as! [Any] {
                var model = PatchEventRequest.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("CardInstances") {
            var tmp : [PatchEventRequest.CardInstances] = []
            for v in dict["CardInstances"] as! [Any] {
                var model = PatchEventRequest.CardInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cardInstances = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") {
            var model = PatchEventRequest.End()
            model.fromMap(dict["End"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("Extra") {
            self.extra = dict["Extra"] as! [String: String]
        }
        if dict.keys.contains("IsAllDay") {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") {
            var model = PatchEventRequest.Location()
            model.fromMap(dict["Location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("Recurrence") {
            var model = PatchEventRequest.Recurrence()
            model.fromMap(dict["Recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("Reminders") {
            var tmp : [PatchEventRequest.Reminders] = []
            for v in dict["Reminders"] as! [Any] {
                var model = PatchEventRequest.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("Start") {
            var model = PatchEventRequest.Start()
            model.fromMap(dict["Start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("Summary") {
            self.summary = dict["Summary"] as! String
        }
    }
}

public class PatchEventShrinkRequest : Tea.TeaModel {
    public var attendeesShrink: String?

    public var calendarId: String?

    public var cardInstancesShrink: String?

    public var description_: String?

    public var endShrink: String?

    public var eventId: String?

    public var extraShrink: String?

    public var isAllDay: Bool?

    public var locationShrink: String?

    public var recurrenceShrink: String?

    public var remindersShrink: String?

    public var startShrink: String?

    public var summary: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesShrink != nil {
            map["Attendees"] = self.attendeesShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.cardInstancesShrink != nil {
            map["CardInstances"] = self.cardInstancesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endShrink != nil {
            map["End"] = self.endShrink!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.extraShrink != nil {
            map["Extra"] = self.extraShrink!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.locationShrink != nil {
            map["Location"] = self.locationShrink!
        }
        if self.recurrenceShrink != nil {
            map["Recurrence"] = self.recurrenceShrink!
        }
        if self.remindersShrink != nil {
            map["Reminders"] = self.remindersShrink!
        }
        if self.startShrink != nil {
            map["Start"] = self.startShrink!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") {
            self.attendeesShrink = dict["Attendees"] as! String
        }
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("CardInstances") {
            self.cardInstancesShrink = dict["CardInstances"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") {
            self.endShrink = dict["End"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("Extra") {
            self.extraShrink = dict["Extra"] as! String
        }
        if dict.keys.contains("IsAllDay") {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") {
            self.locationShrink = dict["Location"] as! String
        }
        if dict.keys.contains("Recurrence") {
            self.recurrenceShrink = dict["Recurrence"] as! String
        }
        if dict.keys.contains("Reminders") {
            self.remindersShrink = dict["Reminders"] as! String
        }
        if dict.keys.contains("Start") {
            self.startShrink = dict["Start"] as! String
        }
        if dict.keys.contains("Summary") {
            self.summary = dict["Summary"] as! String
        }
    }
}

public class PatchEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsOptional") {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public var meetingRooms: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.meetingRooms != nil {
                map["MeetingRooms"] = self.meetingRooms!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MeetingRooms") {
                self.meetingRooms = dict["MeetingRooms"] as! [String]
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: PatchEventResponseBody.Recurrence.Pattern?

        public var range: PatchEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") {
                var model = PatchEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") {
                var model = PatchEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var attendees: [PatchEventResponseBody.Attendees]?

    public var createTime: String?

    public var description_: String?

    public var end: PatchEventResponseBody.End?

    public var id: String?

    public var isAllDay: Bool?

    public var location: PatchEventResponseBody.Location?

    public var organizer: PatchEventResponseBody.Organizer?

    public var recurrence: PatchEventResponseBody.Recurrence?

    public var reminders: [PatchEventResponseBody.Reminders]?

    public var requestId: String?

    public var start: PatchEventResponseBody.Start?

    public var summary: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.organizer?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") {
            var tmp : [PatchEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = PatchEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") {
            var model = PatchEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") {
            var model = PatchEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("organizer") {
            var model = PatchEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("recurrence") {
            var model = PatchEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") {
            var tmp : [PatchEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = PatchEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("start") {
            var model = PatchEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("summary") {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("updateTime") {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class PatchEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PatchEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PatchEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordTextHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordTextHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryCloudRecordTextHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordTextShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordTextRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: Int64?

    public var startTime: Int64?

    public var tenantContext: QueryCloudRecordTextRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryCloudRecordTextRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordTextShrinkRequest : Tea.TeaModel {
    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordTextResponseBody : Tea.TeaModel {
    public class ParagraphList : Tea.TeaModel {
        public class SentenceList : Tea.TeaModel {
            public class WordList : Tea.TeaModel {
                public var endTime: Int64?

                public var startTime: Int64?

                public var word: String?

                public var wordId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.word != nil {
                        map["Word"] = self.word!
                    }
                    if self.wordId != nil {
                        map["WordId"] = self.wordId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Word") {
                        self.word = dict["Word"] as! String
                    }
                    if dict.keys.contains("WordId") {
                        self.wordId = dict["WordId"] as! String
                    }
                }
            }
            public var endTime: Int64?

            public var sentence: String?

            public var startTime: Int64?

            public var userId: String?

            public var wordList: [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.sentence != nil {
                    map["Sentence"] = self.sentence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.wordList != nil {
                    var tmp : [Any] = []
                    for k in self.wordList! {
                        tmp.append(k.toMap())
                    }
                    map["WordList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Sentence") {
                    self.sentence = dict["Sentence"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WordList") {
                    var tmp : [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList] = []
                    for v in dict["WordList"] as! [Any] {
                        var model = QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wordList = tmp
                }
            }
        }
        public var endTime: Int64?

        public var nextTtoken: Int64?

        public var nickName: String?

        public var paragraph: String?

        public var recordId: Int64?

        public var sentenceList: [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList]?

        public var startTime: Int64?

        public var status: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.nextTtoken != nil {
                map["NextTtoken"] = self.nextTtoken!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.paragraph != nil {
                map["Paragraph"] = self.paragraph!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.sentenceList != nil {
                var tmp : [Any] = []
                for k in self.sentenceList! {
                    tmp.append(k.toMap())
                }
                map["SentenceList"] = tmp
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("NextTtoken") {
                self.nextTtoken = dict["NextTtoken"] as! Int64
            }
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("Paragraph") {
                self.paragraph = dict["Paragraph"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! Int64
            }
            if dict.keys.contains("SentenceList") {
                var tmp : [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList] = []
                for v in dict["SentenceList"] as! [Any] {
                    var model = QueryCloudRecordTextResponseBody.ParagraphList.SentenceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sentenceList = tmp
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var hasMore: Bool?

    public var paragraphList: [QueryCloudRecordTextResponseBody.ParagraphList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.paragraphList != nil {
            var tmp : [Any] = []
            for k in self.paragraphList! {
                tmp.append(k.toMap())
            }
            map["paragraphList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("paragraphList") {
            var tmp : [QueryCloudRecordTextResponseBody.ParagraphList] = []
            for v in dict["paragraphList"] as! [Any] {
                var model = QueryCloudRecordTextResponseBody.ParagraphList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paragraphList = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryCloudRecordTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCloudRecordTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordVideoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordVideoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryCloudRecordVideoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordVideoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryCloudRecordVideoRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryCloudRecordVideoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordVideoShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordVideoResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public var duration: Int64?

        public var endTime: Int64?

        public var fileSize: Int64?

        public var mediaId: String?

        public var recordId: String?

        public var recordType: Int64?

        public var regionId: String?

        public var startTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordType != nil {
                map["RecordType"] = self.recordType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordType") {
                self.recordType = dict["RecordType"] as! Int64
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var videoList: [QueryCloudRecordVideoResponseBody.VideoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.videoList != nil {
            var tmp : [Any] = []
            for k in self.videoList! {
                tmp.append(k.toMap())
            }
            map["videoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("videoList") {
            var tmp : [QueryCloudRecordVideoResponseBody.VideoList] = []
            for v in dict["videoList"] as! [Any] {
                var model = QueryCloudRecordVideoResponseBody.VideoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoList = tmp
        }
    }
}

public class QueryCloudRecordVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCloudRecordVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordVideoPlayInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryCloudRecordVideoPlayInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoPlayInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var conferenceId: String?

    public var mediaId: String?

    public var regionId: String?

    public var tenantContext: QueryCloudRecordVideoPlayInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConferenceId") {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryCloudRecordVideoPlayInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoShrinkRequest : Tea.TeaModel {
    public var conferenceId: String?

    public var mediaId: String?

    public var regionId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConferenceId") {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoPlayInfoResponseBody : Tea.TeaModel {
    public var duration: Int64?

    public var fileSize: Int64?

    public var mp4FileUrl: String?

    public var playUrl: String?

    public var requestId: String?

    public var status: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.fileSize != nil {
            map["fileSize"] = self.fileSize!
        }
        if self.mp4FileUrl != nil {
            map["mp4FileUrl"] = self.mp4FileUrl!
        }
        if self.playUrl != nil {
            map["playUrl"] = self.playUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("duration") {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("fileSize") {
            self.fileSize = dict["fileSize"] as! Int64
        }
        if dict.keys.contains("mp4FileUrl") {
            self.mp4FileUrl = dict["mp4FileUrl"] as! String
        }
        if dict.keys.contains("playUrl") {
            self.playUrl = dict["playUrl"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! Int64
        }
    }
}

public class QueryCloudRecordVideoPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordVideoPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCloudRecordVideoPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryConferenceInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceInfoRequest : Tea.TeaModel {
    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceInfoResponseBody : Tea.TeaModel {
    public class ConfInfo : Tea.TeaModel {
        public var activeNum: Int32?

        public var attendNum: Int32?

        public var confDuration: Int64?

        public var conferenceId: String?

        public var creatorId: String?

        public var creatorNick: String?

        public var endTime: Int64?

        public var externalLinkUrl: String?

        public var invitedNum: Int32?

        public var roomCode: String?

        public var startTime: Int64?

        public var status: Int32?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeNum != nil {
                map["ActiveNum"] = self.activeNum!
            }
            if self.attendNum != nil {
                map["AttendNum"] = self.attendNum!
            }
            if self.confDuration != nil {
                map["ConfDuration"] = self.confDuration!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorNick != nil {
                map["CreatorNick"] = self.creatorNick!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.externalLinkUrl != nil {
                map["ExternalLinkUrl"] = self.externalLinkUrl!
            }
            if self.invitedNum != nil {
                map["InvitedNum"] = self.invitedNum!
            }
            if self.roomCode != nil {
                map["RoomCode"] = self.roomCode!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveNum") {
                self.activeNum = dict["ActiveNum"] as! Int32
            }
            if dict.keys.contains("AttendNum") {
                self.attendNum = dict["AttendNum"] as! Int32
            }
            if dict.keys.contains("ConfDuration") {
                self.confDuration = dict["ConfDuration"] as! Int64
            }
            if dict.keys.contains("ConferenceId") {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorNick") {
                self.creatorNick = dict["CreatorNick"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExternalLinkUrl") {
                self.externalLinkUrl = dict["ExternalLinkUrl"] as! String
            }
            if dict.keys.contains("InvitedNum") {
                self.invitedNum = dict["InvitedNum"] as! Int32
            }
            if dict.keys.contains("RoomCode") {
                self.roomCode = dict["RoomCode"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var confInfo: QueryConferenceInfoResponseBody.ConfInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.confInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confInfo != nil {
            map["confInfo"] = self.confInfo?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("confInfo") {
            var model = QueryConferenceInfoResponseBody.ConfInfo()
            model.fromMap(dict["confInfo"] as! [String: Any])
            self.confInfo = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryConferenceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryConferenceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceInfoByRoomCodeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceInfoByRoomCodeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryConferenceInfoByRoomCodeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceInfoByRoomCodeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceInfoByRoomCodeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryConferenceInfoByRoomCodeRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var roomCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryConferenceInfoByRoomCodeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("roomCode") {
            self.roomCode = dict["roomCode"] as! String
        }
    }
}

public class QueryConferenceInfoByRoomCodeShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var roomCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("roomCode") {
            self.roomCode = dict["roomCode"] as! String
        }
    }
}

public class QueryConferenceInfoByRoomCodeResponseBody : Tea.TeaModel {
    public class ConferenceList : Tea.TeaModel {
        public var bizType: String?

        public var confDuration: Int64?

        public var conferenceId: String?

        public var creatorId: String?

        public var creatorNick: String?

        public var endTime: Int64?

        public var externalLinkUrl: String?

        public var roomCode: String?

        public var scheduleConferenceId: String?

        public var startTime: Int64?

        public var status: Int32?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.confDuration != nil {
                map["ConfDuration"] = self.confDuration!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorNick != nil {
                map["CreatorNick"] = self.creatorNick!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.externalLinkUrl != nil {
                map["ExternalLinkUrl"] = self.externalLinkUrl!
            }
            if self.roomCode != nil {
                map["RoomCode"] = self.roomCode!
            }
            if self.scheduleConferenceId != nil {
                map["ScheduleConferenceId"] = self.scheduleConferenceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizType") {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("ConfDuration") {
                self.confDuration = dict["ConfDuration"] as! Int64
            }
            if dict.keys.contains("ConferenceId") {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorNick") {
                self.creatorNick = dict["CreatorNick"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExternalLinkUrl") {
                self.externalLinkUrl = dict["ExternalLinkUrl"] as! String
            }
            if dict.keys.contains("RoomCode") {
                self.roomCode = dict["RoomCode"] as! String
            }
            if dict.keys.contains("ScheduleConferenceId") {
                self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var conferenceList: [QueryConferenceInfoByRoomCodeResponseBody.ConferenceList]?

    public var dingtalkRequestId: String?

    public var hasMore: Bool?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceList != nil {
            var tmp : [Any] = []
            for k in self.conferenceList! {
                tmp.append(k.toMap())
            }
            map["conferenceList"] = tmp
        }
        if self.dingtalkRequestId != nil {
            map["dingtalkRequestId"] = self.dingtalkRequestId!
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceList") {
            var tmp : [QueryConferenceInfoByRoomCodeResponseBody.ConferenceList] = []
            for v in dict["conferenceList"] as! [Any] {
                var model = QueryConferenceInfoByRoomCodeResponseBody.ConferenceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.conferenceList = tmp
        }
        if dict.keys.contains("dingtalkRequestId") {
            self.dingtalkRequestId = dict["dingtalkRequestId"] as! String
        }
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryConferenceInfoByRoomCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceInfoByRoomCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryConferenceInfoByRoomCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryConferenceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceMembersRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContext: QueryConferenceMembersRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryConferenceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceMembersShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceMembersResponseBody : Tea.TeaModel {
    public class MemberModels : Tea.TeaModel {
        public var attendStatus: Int32?

        public var coHost: Bool?

        public var conferenceId: String?

        public var duration: Int64?

        public var host: Bool?

        public var joinTime: Int64?

        public var leaveTime: Int64?

        public var outerOrgMember: Bool?

        public var pstnJoin: Bool?

        public var userId: String?

        public var userNick: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendStatus != nil {
                map["AttendStatus"] = self.attendStatus!
            }
            if self.coHost != nil {
                map["CoHost"] = self.coHost!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.joinTime != nil {
                map["JoinTime"] = self.joinTime!
            }
            if self.leaveTime != nil {
                map["LeaveTime"] = self.leaveTime!
            }
            if self.outerOrgMember != nil {
                map["OuterOrgMember"] = self.outerOrgMember!
            }
            if self.pstnJoin != nil {
                map["PstnJoin"] = self.pstnJoin!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userNick != nil {
                map["UserNick"] = self.userNick!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttendStatus") {
                self.attendStatus = dict["AttendStatus"] as! Int32
            }
            if dict.keys.contains("CoHost") {
                self.coHost = dict["CoHost"] as! Bool
            }
            if dict.keys.contains("ConferenceId") {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! Bool
            }
            if dict.keys.contains("JoinTime") {
                self.joinTime = dict["JoinTime"] as! Int64
            }
            if dict.keys.contains("LeaveTime") {
                self.leaveTime = dict["LeaveTime"] as! Int64
            }
            if dict.keys.contains("OuterOrgMember") {
                self.outerOrgMember = dict["OuterOrgMember"] as! Bool
            }
            if dict.keys.contains("PstnJoin") {
                self.pstnJoin = dict["PstnJoin"] as! Bool
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserNick") {
                self.userNick = dict["UserNick"] as! String
            }
        }
    }
    public var memberModels: [QueryConferenceMembersResponseBody.MemberModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberModels != nil {
            var tmp : [Any] = []
            for k in self.memberModels! {
                tmp.append(k.toMap())
            }
            map["memberModels"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("memberModels") {
            var tmp : [QueryConferenceMembersResponseBody.MemberModels] = []
            for v in dict["memberModels"] as! [Any] {
                var model = QueryConferenceMembersResponseBody.MemberModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.memberModels = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class QueryConferenceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryConferenceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDentryHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryDentryHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryDentryHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryDentryShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryDentryRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var includeSpace: Bool?

    public var spaceId: String?

    public var tenantContext: QueryDentryRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.includeSpace != nil {
            map["IncludeSpace"] = self.includeSpace!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("IncludeSpace") {
            self.includeSpace = dict["IncludeSpace"] as! Bool
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryDentryRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryDentryShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var includeSpace: Bool?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.includeSpace != nil {
            map["IncludeSpace"] = self.includeSpace!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("IncludeSpace") {
            self.includeSpace = dict["IncludeSpace"] as! Bool
        }
        if dict.keys.contains("SpaceId") {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryDentryResponseBody : Tea.TeaModel {
    public class Creator : Tea.TeaModel {
        public var name: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class LinkSourceInfo : Tea.TeaModel {
        public class IconUrl : Tea.TeaModel {
            public var line: String?

            public var small: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.small != nil {
                    map["Small"] = self.small!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Line") {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Small") {
                    self.small = dict["Small"] as! String
                }
            }
        }
        public var extension_: String?

        public var iconUrl: QueryDentryResponseBody.LinkSourceInfo.IconUrl?

        public var id: String?

        public var linkType: Int64?

        public var spaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.iconUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.linkType != nil {
                map["LinkType"] = self.linkType!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("IconUrl") {
                var model = QueryDentryResponseBody.LinkSourceInfo.IconUrl()
                model.fromMap(dict["IconUrl"] as! [String: Any])
                self.iconUrl = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LinkType") {
                self.linkType = dict["LinkType"] as! Int64
            }
            if dict.keys.contains("SpaceId") {
                self.spaceId = dict["SpaceId"] as! String
            }
        }
    }
    public class Space : Tea.TeaModel {
        public class HdIconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class IconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Owner : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class RecentList : Tea.TeaModel {
            public class Creator : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class LinkSourceInfo : Tea.TeaModel {
                public class IconUrl : Tea.TeaModel {
                    public var line: String?

                    public var small: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.small != nil {
                            map["Small"] = self.small!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Line") {
                            self.line = dict["Line"] as! String
                        }
                        if dict.keys.contains("Small") {
                            self.small = dict["Small"] as! String
                        }
                    }
                }
                public var extension_: String?

                public var iconUrl: QueryDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl?

                public var id: String?

                public var linkType: Int64?

                public var spaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.iconUrl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.iconUrl != nil {
                        map["IconUrl"] = self.iconUrl?.toMap()
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.linkType != nil {
                        map["LinkType"] = self.linkType!
                    }
                    if self.spaceId != nil {
                        map["SpaceId"] = self.spaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("IconUrl") {
                        var model = QueryDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl()
                        model.fromMap(dict["IconUrl"] as! [String: Any])
                        self.iconUrl = model
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("LinkType") {
                        self.linkType = dict["LinkType"] as! Int64
                    }
                    if dict.keys.contains("SpaceId") {
                        self.spaceId = dict["SpaceId"] as! String
                    }
                }
            }
            public class StatisticalInfo : Tea.TeaModel {
                public var wordCount: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.wordCount != nil {
                        map["WordCount"] = self.wordCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WordCount") {
                        self.wordCount = dict["WordCount"] as! Int64
                    }
                }
            }
            public class Updater : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var contentType: String?

            public var createdTime: Int64?

            public var creator: QueryDentryResponseBody.Space.RecentList.Creator?

            public var dentryId: String?

            public var dentryType: String?

            public var dentryUuid: String?

            public var docKey: String?

            public var extension_: String?

            public var hasChildren: Bool?

            public var linkSourceInfo: QueryDentryResponseBody.Space.RecentList.LinkSourceInfo?

            public var name: String?

            public var path: String?

            public var space: Any?

            public var spaceId: String?

            public var statisticalInfo: QueryDentryResponseBody.Space.RecentList.StatisticalInfo?

            public var updatedTime: Int64?

            public var updater: QueryDentryResponseBody.Space.RecentList.Updater?

            public var url: String?

            public var visitorInfo: QueryDentryResponseBody.Space.RecentList.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.creator?.validate()
                try self.linkSourceInfo?.validate()
                try self.statisticalInfo?.validate()
                try self.updater?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator?.toMap()
                }
                if self.dentryId != nil {
                    map["DentryId"] = self.dentryId!
                }
                if self.dentryType != nil {
                    map["DentryType"] = self.dentryType!
                }
                if self.dentryUuid != nil {
                    map["DentryUuid"] = self.dentryUuid!
                }
                if self.docKey != nil {
                    map["DocKey"] = self.docKey!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.hasChildren != nil {
                    map["HasChildren"] = self.hasChildren!
                }
                if self.linkSourceInfo != nil {
                    map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.space != nil {
                    map["Space"] = self.space!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                if self.statisticalInfo != nil {
                    map["StatisticalInfo"] = self.statisticalInfo?.toMap()
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.updater != nil {
                    map["Updater"] = self.updater?.toMap()
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentType") {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    var model = QueryDentryResponseBody.Space.RecentList.Creator()
                    model.fromMap(dict["Creator"] as! [String: Any])
                    self.creator = model
                }
                if dict.keys.contains("DentryId") {
                    self.dentryId = dict["DentryId"] as! String
                }
                if dict.keys.contains("DentryType") {
                    self.dentryType = dict["DentryType"] as! String
                }
                if dict.keys.contains("DentryUuid") {
                    self.dentryUuid = dict["DentryUuid"] as! String
                }
                if dict.keys.contains("DocKey") {
                    self.docKey = dict["DocKey"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("HasChildren") {
                    self.hasChildren = dict["HasChildren"] as! Bool
                }
                if dict.keys.contains("LinkSourceInfo") {
                    var model = QueryDentryResponseBody.Space.RecentList.LinkSourceInfo()
                    model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                    self.linkSourceInfo = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Space") {
                    self.space = dict["Space"] as! Any
                }
                if dict.keys.contains("SpaceId") {
                    self.spaceId = dict["SpaceId"] as! String
                }
                if dict.keys.contains("StatisticalInfo") {
                    var model = QueryDentryResponseBody.Space.RecentList.StatisticalInfo()
                    model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                    self.statisticalInfo = model
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
                if dict.keys.contains("Updater") {
                    var model = QueryDentryResponseBody.Space.RecentList.Updater()
                    model.fromMap(dict["Updater"] as! [String: Any])
                    self.updater = model
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") {
                    var model = QueryDentryResponseBody.Space.RecentList.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var cover: String?

        public var description_: String?

        public var hdIconVO: QueryDentryResponseBody.Space.HdIconVO?

        public var iconVO: QueryDentryResponseBody.Space.IconVO?

        public var id: String?

        public var name: String?

        public var owner: QueryDentryResponseBody.Space.Owner?

        public var recentList: [QueryDentryResponseBody.Space.RecentList]?

        public var type: Int32?

        public var url: String?

        public var visitorInfo: QueryDentryResponseBody.Space.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.hdIconVO?.validate()
            try self.iconVO?.validate()
            try self.owner?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hdIconVO != nil {
                map["HdIconVO"] = self.hdIconVO?.toMap()
            }
            if self.iconVO != nil {
                map["IconVO"] = self.iconVO?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner?.toMap()
            }
            if self.recentList != nil {
                var tmp : [Any] = []
                for k in self.recentList! {
                    tmp.append(k.toMap())
                }
                map["RecentList"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cover") {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("HdIconVO") {
                var model = QueryDentryResponseBody.Space.HdIconVO()
                model.fromMap(dict["HdIconVO"] as! [String: Any])
                self.hdIconVO = model
            }
            if dict.keys.contains("IconVO") {
                var model = QueryDentryResponseBody.Space.IconVO()
                model.fromMap(dict["IconVO"] as! [String: Any])
                self.iconVO = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                var model = QueryDentryResponseBody.Space.Owner()
                model.fromMap(dict["Owner"] as! [String: Any])
                self.owner = model
            }
            if dict.keys.contains("RecentList") {
                var tmp : [QueryDentryResponseBody.Space.RecentList] = []
                for v in dict["RecentList"] as! [Any] {
                    var model = QueryDentryResponseBody.Space.RecentList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recentList = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") {
                var model = QueryDentryResponseBody.Space.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public class Updater : Tea.TeaModel {
        public var name: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class VisitorInfo : Tea.TeaModel {
        public var dentryActions: [String]?

        public var roleCode: String?

        public var spaceActions: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dentryActions != nil {
                map["DentryActions"] = self.dentryActions!
            }
            if self.roleCode != nil {
                map["RoleCode"] = self.roleCode!
            }
            if self.spaceActions != nil {
                map["SpaceActions"] = self.spaceActions!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DentryActions") {
                self.dentryActions = dict["DentryActions"] as! [String]
            }
            if dict.keys.contains("RoleCode") {
                self.roleCode = dict["RoleCode"] as! String
            }
            if dict.keys.contains("SpaceActions") {
                self.spaceActions = dict["SpaceActions"] as! [String]
            }
        }
    }
    public var contentType: String?

    public var createdTime: Int64?

    public var creator: QueryDentryResponseBody.Creator?

    public var dentryId: String?

    public var dentryType: String?

    public var dentryUuid: String?

    public var docKey: String?

    public var extension_: String?

    public var hasChildren: Bool?

    public var linkSourceInfo: QueryDentryResponseBody.LinkSourceInfo?

    public var name: String?

    public var path: String?

    public var requestId: String?

    public var space: QueryDentryResponseBody.Space?

    public var spaceId: String?

    public var updatedTime: Int64?

    public var updater: QueryDentryResponseBody.Updater?

    public var url: String?

    public var visitorInfo: QueryDentryResponseBody.VisitorInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.creator?.validate()
        try self.linkSourceInfo?.validate()
        try self.space?.validate()
        try self.updater?.validate()
        try self.visitorInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentType != nil {
            map["contentType"] = self.contentType!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creator != nil {
            map["creator"] = self.creator?.toMap()
        }
        if self.dentryId != nil {
            map["dentryId"] = self.dentryId!
        }
        if self.dentryType != nil {
            map["dentryType"] = self.dentryType!
        }
        if self.dentryUuid != nil {
            map["dentryUuid"] = self.dentryUuid!
        }
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hasChildren != nil {
            map["hasChildren"] = self.hasChildren!
        }
        if self.linkSourceInfo != nil {
            map["linkSourceInfo"] = self.linkSourceInfo?.toMap()
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.space != nil {
            map["space"] = self.space?.toMap()
        }
        if self.spaceId != nil {
            map["spaceId"] = self.spaceId!
        }
        if self.updatedTime != nil {
            map["updatedTime"] = self.updatedTime!
        }
        if self.updater != nil {
            map["updater"] = self.updater?.toMap()
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.visitorInfo != nil {
            map["visitorInfo"] = self.visitorInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("contentType") {
            self.contentType = dict["contentType"] as! String
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creator") {
            var model = QueryDentryResponseBody.Creator()
            model.fromMap(dict["creator"] as! [String: Any])
            self.creator = model
        }
        if dict.keys.contains("dentryId") {
            self.dentryId = dict["dentryId"] as! String
        }
        if dict.keys.contains("dentryType") {
            self.dentryType = dict["dentryType"] as! String
        }
        if dict.keys.contains("dentryUuid") {
            self.dentryUuid = dict["dentryUuid"] as! String
        }
        if dict.keys.contains("docKey") {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("extension") {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hasChildren") {
            self.hasChildren = dict["hasChildren"] as! Bool
        }
        if dict.keys.contains("linkSourceInfo") {
            var model = QueryDentryResponseBody.LinkSourceInfo()
            model.fromMap(dict["linkSourceInfo"] as! [String: Any])
            self.linkSourceInfo = model
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("space") {
            var model = QueryDentryResponseBody.Space()
            model.fromMap(dict["space"] as! [String: Any])
            self.space = model
        }
        if dict.keys.contains("spaceId") {
            self.spaceId = dict["spaceId"] as! String
        }
        if dict.keys.contains("updatedTime") {
            self.updatedTime = dict["updatedTime"] as! Int64
        }
        if dict.keys.contains("updater") {
            var model = QueryDentryResponseBody.Updater()
            model.fromMap(dict["updater"] as! [String: Any])
            self.updater = model
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("visitorInfo") {
            var model = QueryDentryResponseBody.VisitorInfo()
            model.fromMap(dict["visitorInfo"] as! [String: Any])
            self.visitorInfo = model
        }
    }
}

public class QueryDentryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDentryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryDentryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGroupLiveInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryGroupLiveInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryGroupLiveInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryGroupLiveInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryGroupLiveInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var anchorUnionId: String?

    public var liveUuid: String?

    public var tenantContext: QueryGroupLiveInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anchorUnionId != nil {
            map["AnchorUnionId"] = self.anchorUnionId!
        }
        if self.liveUuid != nil {
            map["LiveUuid"] = self.liveUuid!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnchorUnionId") {
            self.anchorUnionId = dict["AnchorUnionId"] as! String
        }
        if dict.keys.contains("LiveUuid") {
            self.liveUuid = dict["LiveUuid"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryGroupLiveInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryGroupLiveInfoShrinkRequest : Tea.TeaModel {
    public var anchorUnionId: String?

    public var liveUuid: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anchorUnionId != nil {
            map["AnchorUnionId"] = self.anchorUnionId!
        }
        if self.liveUuid != nil {
            map["LiveUuid"] = self.liveUuid!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnchorUnionId") {
            self.anchorUnionId = dict["AnchorUnionId"] as! String
        }
        if dict.keys.contains("LiveUuid") {
            self.liveUuid = dict["LiveUuid"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryGroupLiveInfoResponseBody : Tea.TeaModel {
    public var coverUrl: String?

    public var duration: Int64?

    public var endTime: Int64?

    public var introduction: String?

    public var liveId: String?

    public var livePlayUrl: String?

    public var liveStatus: Int32?

    public var playbackDuration: Int64?

    public var replayUrl: String?

    public var requestId: String?

    public var staffId: String?

    public var startTime: Int64?

    public var subscribeCount: Int32?

    public var title: String?

    public var uv: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["coverUrl"] = self.coverUrl!
        }
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.introduction != nil {
            map["introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.livePlayUrl != nil {
            map["livePlayUrl"] = self.livePlayUrl!
        }
        if self.liveStatus != nil {
            map["liveStatus"] = self.liveStatus!
        }
        if self.playbackDuration != nil {
            map["playbackDuration"] = self.playbackDuration!
        }
        if self.replayUrl != nil {
            map["replayUrl"] = self.replayUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.staffId != nil {
            map["staffId"] = self.staffId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subscribeCount != nil {
            map["subscribeCount"] = self.subscribeCount!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("coverUrl") {
            self.coverUrl = dict["coverUrl"] as! String
        }
        if dict.keys.contains("duration") {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("introduction") {
            self.introduction = dict["introduction"] as! String
        }
        if dict.keys.contains("liveId") {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("livePlayUrl") {
            self.livePlayUrl = dict["livePlayUrl"] as! String
        }
        if dict.keys.contains("liveStatus") {
            self.liveStatus = dict["liveStatus"] as! Int32
        }
        if dict.keys.contains("playbackDuration") {
            self.playbackDuration = dict["playbackDuration"] as! Int64
        }
        if dict.keys.contains("replayUrl") {
            self.replayUrl = dict["replayUrl"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("staffId") {
            self.staffId = dict["staffId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subscribeCount") {
            self.subscribeCount = dict["subscribeCount"] as! Int32
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("uv") {
            self.uv = dict["uv"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryGroupLiveInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGroupLiveInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryGroupLiveInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryLiveInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: QueryLiveInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryLiveInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveInfoShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveInfoResponseBody : Tea.TeaModel {
    public var coverUrl: String?

    public var duration: Int64?

    public var endTime: Int64?

    public var introduction: String?

    public var liveId: String?

    public var livePlayUrl: String?

    public var liveStatus: Int32?

    public var playbackDuration: Int64?

    public var requestId: String?

    public var startTime: Int64?

    public var subscribeCount: Int32?

    public var title: String?

    public var uv: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["coverUrl"] = self.coverUrl!
        }
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.introduction != nil {
            map["introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.livePlayUrl != nil {
            map["livePlayUrl"] = self.livePlayUrl!
        }
        if self.liveStatus != nil {
            map["liveStatus"] = self.liveStatus!
        }
        if self.playbackDuration != nil {
            map["playbackDuration"] = self.playbackDuration!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subscribeCount != nil {
            map["subscribeCount"] = self.subscribeCount!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("coverUrl") {
            self.coverUrl = dict["coverUrl"] as! String
        }
        if dict.keys.contains("duration") {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("introduction") {
            self.introduction = dict["introduction"] as! String
        }
        if dict.keys.contains("liveId") {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("livePlayUrl") {
            self.livePlayUrl = dict["livePlayUrl"] as! String
        }
        if dict.keys.contains("liveStatus") {
            self.liveStatus = dict["liveStatus"] as! Int32
        }
        if dict.keys.contains("playbackDuration") {
            self.playbackDuration = dict["playbackDuration"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subscribeCount") {
            self.subscribeCount = dict["subscribeCount"] as! Int32
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("uv") {
            self.uv = dict["uv"] as! Int32
        }
    }
}

public class QueryLiveInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryLiveInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveWatchDetailHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveWatchDetailHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryLiveWatchDetailHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveWatchDetailShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveWatchDetailRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: QueryLiveWatchDetailRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryLiveWatchDetailRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveWatchDetailShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveWatchDetailResponseBody : Tea.TeaModel {
    public var avgWatchTime: Int64?

    public var liveUv: Int32?

    public var msgCount: Int32?

    public var playbackUv: Int32?

    public var praiseCount: Int32?

    public var pv: Int32?

    public var requestId: String?

    public var totalWatchTime: Int64?

    public var uv: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avgWatchTime != nil {
            map["avgWatchTime"] = self.avgWatchTime!
        }
        if self.liveUv != nil {
            map["liveUv"] = self.liveUv!
        }
        if self.msgCount != nil {
            map["msgCount"] = self.msgCount!
        }
        if self.playbackUv != nil {
            map["playbackUv"] = self.playbackUv!
        }
        if self.praiseCount != nil {
            map["praiseCount"] = self.praiseCount!
        }
        if self.pv != nil {
            map["pv"] = self.pv!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalWatchTime != nil {
            map["totalWatchTime"] = self.totalWatchTime!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("avgWatchTime") {
            self.avgWatchTime = dict["avgWatchTime"] as! Int64
        }
        if dict.keys.contains("liveUv") {
            self.liveUv = dict["liveUv"] as! Int32
        }
        if dict.keys.contains("msgCount") {
            self.msgCount = dict["msgCount"] as! Int32
        }
        if dict.keys.contains("playbackUv") {
            self.playbackUv = dict["playbackUv"] as! Int32
        }
        if dict.keys.contains("praiseCount") {
            self.praiseCount = dict["praiseCount"] as! Int32
        }
        if dict.keys.contains("pv") {
            self.pv = dict["pv"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalWatchTime") {
            self.totalWatchTime = dict["totalWatchTime"] as! Int64
        }
        if dict.keys.contains("uv") {
            self.uv = dict["uv"] as! Int32
        }
    }
}

public class QueryLiveWatchDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveWatchDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryLiveWatchDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveWatchUserListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveWatchUserListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryLiveWatchUserListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveWatchUserListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveWatchUserListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantContext: QueryLiveWatchUserListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryLiveWatchUserListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveWatchUserListShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveWatchUserListResponseBody : Tea.TeaModel {
    public class OrgUsesList : Tea.TeaModel {
        public var deptName: String?

        public var name: String?

        public var userId: String?

        public var watchLiveTime: Int64?

        public var watchPlaybackTime: Int64?

        public var watchProgressMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.watchLiveTime != nil {
                map["WatchLiveTime"] = self.watchLiveTime!
            }
            if self.watchPlaybackTime != nil {
                map["WatchPlaybackTime"] = self.watchPlaybackTime!
            }
            if self.watchProgressMs != nil {
                map["WatchProgressMs"] = self.watchProgressMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WatchLiveTime") {
                self.watchLiveTime = dict["WatchLiveTime"] as! Int64
            }
            if dict.keys.contains("WatchPlaybackTime") {
                self.watchPlaybackTime = dict["WatchPlaybackTime"] as! Int64
            }
            if dict.keys.contains("WatchProgressMs") {
                self.watchProgressMs = dict["WatchProgressMs"] as! Int64
            }
        }
    }
    public class OutOrgUserList : Tea.TeaModel {
        public var name: String?

        public var watchLiveTime: Int64?

        public var watchPlaybackTime: Int64?

        public var watchProgressMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.watchLiveTime != nil {
                map["WatchLiveTime"] = self.watchLiveTime!
            }
            if self.watchPlaybackTime != nil {
                map["WatchPlaybackTime"] = self.watchPlaybackTime!
            }
            if self.watchProgressMs != nil {
                map["WatchProgressMs"] = self.watchProgressMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WatchLiveTime") {
                self.watchLiveTime = dict["WatchLiveTime"] as! Int64
            }
            if dict.keys.contains("WatchPlaybackTime") {
                self.watchPlaybackTime = dict["WatchPlaybackTime"] as! Int64
            }
            if dict.keys.contains("WatchProgressMs") {
                self.watchProgressMs = dict["WatchProgressMs"] as! Int64
            }
        }
    }
    public var orgUsesList: [QueryLiveWatchUserListResponseBody.OrgUsesList]?

    public var outOrgUserList: [QueryLiveWatchUserListResponseBody.OutOrgUserList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgUsesList != nil {
            var tmp : [Any] = []
            for k in self.orgUsesList! {
                tmp.append(k.toMap())
            }
            map["orgUsesList"] = tmp
        }
        if self.outOrgUserList != nil {
            var tmp : [Any] = []
            for k in self.outOrgUserList! {
                tmp.append(k.toMap())
            }
            map["outOrgUserList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("orgUsesList") {
            var tmp : [QueryLiveWatchUserListResponseBody.OrgUsesList] = []
            for v in dict["orgUsesList"] as! [Any] {
                var model = QueryLiveWatchUserListResponseBody.OrgUsesList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orgUsesList = tmp
        }
        if dict.keys.contains("outOrgUserList") {
            var tmp : [QueryLiveWatchUserListResponseBody.OutOrgUserList] = []
            for v in dict["outOrgUserList"] as! [Any] {
                var model = QueryLiveWatchUserListResponseBody.OutOrgUserList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outOrgUserList = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryLiveWatchUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveWatchUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryLiveWatchUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var roomId: String?

    public var tenantContext: QueryMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomShrinkRequest : Tea.TeaModel {
    public var roomId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ReservationAuthority : Tea.TeaModel {
            public class AuthorizedMembers : Tea.TeaModel {
                public var memberId: String?

                public var memberName: String?

                public var memberType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.memberId != nil {
                        map["MemberId"] = self.memberId!
                    }
                    if self.memberName != nil {
                        map["MemberName"] = self.memberName!
                    }
                    if self.memberType != nil {
                        map["MemberType"] = self.memberType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MemberId") {
                        self.memberId = dict["MemberId"] as! String
                    }
                    if dict.keys.contains("MemberName") {
                        self.memberName = dict["MemberName"] as! String
                    }
                    if dict.keys.contains("MemberType") {
                        self.memberType = dict["MemberType"] as! String
                    }
                }
            }
            public var authorizedMembers: [QueryMeetingRoomResponseBody.Result.ReservationAuthority.AuthorizedMembers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizedMembers != nil {
                    var tmp : [Any] = []
                    for k in self.authorizedMembers! {
                        tmp.append(k.toMap())
                    }
                    map["AuthorizedMembers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorizedMembers") {
                    var tmp : [QueryMeetingRoomResponseBody.Result.ReservationAuthority.AuthorizedMembers] = []
                    for v in dict["AuthorizedMembers"] as! [Any] {
                        var model = QueryMeetingRoomResponseBody.Result.ReservationAuthority.AuthorizedMembers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authorizedMembers = tmp
                }
            }
        }
        public class RoomGroup : Tea.TeaModel {
            public var groupId: Int64?

            public var groupName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public class RoomLabels : Tea.TeaModel {
            public var labelId: Int64?

            public var labelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelId != nil {
                    map["LabelId"] = self.labelId!
                }
                if self.labelName != nil {
                    map["LabelName"] = self.labelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelId") {
                    self.labelId = dict["LabelId"] as! Int64
                }
                if dict.keys.contains("LabelName") {
                    self.labelName = dict["LabelName"] as! String
                }
            }
        }
        public class RoomLocation : Tea.TeaModel {
            public var desc: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var corpId: String?

        public var deviceUnionIds: [String]?

        public var enableCycleReservation: Bool?

        public var isvRoomId: String?

        public var reservationAuthority: QueryMeetingRoomResponseBody.Result.ReservationAuthority?

        public var roomCapacity: Int32?

        public var roomGroup: QueryMeetingRoomResponseBody.Result.RoomGroup?

        public var roomId: String?

        public var roomLabels: [QueryMeetingRoomResponseBody.Result.RoomLabels]?

        public var roomLocation: QueryMeetingRoomResponseBody.Result.RoomLocation?

        public var roomName: String?

        public var roomPicture: String?

        public var roomStaffId: String?

        public var roomStatus: Int32?

        public var roomUnionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.reservationAuthority?.validate()
            try self.roomGroup?.validate()
            try self.roomLocation?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.deviceUnionIds != nil {
                map["DeviceUnionIds"] = self.deviceUnionIds!
            }
            if self.enableCycleReservation != nil {
                map["EnableCycleReservation"] = self.enableCycleReservation!
            }
            if self.isvRoomId != nil {
                map["IsvRoomId"] = self.isvRoomId!
            }
            if self.reservationAuthority != nil {
                map["ReservationAuthority"] = self.reservationAuthority?.toMap()
            }
            if self.roomCapacity != nil {
                map["RoomCapacity"] = self.roomCapacity!
            }
            if self.roomGroup != nil {
                map["RoomGroup"] = self.roomGroup?.toMap()
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomLabels != nil {
                var tmp : [Any] = []
                for k in self.roomLabels! {
                    tmp.append(k.toMap())
                }
                map["RoomLabels"] = tmp
            }
            if self.roomLocation != nil {
                map["RoomLocation"] = self.roomLocation?.toMap()
            }
            if self.roomName != nil {
                map["RoomName"] = self.roomName!
            }
            if self.roomPicture != nil {
                map["RoomPicture"] = self.roomPicture!
            }
            if self.roomStaffId != nil {
                map["RoomStaffId"] = self.roomStaffId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            if self.roomUnionId != nil {
                map["RoomUnionId"] = self.roomUnionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DeviceUnionIds") {
                self.deviceUnionIds = dict["DeviceUnionIds"] as! [String]
            }
            if dict.keys.contains("EnableCycleReservation") {
                self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
            }
            if dict.keys.contains("IsvRoomId") {
                self.isvRoomId = dict["IsvRoomId"] as! String
            }
            if dict.keys.contains("ReservationAuthority") {
                var model = QueryMeetingRoomResponseBody.Result.ReservationAuthority()
                model.fromMap(dict["ReservationAuthority"] as! [String: Any])
                self.reservationAuthority = model
            }
            if dict.keys.contains("RoomCapacity") {
                self.roomCapacity = dict["RoomCapacity"] as! Int32
            }
            if dict.keys.contains("RoomGroup") {
                var model = QueryMeetingRoomResponseBody.Result.RoomGroup()
                model.fromMap(dict["RoomGroup"] as! [String: Any])
                self.roomGroup = model
            }
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomLabels") {
                var tmp : [QueryMeetingRoomResponseBody.Result.RoomLabels] = []
                for v in dict["RoomLabels"] as! [Any] {
                    var model = QueryMeetingRoomResponseBody.Result.RoomLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roomLabels = tmp
            }
            if dict.keys.contains("RoomLocation") {
                var model = QueryMeetingRoomResponseBody.Result.RoomLocation()
                model.fromMap(dict["RoomLocation"] as! [String: Any])
                self.roomLocation = model
            }
            if dict.keys.contains("RoomName") {
                self.roomName = dict["RoomName"] as! String
            }
            if dict.keys.contains("RoomPicture") {
                self.roomPicture = dict["RoomPicture"] as! String
            }
            if dict.keys.contains("RoomStaffId") {
                self.roomStaffId = dict["RoomStaffId"] as! String
            }
            if dict.keys.contains("RoomStatus") {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
            if dict.keys.contains("RoomUnionId") {
                self.roomUnionId = dict["RoomUnionId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: QueryMeetingRoomResponseBody.Result?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = QueryMeetingRoomResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var tenantContext: QueryMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var groupId: Int64?

    public var groupName: String?

    public var parentId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["groupName"] = self.groupName!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("groupId") {
            self.groupId = dict["groupId"] as! Int64
        }
        if dict.keys.contains("groupName") {
            self.groupName = dict["groupName"] as! String
        }
        if dict.keys.contains("parentId") {
            self.parentId = dict["parentId"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomGroupListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomGroupListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMeetingRoomGroupListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomGroupListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: QueryMeetingRoomGroupListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryMeetingRoomGroupListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomGroupListShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var groupId: Int64?

        public var groupName: String?

        public var parentId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [QueryMeetingRoomGroupListResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [QueryMeetingRoomGroupListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = QueryMeetingRoomGroupListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class QueryMeetingRoomGroupListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomGroupListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMeetingRoomGroupListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMeetingRoomListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: Int64?

    public var tenantContext: QueryMeetingRoomListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryMeetingRoomListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomListShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RoomGroup : Tea.TeaModel {
            public var groupId: Int64?

            public var groupName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public class RoomLabels : Tea.TeaModel {
            public var labelId: Int64?

            public var labelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelId != nil {
                    map["LabelId"] = self.labelId!
                }
                if self.labelName != nil {
                    map["LabelName"] = self.labelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelId") {
                    self.labelId = dict["LabelId"] as! Int64
                }
                if dict.keys.contains("LabelName") {
                    self.labelName = dict["LabelName"] as! String
                }
            }
        }
        public class RoomLocation : Tea.TeaModel {
            public var desc: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var corpId: String?

        public var isvRoomId: String?

        public var roomCapacity: Int32?

        public var roomGroup: QueryMeetingRoomListResponseBody.Result.RoomGroup?

        public var roomId: String?

        public var roomLabels: [QueryMeetingRoomListResponseBody.Result.RoomLabels]?

        public var roomLocation: QueryMeetingRoomListResponseBody.Result.RoomLocation?

        public var roomName: String?

        public var roomPicture: String?

        public var roomStaffId: String?

        public var roomStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.roomGroup?.validate()
            try self.roomLocation?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.isvRoomId != nil {
                map["IsvRoomId"] = self.isvRoomId!
            }
            if self.roomCapacity != nil {
                map["RoomCapacity"] = self.roomCapacity!
            }
            if self.roomGroup != nil {
                map["RoomGroup"] = self.roomGroup?.toMap()
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomLabels != nil {
                var tmp : [Any] = []
                for k in self.roomLabels! {
                    tmp.append(k.toMap())
                }
                map["RoomLabels"] = tmp
            }
            if self.roomLocation != nil {
                map["RoomLocation"] = self.roomLocation?.toMap()
            }
            if self.roomName != nil {
                map["RoomName"] = self.roomName!
            }
            if self.roomPicture != nil {
                map["RoomPicture"] = self.roomPicture!
            }
            if self.roomStaffId != nil {
                map["RoomStaffId"] = self.roomStaffId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("IsvRoomId") {
                self.isvRoomId = dict["IsvRoomId"] as! String
            }
            if dict.keys.contains("RoomCapacity") {
                self.roomCapacity = dict["RoomCapacity"] as! Int32
            }
            if dict.keys.contains("RoomGroup") {
                var model = QueryMeetingRoomListResponseBody.Result.RoomGroup()
                model.fromMap(dict["RoomGroup"] as! [String: Any])
                self.roomGroup = model
            }
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomLabels") {
                var tmp : [QueryMeetingRoomListResponseBody.Result.RoomLabels] = []
                for v in dict["RoomLabels"] as! [Any] {
                    var model = QueryMeetingRoomListResponseBody.Result.RoomLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roomLabels = tmp
            }
            if dict.keys.contains("RoomLocation") {
                var model = QueryMeetingRoomListResponseBody.Result.RoomLocation()
                model.fromMap(dict["RoomLocation"] as! [String: Any])
                self.roomLocation = model
            }
            if dict.keys.contains("RoomName") {
                self.roomName = dict["RoomName"] as! String
            }
            if dict.keys.contains("RoomPicture") {
                self.roomPicture = dict["RoomPicture"] as! String
            }
            if dict.keys.contains("RoomStaffId") {
                self.roomStaffId = dict["RoomStaffId"] as! String
            }
            if dict.keys.contains("RoomStatus") {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
        }
    }
    public var hasMore: Bool?

    public var nextToken: Int64?

    public var requestId: String?

    public var result: [QueryMeetingRoomListResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [QueryMeetingRoomListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = QueryMeetingRoomListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class QueryMeetingRoomListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMeetingRoomListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMinutesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMinutesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMinutesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMinutesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMinutesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryMinutesRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryMinutesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryMinutesShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryMinutesResponseBody : Tea.TeaModel {
    public class AudioList : Tea.TeaModel {
        public var duration: Int64?

        public var endTime: Int64?

        public var fileSize: Int64?

        public var playUrl: String?

        public var recordId: String?

        public var startTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.playUrl != nil {
                map["PlayUrl"] = self.playUrl!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("PlayUrl") {
                self.playUrl = dict["PlayUrl"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var audioList: [QueryMinutesResponseBody.AudioList]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioList != nil {
            var tmp : [Any] = []
            for k in self.audioList! {
                tmp.append(k.toMap())
            }
            map["audioList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("audioList") {
            var tmp : [QueryMinutesResponseBody.AudioList] = []
            for v in dict["audioList"] as! [Any] {
                var model = QueryMinutesResponseBody.AudioList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.audioList = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryMinutesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMinutesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMinutesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMinutesSummaryHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMinutesSummaryHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMinutesSummaryHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMinutesSummaryShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMinutesSummaryRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryMinutesSummaryRequest.TenantContext?

    public var conferenceId: String?

    public var summaryTypeList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.summaryTypeList != nil {
            map["summaryTypeList"] = self.summaryTypeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryMinutesSummaryRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("summaryTypeList") {
            self.summaryTypeList = dict["summaryTypeList"] as! [String]
        }
    }
}

public class QueryMinutesSummaryShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public var summaryTypeListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.summaryTypeListShrink != nil {
            map["summaryTypeList"] = self.summaryTypeListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("summaryTypeList") {
            self.summaryTypeListShrink = dict["summaryTypeList"] as! String
        }
    }
}

public class QueryMinutesSummaryResponseBody : Tea.TeaModel {
    public class Summary : Tea.TeaModel {
        public class Actions : Tea.TeaModel {
            public var end: Int64?

            public var id: Int64?

            public var sentenceId: Int64?

            public var start: Int64?

            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.sentenceId != nil {
                    map["SentenceId"] = self.sentenceId!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("SentenceId") {
                    self.sentenceId = dict["SentenceId"] as! Int64
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! Int64
                }
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class AutoChapters : Tea.TeaModel {
            public var end: Int64?

            public var headline: String?

            public var id: Int64?

            public var start: Int64?

            public var summary: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.headline != nil {
                    map["Headline"] = self.headline!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.summary != nil {
                    map["Summary"] = self.summary!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! Int64
                }
                if dict.keys.contains("Headline") {
                    self.headline = dict["Headline"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! Int64
                }
                if dict.keys.contains("Summary") {
                    self.summary = dict["Summary"] as! String
                }
            }
        }
        public class ConversationalSummary : Tea.TeaModel {
            public var speakerId: String?

            public var speakerName: String?

            public var summary: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.speakerId != nil {
                    map["SpeakerId"] = self.speakerId!
                }
                if self.speakerName != nil {
                    map["SpeakerName"] = self.speakerName!
                }
                if self.summary != nil {
                    map["Summary"] = self.summary!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SpeakerId") {
                    self.speakerId = dict["SpeakerId"] as! String
                }
                if dict.keys.contains("SpeakerName") {
                    self.speakerName = dict["SpeakerName"] as! String
                }
                if dict.keys.contains("Summary") {
                    self.summary = dict["Summary"] as! String
                }
            }
        }
        public class KeySentences : Tea.TeaModel {
            public var end: Int64?

            public var id: Int64?

            public var sentenceId: Int64?

            public var start: Int64?

            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.sentenceId != nil {
                    map["SentenceId"] = self.sentenceId!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("SentenceId") {
                    self.sentenceId = dict["SentenceId"] as! Int64
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! Int64
                }
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class QuestionsAnsweringSummary : Tea.TeaModel {
            public var answer: String?

            public var question: String?

            public var sentenceIdsOfAnswer: [Int64]?

            public var sentenceIdsOfQuestion: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answer != nil {
                    map["Answer"] = self.answer!
                }
                if self.question != nil {
                    map["Question"] = self.question!
                }
                if self.sentenceIdsOfAnswer != nil {
                    map["SentenceIdsOfAnswer"] = self.sentenceIdsOfAnswer!
                }
                if self.sentenceIdsOfQuestion != nil {
                    map["SentenceIdsOfQuestion"] = self.sentenceIdsOfQuestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Answer") {
                    self.answer = dict["Answer"] as! String
                }
                if dict.keys.contains("Question") {
                    self.question = dict["Question"] as! String
                }
                if dict.keys.contains("SentenceIdsOfAnswer") {
                    self.sentenceIdsOfAnswer = dict["SentenceIdsOfAnswer"] as! [Int64]
                }
                if dict.keys.contains("SentenceIdsOfQuestion") {
                    self.sentenceIdsOfQuestion = dict["SentenceIdsOfQuestion"] as! [Int64]
                }
            }
        }
        public var actions: QueryMinutesSummaryResponseBody.Summary.Actions?

        public var autoChapters: [QueryMinutesSummaryResponseBody.Summary.AutoChapters]?

        public var conversationalSummary: [QueryMinutesSummaryResponseBody.Summary.ConversationalSummary]?

        public var keySentences: QueryMinutesSummaryResponseBody.Summary.KeySentences?

        public var keywords: [String]?

        public var paragraphSummary: String?

        public var questionsAnsweringSummary: [QueryMinutesSummaryResponseBody.Summary.QuestionsAnsweringSummary]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.actions?.validate()
            try self.keySentences?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                map["Actions"] = self.actions?.toMap()
            }
            if self.autoChapters != nil {
                var tmp : [Any] = []
                for k in self.autoChapters! {
                    tmp.append(k.toMap())
                }
                map["AutoChapters"] = tmp
            }
            if self.conversationalSummary != nil {
                var tmp : [Any] = []
                for k in self.conversationalSummary! {
                    tmp.append(k.toMap())
                }
                map["ConversationalSummary"] = tmp
            }
            if self.keySentences != nil {
                map["KeySentences"] = self.keySentences?.toMap()
            }
            if self.keywords != nil {
                map["Keywords"] = self.keywords!
            }
            if self.paragraphSummary != nil {
                map["ParagraphSummary"] = self.paragraphSummary!
            }
            if self.questionsAnsweringSummary != nil {
                var tmp : [Any] = []
                for k in self.questionsAnsweringSummary! {
                    tmp.append(k.toMap())
                }
                map["QuestionsAnsweringSummary"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Actions") {
                var model = QueryMinutesSummaryResponseBody.Summary.Actions()
                model.fromMap(dict["Actions"] as! [String: Any])
                self.actions = model
            }
            if dict.keys.contains("AutoChapters") {
                var tmp : [QueryMinutesSummaryResponseBody.Summary.AutoChapters] = []
                for v in dict["AutoChapters"] as! [Any] {
                    var model = QueryMinutesSummaryResponseBody.Summary.AutoChapters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.autoChapters = tmp
            }
            if dict.keys.contains("ConversationalSummary") {
                var tmp : [QueryMinutesSummaryResponseBody.Summary.ConversationalSummary] = []
                for v in dict["ConversationalSummary"] as! [Any] {
                    var model = QueryMinutesSummaryResponseBody.Summary.ConversationalSummary()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conversationalSummary = tmp
            }
            if dict.keys.contains("KeySentences") {
                var model = QueryMinutesSummaryResponseBody.Summary.KeySentences()
                model.fromMap(dict["KeySentences"] as! [String: Any])
                self.keySentences = model
            }
            if dict.keys.contains("Keywords") {
                self.keywords = dict["Keywords"] as! [String]
            }
            if dict.keys.contains("ParagraphSummary") {
                self.paragraphSummary = dict["ParagraphSummary"] as! String
            }
            if dict.keys.contains("QuestionsAnsweringSummary") {
                var tmp : [QueryMinutesSummaryResponseBody.Summary.QuestionsAnsweringSummary] = []
                for v in dict["QuestionsAnsweringSummary"] as! [Any] {
                    var model = QueryMinutesSummaryResponseBody.Summary.QuestionsAnsweringSummary()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.questionsAnsweringSummary = tmp
            }
        }
    }
    public var requestId: String?

    public var summary: QueryMinutesSummaryResponseBody.Summary?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.summary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.summary != nil {
            map["summary"] = self.summary?.toMap()
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("summary") {
            var model = QueryMinutesSummaryResponseBody.Summary()
            model.fromMap(dict["summary"] as! [String: Any])
            self.summary = model
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryMinutesSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMinutesSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMinutesSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMinutesTextHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMinutesTextHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryMinutesTextHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMinutesTextShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMinutesTextRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryMinutesTextRequest.TenantContext?

    public var conferenceId: String?

    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryMinutesTextRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("direction") {
            self.direction = dict["direction"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryMinutesTextShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("direction") {
            self.direction = dict["direction"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryMinutesTextResponseBody : Tea.TeaModel {
    public class ParagraphList : Tea.TeaModel {
        public class SentenceList : Tea.TeaModel {
            public class WordList : Tea.TeaModel {
                public var endTime: Int64?

                public var startTime: Int64?

                public var word: String?

                public var wordId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.word != nil {
                        map["Word"] = self.word!
                    }
                    if self.wordId != nil {
                        map["WordId"] = self.wordId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Word") {
                        self.word = dict["Word"] as! String
                    }
                    if dict.keys.contains("WordId") {
                        self.wordId = dict["WordId"] as! String
                    }
                }
            }
            public var endTime: Int64?

            public var sentence: String?

            public var startTime: Int64?

            public var userId: String?

            public var wordList: [QueryMinutesTextResponseBody.ParagraphList.SentenceList.WordList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.sentence != nil {
                    map["Sentence"] = self.sentence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.wordList != nil {
                    var tmp : [Any] = []
                    for k in self.wordList! {
                        tmp.append(k.toMap())
                    }
                    map["WordList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Sentence") {
                    self.sentence = dict["Sentence"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WordList") {
                    var tmp : [QueryMinutesTextResponseBody.ParagraphList.SentenceList.WordList] = []
                    for v in dict["WordList"] as! [Any] {
                        var model = QueryMinutesTextResponseBody.ParagraphList.SentenceList.WordList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wordList = tmp
                }
            }
        }
        public var endTime: Int64?

        public var nickName: String?

        public var paragraph: String?

        public var paragraphId: Int64?

        public var recordId: Int64?

        public var sentenceList: [QueryMinutesTextResponseBody.ParagraphList.SentenceList]?

        public var startTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.paragraph != nil {
                map["Paragraph"] = self.paragraph!
            }
            if self.paragraphId != nil {
                map["ParagraphId"] = self.paragraphId!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.sentenceList != nil {
                var tmp : [Any] = []
                for k in self.sentenceList! {
                    tmp.append(k.toMap())
                }
                map["SentenceList"] = tmp
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("NickName") {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("Paragraph") {
                self.paragraph = dict["Paragraph"] as! String
            }
            if dict.keys.contains("ParagraphId") {
                self.paragraphId = dict["ParagraphId"] as! Int64
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! Int64
            }
            if dict.keys.contains("SentenceList") {
                var tmp : [QueryMinutesTextResponseBody.ParagraphList.SentenceList] = []
                for v in dict["SentenceList"] as! [Any] {
                    var model = QueryMinutesTextResponseBody.ParagraphList.SentenceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sentenceList = tmp
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var hasMore: Bool?

    public var nextToken: String?

    public var paragraphList: [QueryMinutesTextResponseBody.ParagraphList]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.paragraphList != nil {
            var tmp : [Any] = []
            for k in self.paragraphList! {
                tmp.append(k.toMap())
            }
            map["paragraphList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("paragraphList") {
            var tmp : [QueryMinutesTextResponseBody.ParagraphList] = []
            for v in dict["paragraphList"] as! [Any] {
                var model = QueryMinutesTextResponseBody.ParagraphList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paragraphList = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryMinutesTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMinutesTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMinutesTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrgHonorsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryOrgHonorsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryOrgHonorsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryOrgHonorsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryOrgHonorsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryOrgHonorsRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryOrgHonorsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
    }
}

public class QueryOrgHonorsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
    }
}

public class QueryOrgHonorsResponseBody : Tea.TeaModel {
    public class OpenHonors : Tea.TeaModel {
        public var honorDesc: String?

        public var honorId: Int64?

        public var honorImgUrl: String?

        public var honorName: String?

        public var honorPendantImgUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.honorDesc != nil {
                map["honorDesc"] = self.honorDesc!
            }
            if self.honorId != nil {
                map["honorId"] = self.honorId!
            }
            if self.honorImgUrl != nil {
                map["honorImgUrl"] = self.honorImgUrl!
            }
            if self.honorName != nil {
                map["honorName"] = self.honorName!
            }
            if self.honorPendantImgUrl != nil {
                map["honorPendantImgUrl"] = self.honorPendantImgUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("honorDesc") {
                self.honorDesc = dict["honorDesc"] as! String
            }
            if dict.keys.contains("honorId") {
                self.honorId = dict["honorId"] as! Int64
            }
            if dict.keys.contains("honorImgUrl") {
                self.honorImgUrl = dict["honorImgUrl"] as! String
            }
            if dict.keys.contains("honorName") {
                self.honorName = dict["honorName"] as! String
            }
            if dict.keys.contains("honorPendantImgUrl") {
                self.honorPendantImgUrl = dict["honorPendantImgUrl"] as! String
            }
        }
    }
    public var nextToken: String?

    public var openHonors: [QueryOrgHonorsResponseBody.OpenHonors]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.openHonors != nil {
            var tmp : [Any] = []
            for k in self.openHonors! {
                tmp.append(k.toMap())
            }
            map["openHonors"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("openHonors") {
            var tmp : [QueryOrgHonorsResponseBody.OpenHonors] = []
            for v in dict["openHonors"] as! [Any] {
                var model = QueryOrgHonorsResponseBody.OpenHonors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.openHonors = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryOrgHonorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrgHonorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryOrgHonorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrgTodoTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryOrgTodoTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryOrgTodoTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryOrgTodoTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryOrgTodoTasksRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryOrgTodoTasksRequest.TenantContext?

    public var isDone: Bool?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.isDone != nil {
            map["isDone"] = self.isDone!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryOrgTodoTasksRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("isDone") {
            self.isDone = dict["isDone"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryOrgTodoTasksShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var isDone: Bool?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.isDone != nil {
            map["isDone"] = self.isDone!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("isDone") {
            self.isDone = dict["isDone"] as! Bool
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryOrgTodoTasksResponseBody : Tea.TeaModel {
    public class TodoCards : Tea.TeaModel {
        public class DetailUrl : Tea.TeaModel {
            public var appUrl: String?

            public var pcUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appUrl != nil {
                    map["appUrl"] = self.appUrl!
                }
                if self.pcUrl != nil {
                    map["pcUrl"] = self.pcUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("appUrl") {
                    self.appUrl = dict["appUrl"] as! String
                }
                if dict.keys.contains("pcUrl") {
                    self.pcUrl = dict["pcUrl"] as! String
                }
            }
        }
        public var bizTag: String?

        public var createdTime: Int64?

        public var creatorId: String?

        public var detailUrl: QueryOrgTodoTasksResponseBody.TodoCards.DetailUrl?

        public var dueTime: Int64?

        public var isDone: Bool?

        public var modifiedTime: Int64?

        public var priority: Int32?

        public var sourceId: String?

        public var subject: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.detailUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizTag != nil {
                map["bizTag"] = self.bizTag!
            }
            if self.createdTime != nil {
                map["createdTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl?.toMap()
            }
            if self.dueTime != nil {
                map["dueTime"] = self.dueTime!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizTag") {
                self.bizTag = dict["bizTag"] as! String
            }
            if dict.keys.contains("createdTime") {
                self.createdTime = dict["createdTime"] as! Int64
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! String
            }
            if dict.keys.contains("detailUrl") {
                var model = QueryOrgTodoTasksResponseBody.TodoCards.DetailUrl()
                model.fromMap(dict["detailUrl"] as! [String: Any])
                self.detailUrl = model
            }
            if dict.keys.contains("dueTime") {
                self.dueTime = dict["dueTime"] as! Int64
            }
            if dict.keys.contains("isDone") {
                self.isDone = dict["isDone"] as! Bool
            }
            if dict.keys.contains("modifiedTime") {
                self.modifiedTime = dict["modifiedTime"] as! Int64
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("taskId") {
                self.taskId = dict["taskId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var todoCards: [QueryOrgTodoTasksResponseBody.TodoCards]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.todoCards != nil {
            var tmp : [Any] = []
            for k in self.todoCards! {
                tmp.append(k.toMap())
            }
            map["todoCards"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("todoCards") {
            var tmp : [QueryOrgTodoTasksResponseBody.TodoCards] = []
            for v in dict["todoCards"] as! [Any] {
                var model = QueryOrgTodoTasksResponseBody.TodoCards()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.todoCards = tmp
        }
    }
}

public class QueryOrgTodoTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrgTodoTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryOrgTodoTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRecordMinutesUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryRecordMinutesUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryRecordMinutesUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryRecordMinutesUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryRecordMinutesUrlRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var bizType: String?

    public var conferenceId: String?

    public var tenantContext: QueryRecordMinutesUrlRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ConferenceId") {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryRecordMinutesUrlRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryRecordMinutesUrlShrinkRequest : Tea.TeaModel {
    public var bizType: String?

    public var conferenceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ConferenceId") {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryRecordMinutesUrlResponseBody : Tea.TeaModel {
    public class RecordMinutesUrls : Tea.TeaModel {
        public var recordMinutesUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordMinutesUrl != nil {
                map["RecordMinutesUrl"] = self.recordMinutesUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordMinutesUrl") {
                self.recordMinutesUrl = dict["RecordMinutesUrl"] as! String
            }
        }
    }
    public var recordMinutesUrls: [QueryRecordMinutesUrlResponseBody.RecordMinutesUrls]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordMinutesUrls != nil {
            var tmp : [Any] = []
            for k in self.recordMinutesUrls! {
                tmp.append(k.toMap())
            }
            map["recordMinutesUrls"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("recordMinutesUrls") {
            var tmp : [QueryRecordMinutesUrlResponseBody.RecordMinutesUrls] = []
            for v in dict["recordMinutesUrls"] as! [Any] {
                var model = QueryRecordMinutesUrlResponseBody.RecordMinutesUrls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordMinutesUrls = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryRecordMinutesUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecordMinutesUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryRecordMinutesUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryReportDetailHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryReportDetailHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryReportDetailHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryReportDetailShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryReportDetailRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var reportId: String?

    public var tenantContext: QueryReportDetailRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryReportDetailRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryReportDetailShrinkRequest : Tea.TeaModel {
    public var reportId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryReportDetailResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var images: [String]?

        public var key: String?

        public var sort: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.images != nil {
                map["Images"] = self.images!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Images") {
                self.images = dict["Images"] as! [String]
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") {
                self.sort = dict["Sort"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var content: [QueryReportDetailResponseBody.Content]?

    public var createTime: Int64?

    public var creatorId: String?

    public var creatorName: String?

    public var deptName: String?

    public var modifiedTime: Int64?

    public var remark: String?

    public var reportId: String?

    public var requestId: String?

    public var templateName: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["content"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.creatorName != nil {
            map["creatorName"] = self.creatorName!
        }
        if self.deptName != nil {
            map["deptName"] = self.deptName!
        }
        if self.modifiedTime != nil {
            map["modifiedTime"] = self.modifiedTime!
        }
        if self.remark != nil {
            map["remark"] = self.remark!
        }
        if self.reportId != nil {
            map["reportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.templateName != nil {
            map["templateName"] = self.templateName!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            var tmp : [QueryReportDetailResponseBody.Content] = []
            for v in dict["content"] as! [Any] {
                var model = QueryReportDetailResponseBody.Content()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.content = tmp
        }
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! Int64
        }
        if dict.keys.contains("creatorId") {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("creatorName") {
            self.creatorName = dict["creatorName"] as! String
        }
        if dict.keys.contains("deptName") {
            self.deptName = dict["deptName"] as! String
        }
        if dict.keys.contains("modifiedTime") {
            self.modifiedTime = dict["modifiedTime"] as! Int64
        }
        if dict.keys.contains("remark") {
            self.remark = dict["remark"] as! String
        }
        if dict.keys.contains("reportId") {
            self.reportId = dict["reportId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("templateName") {
            self.templateName = dict["templateName"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryReportDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryReportDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryReportDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryScheduleConferenceRequest.TenantContext?

    public var scheduleConferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("scheduleConferenceId") {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
    }
}

public class QueryScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var scheduleConferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
    }
}

public class QueryScheduleConferenceResponseBody : Tea.TeaModel {
    public var endTime: Int64?

    public var phones: [String]?

    public var requestId: String?

    public var roomCode: String?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var title: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.phones != nil {
            map["phones"] = self.phones!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("phones") {
            self.phones = dict["phones"] as! [String]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") {
            self.roomCode = dict["roomCode"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
    }
}

public class QueryScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryScheduleConferenceInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryScheduleConferenceInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryScheduleConferenceInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryScheduleConferenceInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryScheduleConferenceInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var scheduleConferenceId: String?

    public var tenantContext: QueryScheduleConferenceInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = QueryScheduleConferenceInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryScheduleConferenceInfoShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var scheduleConferenceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryScheduleConferenceInfoResponseBody : Tea.TeaModel {
    public class ConferenceList : Tea.TeaModel {
        public var conferenceId: String?

        public var endTime: Int64?

        public var roomCode: String?

        public var startTime: Int64?

        public var status: Int32?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.roomCode != nil {
                map["RoomCode"] = self.roomCode!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("RoomCode") {
                self.roomCode = dict["RoomCode"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var conferenceList: [QueryScheduleConferenceInfoResponseBody.ConferenceList]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceList != nil {
            var tmp : [Any] = []
            for k in self.conferenceList! {
                tmp.append(k.toMap())
            }
            map["conferenceList"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceList") {
            var tmp : [QueryScheduleConferenceInfoResponseBody.ConferenceList] = []
            for v in dict["conferenceList"] as! [Any] {
                var model = QueryScheduleConferenceInfoResponseBody.ConferenceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.conferenceList = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryScheduleConferenceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryScheduleConferenceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryScheduleConferenceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUserHonorsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryUserHonorsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = QueryUserHonorsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryUserHonorsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryUserHonorsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryUserHonorsRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = QueryUserHonorsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class QueryUserHonorsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class QueryUserHonorsResponseBody : Tea.TeaModel {
    public class Honors : Tea.TeaModel {
        public class GrantHistory : Tea.TeaModel {
            public var grantTime: Int64?

            public var senderUserid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.grantTime != nil {
                    map["grantTime"] = self.grantTime!
                }
                if self.senderUserid != nil {
                    map["senderUserid"] = self.senderUserid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("grantTime") {
                    self.grantTime = dict["grantTime"] as! Int64
                }
                if dict.keys.contains("senderUserid") {
                    self.senderUserid = dict["senderUserid"] as! String
                }
            }
        }
        public var expirationTime: Int64?

        public var grantHistory: [QueryUserHonorsResponseBody.Honors.GrantHistory]?

        public var honorDesc: String?

        public var honorId: String?

        public var honorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationTime != nil {
                map["expirationTime"] = self.expirationTime!
            }
            if self.grantHistory != nil {
                var tmp : [Any] = []
                for k in self.grantHistory! {
                    tmp.append(k.toMap())
                }
                map["grantHistory"] = tmp
            }
            if self.honorDesc != nil {
                map["honorDesc"] = self.honorDesc!
            }
            if self.honorId != nil {
                map["honorId"] = self.honorId!
            }
            if self.honorName != nil {
                map["honorName"] = self.honorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("expirationTime") {
                self.expirationTime = dict["expirationTime"] as! Int64
            }
            if dict.keys.contains("grantHistory") {
                var tmp : [QueryUserHonorsResponseBody.Honors.GrantHistory] = []
                for v in dict["grantHistory"] as! [Any] {
                    var model = QueryUserHonorsResponseBody.Honors.GrantHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.grantHistory = tmp
            }
            if dict.keys.contains("honorDesc") {
                self.honorDesc = dict["honorDesc"] as! String
            }
            if dict.keys.contains("honorId") {
                self.honorId = dict["honorId"] as! String
            }
            if dict.keys.contains("honorName") {
                self.honorName = dict["honorName"] as! String
            }
        }
    }
    public var honors: [QueryUserHonorsResponseBody.Honors]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honors != nil {
            var tmp : [Any] = []
            for k in self.honors! {
                tmp.append(k.toMap())
            }
            map["honors"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("honors") {
            var tmp : [QueryUserHonorsResponseBody.Honors] = []
            for v in dict["honors"] as! [Any] {
                var model = QueryUserHonorsResponseBody.Honors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honors = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryUserHonorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUserHonorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryUserHonorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecallHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RecallHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = RecallHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RecallHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RecallHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: RecallHonorRequest.TenantContext?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = RecallHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class RecallHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class RecallHonorResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: RecallHonorResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            var model = RecallHonorResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class RecallHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecallHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecallHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReceiverListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ReceiverListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = ReceiverListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ReceiverListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ReceiverListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: ReceiverListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = ReceiverListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ReceiverListReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ReceiverListReportResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var useridList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.useridList != nil {
            map["useridList"] = self.useridList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("useridList") {
            self.useridList = dict["useridList"] as! [String]
        }
    }
}

public class ReceiverListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReceiverListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReceiverListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RedirectTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RedirectTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = RedirectTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RedirectTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RedirectTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var byManager: String?

    public var language: String?

    public var nowActionExecutorId: String?

    public var processInstanceId: String?

    public var remark: String?

    public var systemToken: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.byManager != nil {
            map["ByManager"] = self.byManager!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.nowActionExecutorId != nil {
            map["NowActionExecutorId"] = self.nowActionExecutorId!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ByManager") {
            self.byManager = dict["ByManager"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NowActionExecutorId") {
            self.nowActionExecutorId = dict["NowActionExecutorId"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class RedirectTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class RedirectTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedirectTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RedirectTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAttendeeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RemoveAttendeeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = RemoveAttendeeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RemoveAttendeeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RemoveAttendeeRequest : Tea.TeaModel {
    public var attendeesToRemove: [String]?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToRemove != nil {
            map["AttendeesToRemove"] = self.attendeesToRemove!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToRemove") {
            self.attendeesToRemove = dict["AttendeesToRemove"] as! [String]
        }
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class RemoveAttendeeShrinkRequest : Tea.TeaModel {
    public var attendeesToRemoveShrink: String?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToRemoveShrink != nil {
            map["AttendeesToRemove"] = self.attendeesToRemoveShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToRemove") {
            self.attendeesToRemoveShrink = dict["AttendeesToRemove"] as! String
        }
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class RemoveAttendeeResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! Any
            }
        }
    }
    public var content: RemoveAttendeeResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["ErrorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = RemoveAttendeeResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorCtx") {
            self.errorCtx = dict["ErrorCtx"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveAttendeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAttendeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveAttendeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveMeetingRoomsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RemoveMeetingRoomsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = RemoveMeetingRoomsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RemoveMeetingRoomsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RemoveMeetingRoomsRequest : Tea.TeaModel {
    public class MeetingRoomsToRemove : Tea.TeaModel {
        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToRemove: [RemoveMeetingRoomsRequest.MeetingRoomsToRemove]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToRemove != nil {
            var tmp : [Any] = []
            for k in self.meetingRoomsToRemove! {
                tmp.append(k.toMap())
            }
            map["MeetingRoomsToRemove"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToRemove") {
            var tmp : [RemoveMeetingRoomsRequest.MeetingRoomsToRemove] = []
            for v in dict["MeetingRoomsToRemove"] as! [Any] {
                var model = RemoveMeetingRoomsRequest.MeetingRoomsToRemove()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRoomsToRemove = tmp
        }
    }
}

public class RemoveMeetingRoomsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToRemoveShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToRemoveShrink != nil {
            map["MeetingRoomsToRemove"] = self.meetingRoomsToRemoveShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToRemove") {
            self.meetingRoomsToRemoveShrink = dict["MeetingRoomsToRemove"] as! String
        }
    }
}

public class RemoveMeetingRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class RemoveMeetingRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveMeetingRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveMeetingRoomsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RespondEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RespondEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = RespondEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RespondEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RespondEventRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var responseStatus: String?

    public var tenantContext: RespondEventRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.responseStatus != nil {
            map["ResponseStatus"] = self.responseStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("ResponseStatus") {
            self.responseStatus = dict["ResponseStatus"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = RespondEventRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class RespondEventShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var responseStatus: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.responseStatus != nil {
            map["ResponseStatus"] = self.responseStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("ResponseStatus") {
            self.responseStatus = dict["ResponseStatus"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class RespondEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class RespondEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RespondEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RespondEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetrieveRunHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
    }
}

public class RetrieveRunRequest : Tea.TeaModel {
    public var assistantId: String?

    public var originalAssistantId: String?

    public var runId: String?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistantId != nil {
            map["assistantId"] = self.assistantId!
        }
        if self.originalAssistantId != nil {
            map["originalAssistantId"] = self.originalAssistantId!
        }
        if self.runId != nil {
            map["runId"] = self.runId!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assistantId") {
            self.assistantId = dict["assistantId"] as! String
        }
        if dict.keys.contains("originalAssistantId") {
            self.originalAssistantId = dict["originalAssistantId"] as! String
        }
        if dict.keys.contains("runId") {
            self.runId = dict["runId"] as! String
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class RetrieveRunResponseBody : Tea.TeaModel {
    public var cancelledAt: Int64?

    public var completedAt: Int64?

    public var createAt: Int64?

    public var expiresAt: Int64?

    public var failedAt: Int64?

    public var id: String?

    public var lastErrorMsg: String?

    public var metadata: [String: Any]?

    public var object: String?

    public var requestId: String?

    public var startedAt: Int64?

    public var status: String?

    public var threadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cancelledAt != nil {
            map["cancelledAt"] = self.cancelledAt!
        }
        if self.completedAt != nil {
            map["completedAt"] = self.completedAt!
        }
        if self.createAt != nil {
            map["createAt"] = self.createAt!
        }
        if self.expiresAt != nil {
            map["expiresAt"] = self.expiresAt!
        }
        if self.failedAt != nil {
            map["failedAt"] = self.failedAt!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastErrorMsg != nil {
            map["lastErrorMsg"] = self.lastErrorMsg!
        }
        if self.metadata != nil {
            map["metadata"] = self.metadata!
        }
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.startedAt != nil {
            map["startedAt"] = self.startedAt!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.threadId != nil {
            map["threadId"] = self.threadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cancelledAt") {
            self.cancelledAt = dict["cancelledAt"] as! Int64
        }
        if dict.keys.contains("completedAt") {
            self.completedAt = dict["completedAt"] as! Int64
        }
        if dict.keys.contains("createAt") {
            self.createAt = dict["createAt"] as! Int64
        }
        if dict.keys.contains("expiresAt") {
            self.expiresAt = dict["expiresAt"] as! Int64
        }
        if dict.keys.contains("failedAt") {
            self.failedAt = dict["failedAt"] as! Int64
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("lastErrorMsg") {
            self.lastErrorMsg = dict["lastErrorMsg"] as! String
        }
        if dict.keys.contains("metadata") {
            self.metadata = dict["metadata"] as! [String: Any]
        }
        if dict.keys.contains("object") {
            self.object = dict["object"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("startedAt") {
            self.startedAt = dict["startedAt"] as! Int64
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("threadId") {
            self.threadId = dict["threadId"] as! String
        }
    }
}

public class RetrieveRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetrieveRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetrieveRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveContentHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveContentHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SaveContentHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveContentShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveContentRequest : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var content: String?

        public var contentType: String?

        public var key: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentType") {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var contents: [SaveContentRequest.Contents]?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContext: SaveContentRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") {
            var tmp : [SaveContentRequest.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = SaveContentRequest.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("DdFrom") {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SaveContentRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SaveContentShrinkRequest : Tea.TeaModel {
    public var contentsShrink: String?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentsShrink != nil {
            map["Contents"] = self.contentsShrink!
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") {
            self.contentsShrink = dict["Contents"] as! String
        }
        if dict.keys.contains("DdFrom") {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SaveContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SaveContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SaveFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formDataJson: String?

    public var formUuid: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormDataJson") {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SaveFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SaveFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveFormRemarkHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveFormRemarkHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SaveFormRemarkHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveFormRemarkShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveFormRemarkRequest : Tea.TeaModel {
    public var appType: String?

    public var atUserId: String?

    public var content: String?

    public var formInstanceId: String?

    public var language: String?

    public var replyId: Int64?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.atUserId != nil {
            map["AtUserId"] = self.atUserId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.replyId != nil {
            map["ReplyId"] = self.replyId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AtUserId") {
            self.atUserId = dict["AtUserId"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("FormInstanceId") {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ReplyId") {
            self.replyId = dict["ReplyId"] as! Int64
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SaveFormRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SaveFormRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveFormRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveFormRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEmployeeFieldValuesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchEmployeeFieldValuesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SearchEmployeeFieldValuesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchEmployeeFieldValuesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchEmployeeFieldValuesRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var searchFieldJson: String?

    public var systemToken: String?

    public var targetFieldJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.targetFieldJson != nil {
            map["TargetFieldJson"] = self.targetFieldJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("SearchFieldJson") {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TargetFieldJson") {
            self.targetFieldJson = dict["TargetFieldJson"] as! String
        }
    }
}

public class SearchEmployeeFieldValuesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchEmployeeFieldValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEmployeeFieldValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchEmployeeFieldValuesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDataIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDataIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SearchFormDataIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDataIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDataIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDataIdListResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            self.data = dict["data"] as! [String]
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDataIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDataIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchFormDataIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDataSecondGenerationHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDataSecondGenerationHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SearchFormDataSecondGenerationHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDataSecondGenerationShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var orderConfigJson: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchCondition: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.orderConfigJson != nil {
            map["OrderConfigJson"] = self.orderConfigJson!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchCondition != nil {
            map["SearchCondition"] = self.searchCondition!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OrderConfigJson") {
            self.orderConfigJson = dict["OrderConfigJson"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchCondition") {
            self.searchCondition = dict["SearchCondition"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationResponseBody.Data.ModifyUser.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    var model = SearchFormDataSecondGenerationResponseBody.Data.ModifyUser.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationResponseBody.Data.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    var model = SearchFormDataSecondGenerationResponseBody.Data.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var id: Int64?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var modifier: String?

        public var modifyUser: SearchFormDataSecondGenerationResponseBody.Data.ModifyUser?

        public var originator: SearchFormDataSecondGenerationResponseBody.Data.Originator?

        public var sequence: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormData") {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceValue") {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Modifier") {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("ModifyUser") {
                var model = SearchFormDataSecondGenerationResponseBody.Data.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") {
                var model = SearchFormDataSecondGenerationResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [SearchFormDataSecondGenerationResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [SearchFormDataSecondGenerationResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = SearchFormDataSecondGenerationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDataSecondGenerationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchFormDataSecondGenerationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDataSecondGenerationNoTableFieldHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SearchFormDataSecondGenerationNoTableFieldHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var orderConfigJson: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchCondition: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.orderConfigJson != nil {
            map["OrderConfigJson"] = self.orderConfigJson!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchCondition != nil {
            map["SearchCondition"] = self.searchCondition!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OrderConfigJson") {
            self.orderConfigJson = dict["OrderConfigJson"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchCondition") {
            self.searchCondition = dict["SearchCondition"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var id: Int64?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var modifier: String?

        public var modifyUser: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser?

        public var originator: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator?

        public var sequence: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimeGMT") {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormData") {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceValue") {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Modifier") {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("ModifyUser") {
                var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") {
                var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [SearchFormDataSecondGenerationNoTableFieldResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [SearchFormDataSecondGenerationNoTableFieldResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDataSecondGenerationNoTableFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchFormDataSecondGenerationNoTableFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDatasHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDatasHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SearchFormDatasHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDatasShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDatasRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var currentPage: Int32?

    public var dynamicOrder: String?

    public var formUuid: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dynamicOrder != nil {
            map["DynamicOrder"] = self.dynamicOrder!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("DynamicOrder") {
            self.dynamicOrder = dict["DynamicOrder"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDatasResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class UserName : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var userId: String?

            public var userName: SearchFormDatasResponseBody.Data.ModifyUser.UserName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.userName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserName") {
                    var model = SearchFormDatasResponseBody.Data.ModifyUser.UserName()
                    model.fromMap(dict["UserName"] as! [String: Any])
                    self.userName = model
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class UserName : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var userId: String?

            public var userName: SearchFormDatasResponseBody.Data.Originator.UserName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.userName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserName") {
                    var model = SearchFormDatasResponseBody.Data.Originator.UserName()
                    model.fromMap(dict["UserName"] as! [String: Any])
                    self.userName = model
                }
            }
        }
        public var createdTimeGMT: String?

        public var creatorUserId: String?

        public var dataId: Int64?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var instanceValue: String?

        public var modelUuid: String?

        public var modifiedTimeGMT: String?

        public var modifierUserId: String?

        public var modifyUser: SearchFormDatasResponseBody.Data.ModifyUser?

        public var originator: SearchFormDatasResponseBody.Data.Originator?

        public var sequence: String?

        public var serialNo: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTimeGMT != nil {
                map["CreatedTimeGMT"] = self.createdTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modelUuid != nil {
                map["ModelUuid"] = self.modelUuid!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifierUserId != nil {
                map["ModifierUserId"] = self.modifierUserId!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNo != nil {
                map["SerialNo"] = self.serialNo!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTimeGMT") {
                self.createdTimeGMT = dict["CreatedTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("DataId") {
                self.dataId = dict["DataId"] as! Int64
            }
            if dict.keys.contains("FormData") {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceValue") {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModelUuid") {
                self.modelUuid = dict["ModelUuid"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("ModifierUserId") {
                self.modifierUserId = dict["ModifierUserId"] as! String
            }
            if dict.keys.contains("ModifyUser") {
                var model = SearchFormDatasResponseBody.Data.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") {
                var model = SearchFormDatasResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNo") {
                self.serialNo = dict["SerialNo"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var currentPage: Int32?

    public var data: [SearchFormDatasResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("data") {
            var tmp : [SearchFormDatasResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = SearchFormDatasResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDatasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDatasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchFormDatasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchInnerGroupsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchInnerGroupsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SearchInnerGroupsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchInnerGroupsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchInnerGroupsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var searchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
    }
}

public class SearchInnerGroupsResponseBody : Tea.TeaModel {
    public class GroupInfos : Tea.TeaModel {
        public var icon: String?

        public var memberAmount: String?

        public var openConversationId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.memberAmount != nil {
                map["MemberAmount"] = self.memberAmount!
            }
            if self.openConversationId != nil {
                map["OpenConversationId"] = self.openConversationId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Icon") {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("MemberAmount") {
                self.memberAmount = dict["MemberAmount"] as! String
            }
            if dict.keys.contains("OpenConversationId") {
                self.openConversationId = dict["OpenConversationId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var groupInfos: [SearchInnerGroupsResponseBody.GroupInfos]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupInfos != nil {
            var tmp : [Any] = []
            for k in self.groupInfos! {
                tmp.append(k.toMap())
            }
            map["groupInfos"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("groupInfos") {
            var tmp : [SearchInnerGroupsResponseBody.GroupInfos] = []
            for v in dict["groupInfos"] as! [Any] {
                var model = SearchInnerGroupsResponseBody.GroupInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupInfos = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchInnerGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchInnerGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchInnerGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendBannerHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SendBannerHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SendBannerHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SendBannerShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SendBannerRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: SendBannerRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = SendBannerRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SendBannerShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SendBannerResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SendBannerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendBannerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendBannerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendPopupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SendPopupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SendPopupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SendPopupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SendPopupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: SendPopupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = SendPopupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SendPopupShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SendPopupResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SendPopupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendPopupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendPopupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendSearchShadeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SendSearchShadeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SendSearchShadeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SendSearchShadeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SendSearchShadeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: SendSearchShadeRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = SendSearchShadeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SendSearchShadeShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SendSearchShadeResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SendSearchShadeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendSearchShadeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendSearchShadeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetColumnsVisibilityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetColumnsVisibilityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SetColumnsVisibilityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetColumnsVisibilityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetColumnsVisibilityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: SetColumnsVisibilityRequest.TenantContext?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SetColumnsVisibilityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetColumnsVisibilityShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetColumnsVisibilityResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SetColumnsVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetColumnsVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetColumnsVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetConferenceHostsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetConferenceHostsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SetConferenceHostsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetConferenceHostsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetConferenceHostsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var operationType: String?

    public var tenantContext: SetConferenceHostsRequest.TenantContext?

    public var userIds: [String]?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SetConferenceHostsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! [String]
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class SetConferenceHostsShrinkRequest : Tea.TeaModel {
    public var operationType: String?

    public var tenantContextShrink: String?

    public var userIdsShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userIdsShrink != nil {
            map["UserIds"] = self.userIdsShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserIds") {
            self.userIdsShrink = dict["UserIds"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class SetConferenceHostsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SetConferenceHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetConferenceHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetConferenceHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetRowsVisibilityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetRowsVisibilityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SetRowsVisibilityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetRowsVisibilityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetRowsVisibilityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: SetRowsVisibilityRequest.TenantContext?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SetRowsVisibilityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetRowsVisibilityShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetRowsVisibilityResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SetRowsVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetRowsVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetRowsVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SimpleListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SimpleListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SimpleListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SimpleListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SimpleListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var cursor: Int64?

    public var endTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContext: SimpleListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SimpleListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SimpleListReportShrinkRequest : Tea.TeaModel {
    public var cursor: Int64?

    public var endTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SimpleListReportResponseBody : Tea.TeaModel {
    public class DataList : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorId: String?

        public var creatorName: String?

        public var deptName: String?

        public var remark: String?

        public var reportId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DeptName") {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ReportId") {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var dataList: [SimpleListReportResponseBody.DataList]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataList != nil {
            var tmp : [Any] = []
            for k in self.dataList! {
                tmp.append(k.toMap())
            }
            map["dataList"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataList") {
            var tmp : [SimpleListReportResponseBody.DataList] = []
            for v in dict["dataList"] as! [Any] {
                var model = SimpleListReportResponseBody.DataList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataList = tmp
        }
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int64
        }
    }
}

public class SimpleListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SimpleListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SimpleListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartCloudRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StartCloudRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StartCloudRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StartCloudRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StartCloudRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var mode: String?

    public var smallWindowPosition: String?

    public var tenantContext: StartCloudRecordRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.smallWindowPosition != nil {
            map["SmallWindowPosition"] = self.smallWindowPosition!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SmallWindowPosition") {
            self.smallWindowPosition = dict["SmallWindowPosition"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = StartCloudRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StartCloudRecordShrinkRequest : Tea.TeaModel {
    public var mode: String?

    public var smallWindowPosition: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.smallWindowPosition != nil {
            map["SmallWindowPosition"] = self.smallWindowPosition!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SmallWindowPosition") {
            self.smallWindowPosition = dict["SmallWindowPosition"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StartCloudRecordResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StartCloudRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCloudRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartCloudRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StartInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StartInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StartInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StartInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var departmentId: String?

    public var formDataJson: String?

    public var formUuid: String?

    public var language: String?

    public var processCode: String?

    public var processData: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.departmentId != nil {
            map["DepartmentId"] = self.departmentId!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processCode != nil {
            map["ProcessCode"] = self.processCode!
        }
        if self.processData != nil {
            map["ProcessData"] = self.processData!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("DepartmentId") {
            self.departmentId = dict["DepartmentId"] as! String
        }
        if dict.keys.contains("FormDataJson") {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("FormUuid") {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessCode") {
            self.processCode = dict["ProcessCode"] as! String
        }
        if dict.keys.contains("ProcessData") {
            self.processData = dict["ProcessData"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class StartInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class StartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartMinutesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StartMinutesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StartMinutesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StartMinutesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StartMinutesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: StartMinutesRequest.TenantContext?

    public var conferenceId: String?

    public var ownerUserId: String?

    public var recordAudio: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.ownerUserId != nil {
            map["ownerUserId"] = self.ownerUserId!
        }
        if self.recordAudio != nil {
            map["recordAudio"] = self.recordAudio!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = StartMinutesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("ownerUserId") {
            self.ownerUserId = dict["ownerUserId"] as! String
        }
        if dict.keys.contains("recordAudio") {
            self.recordAudio = dict["recordAudio"] as! Bool
        }
    }
}

public class StartMinutesShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public var ownerUserId: String?

    public var recordAudio: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.ownerUserId != nil {
            map["ownerUserId"] = self.ownerUserId!
        }
        if self.recordAudio != nil {
            map["recordAudio"] = self.recordAudio!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("ownerUserId") {
            self.ownerUserId = dict["ownerUserId"] as! String
        }
        if dict.keys.contains("recordAudio") {
            self.recordAudio = dict["recordAudio"] as! Bool
        }
    }
}

public class StartMinutesResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class StartMinutesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartMinutesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartMinutesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StatisticsListByTypeReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StatisticsListByTypeReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StatisticsListByTypeReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StatisticsListByTypeReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StatisticsListByTypeReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: StatisticsListByTypeReportRequest.TenantContext?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = StatisticsListByTypeReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class StatisticsListByTypeReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class StatisticsListByTypeReportResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var useridList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.useridList != nil {
            map["useridList"] = self.useridList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("useridList") {
            self.useridList = dict["useridList"] as! [String]
        }
    }
}

public class StatisticsListByTypeReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StatisticsListByTypeReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StatisticsListByTypeReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StatisticsReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StatisticsReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StatisticsReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StatisticsReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StatisticsReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var reportId: String?

    public var tenantContext: StatisticsReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = StatisticsReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class StatisticsReportShrinkRequest : Tea.TeaModel {
    public var reportId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class StatisticsReportResponseBody : Tea.TeaModel {
    public var commentNum: Int64?

    public var commentUserNum: Int64?

    public var likeNum: Int64?

    public var readNum: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentNum != nil {
            map["commentNum"] = self.commentNum!
        }
        if self.commentUserNum != nil {
            map["commentUserNum"] = self.commentUserNum!
        }
        if self.likeNum != nil {
            map["likeNum"] = self.likeNum!
        }
        if self.readNum != nil {
            map["readNum"] = self.readNum!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commentNum") {
            self.commentNum = dict["commentNum"] as! Int64
        }
        if dict.keys.contains("commentUserNum") {
            self.commentUserNum = dict["commentUserNum"] as! Int64
        }
        if dict.keys.contains("likeNum") {
            self.likeNum = dict["likeNum"] as! Int64
        }
        if dict.keys.contains("readNum") {
            self.readNum = dict["readNum"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StatisticsReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StatisticsReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StatisticsReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopCloudRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StopCloudRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StopCloudRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StopCloudRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StopCloudRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: StopCloudRecordRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = StopCloudRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopCloudRecordShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopCloudRecordResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StopCloudRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCloudRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopCloudRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopMinutesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StopMinutesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = StopMinutesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StopMinutesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StopMinutesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: StopMinutesRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = StopMinutesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopMinutesShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopMinutesResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class StopMinutesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopMinutesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopMinutesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubscribeCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SubscribeCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SubscribeCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SubscribeCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SubscribeCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class SubscribeCalendarResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SubscribeCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubscribeCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubscribeCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubscribeEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SubscribeEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SubscribeEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SubscribeEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SubscribeEventRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var scope: String?

    public var scopeId: String?

    public var tenantContext: SubscribeEventRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeId != nil {
            map["ScopeId"] = self.scopeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeId") {
            self.scopeId = dict["ScopeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SubscribeEventRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SubscribeEventShrinkRequest : Tea.TeaModel {
    public var scope: String?

    public var scopeId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeId != nil {
            map["ScopeId"] = self.scopeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeId") {
            self.scopeId = dict["ScopeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SubscribeEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SubscribeEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubscribeEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubscribeEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncDingTypeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SyncDingTypeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = SyncDingTypeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SyncDingTypeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SyncDingTypeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dingType: String?

    public var isDimission: String?

    public var source: String?

    public var tenantContext: SyncDingTypeRequest.TenantContext?

    public var workNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dingType != nil {
            map["DingType"] = self.dingType!
        }
        if self.isDimission != nil {
            map["IsDimission"] = self.isDimission!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workNo != nil {
            map["WorkNo"] = self.workNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DingType") {
            self.dingType = dict["DingType"] as! String
        }
        if dict.keys.contains("IsDimission") {
            self.isDimission = dict["IsDimission"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = SyncDingTypeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkNo") {
            self.workNo = dict["WorkNo"] as! String
        }
    }
}

public class SyncDingTypeShrinkRequest : Tea.TeaModel {
    public var dingType: String?

    public var isDimission: String?

    public var source: String?

    public var tenantContextShrink: String?

    public var workNo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dingType != nil {
            map["DingType"] = self.dingType!
        }
        if self.isDimission != nil {
            map["IsDimission"] = self.isDimission!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workNo != nil {
            map["WorkNo"] = self.workNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DingType") {
            self.dingType = dict["DingType"] as! String
        }
        if dict.keys.contains("IsDimission") {
            self.isDimission = dict["IsDimission"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkNo") {
            self.workNo = dict["WorkNo"] as! String
        }
    }
}

public class SyncDingTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SyncDingTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncDingTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SyncDingTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: TerminateInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = TerminateInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class TerminateInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class TerminateInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class TerminateInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class TerminateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferTicketHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: TransferTicketHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = TransferTicketHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class TransferTicketShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class TransferTicketRequest : Tea.TeaModel {
    public class Notify : Tea.TeaModel {
        public var groupNoticeReceiverUserIds: [String]?

        public var noticeAllGroupMember: Bool?

        public var workNoticeReceiverUserIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupNoticeReceiverUserIds != nil {
                map["GroupNoticeReceiverUserIds"] = self.groupNoticeReceiverUserIds!
            }
            if self.noticeAllGroupMember != nil {
                map["NoticeAllGroupMember"] = self.noticeAllGroupMember!
            }
            if self.workNoticeReceiverUserIds != nil {
                map["WorkNoticeReceiverUserIds"] = self.workNoticeReceiverUserIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupNoticeReceiverUserIds") {
                self.groupNoticeReceiverUserIds = dict["GroupNoticeReceiverUserIds"] as! [String]
            }
            if dict.keys.contains("NoticeAllGroupMember") {
                self.noticeAllGroupMember = dict["NoticeAllGroupMember"] as! Bool
            }
            if dict.keys.contains("WorkNoticeReceiverUserIds") {
                self.workNoticeReceiverUserIds = dict["WorkNoticeReceiverUserIds"] as! [String]
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class TicketMemo : Tea.TeaModel {
        public class Attachments : Tea.TeaModel {
            public var fileName: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
            }
        }
        public var attachments: [TransferTicketRequest.TicketMemo.Attachments]?

        public var memo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachments != nil {
                var tmp : [Any] = []
                for k in self.attachments! {
                    tmp.append(k.toMap())
                }
                map["Attachments"] = tmp
            }
            if self.memo != nil {
                map["Memo"] = self.memo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attachments") {
                var tmp : [TransferTicketRequest.TicketMemo.Attachments] = []
                for v in dict["Attachments"] as! [Any] {
                    var model = TransferTicketRequest.TicketMemo.Attachments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachments = tmp
            }
            if dict.keys.contains("Memo") {
                self.memo = dict["Memo"] as! String
            }
        }
    }
    public var notify: TransferTicketRequest.Notify?

    public var openTeamId: String?

    public var openTicketId: String?

    public var processorUserIds: [String]?

    public var tenantContext: TransferTicketRequest.TenantContext?

    public var ticketMemo: TransferTicketRequest.TicketMemo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notify?.validate()
        try self.tenantContext?.validate()
        try self.ticketMemo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notify != nil {
            map["Notify"] = self.notify?.toMap()
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.processorUserIds != nil {
            map["ProcessorUserIds"] = self.processorUserIds!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.ticketMemo != nil {
            map["TicketMemo"] = self.ticketMemo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Notify") {
            var model = TransferTicketRequest.Notify()
            model.fromMap(dict["Notify"] as! [String: Any])
            self.notify = model
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("ProcessorUserIds") {
            self.processorUserIds = dict["ProcessorUserIds"] as! [String]
        }
        if dict.keys.contains("TenantContext") {
            var model = TransferTicketRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("TicketMemo") {
            var model = TransferTicketRequest.TicketMemo()
            model.fromMap(dict["TicketMemo"] as! [String: Any])
            self.ticketMemo = model
        }
    }
}

public class TransferTicketShrinkRequest : Tea.TeaModel {
    public var notifyShrink: String?

    public var openTeamId: String?

    public var openTicketId: String?

    public var processorUserIdsShrink: String?

    public var tenantContextShrink: String?

    public var ticketMemoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notifyShrink != nil {
            map["Notify"] = self.notifyShrink!
        }
        if self.openTeamId != nil {
            map["OpenTeamId"] = self.openTeamId!
        }
        if self.openTicketId != nil {
            map["OpenTicketId"] = self.openTicketId!
        }
        if self.processorUserIdsShrink != nil {
            map["ProcessorUserIds"] = self.processorUserIdsShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.ticketMemoShrink != nil {
            map["TicketMemo"] = self.ticketMemoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Notify") {
            self.notifyShrink = dict["Notify"] as! String
        }
        if dict.keys.contains("OpenTeamId") {
            self.openTeamId = dict["OpenTeamId"] as! String
        }
        if dict.keys.contains("OpenTicketId") {
            self.openTicketId = dict["OpenTicketId"] as! String
        }
        if dict.keys.contains("ProcessorUserIds") {
            self.processorUserIdsShrink = dict["ProcessorUserIds"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("TicketMemo") {
            self.ticketMemoShrink = dict["TicketMemo"] as! String
        }
    }
}

public class TransferTicketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class TransferTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnsubscribeCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UnsubscribeCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UnsubscribeCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UnsubscribeCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UnsubscribeCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class UnsubscribeCalendarResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UnsubscribeCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnsubscribeCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnsubscribeCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnsubscribeEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UnsubscribeEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UnsubscribeEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UnsubscribeEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UnsubscribeEventRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var scope: String?

    public var scopeId: String?

    public var tenantContext: UnsubscribeEventRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeId != nil {
            map["ScopeId"] = self.scopeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeId") {
            self.scopeId = dict["ScopeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = UnsubscribeEventRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UnsubscribeEventShrinkRequest : Tea.TeaModel {
    public var scope: String?

    public var scopeId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.scopeId != nil {
            map["ScopeId"] = self.scopeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("ScopeId") {
            self.scopeId = dict["ScopeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UnsubscribeEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UnsubscribeEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnsubscribeEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnsubscribeEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceId: String?

    public var language: String?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public var useLatestVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        if self.useLatestVersion != nil {
            map["UseLatestVersion"] = self.useLatestVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceId") {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
        if dict.keys.contains("UseLatestVersion") {
            self.useLatestVersion = dict["UseLatestVersion"] as! Bool
        }
    }
}

public class UpdateFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
    }
}

public class UpdateInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var coverUrl: String?

    public var introduction: String?

    public var liveId: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var tenantContext: UpdateLiveRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PreEndTime") {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateLiveShrinkRequest : Tea.TeaModel {
    public var coverUrl: String?

    public var introduction: String?

    public var liveId: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("LiveId") {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PreEndTime") {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateLiveResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateMeetingRoomRequest : Tea.TeaModel {
    public class ReservationAuthority : Tea.TeaModel {
        public class AuthorizedMembers : Tea.TeaModel {
            public var memberId: String?

            public var memberName: String?

            public var memberType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.memberType != nil {
                    map["MemberType"] = self.memberType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemberId") {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("MemberType") {
                    self.memberType = dict["MemberType"] as! String
                }
            }
        }
        public var authorizedMembers: [UpdateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedMembers != nil {
                var tmp : [Any] = []
                for k in self.authorizedMembers! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedMembers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedMembers") {
                var tmp : [UpdateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers] = []
                for v in dict["AuthorizedMembers"] as! [Any] {
                    var model = UpdateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedMembers = tmp
            }
        }
    }
    public class RoomLocation : Tea.TeaModel {
        public var desc: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthority: UpdateMeetingRoomRequest.ReservationAuthority?

    public var roomCapacity: Int32?

    public var roomId: String?

    public var roomLabelIds: [Int64]?

    public var roomLocation: UpdateMeetingRoomRequest.RoomLocation?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContext: UpdateMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservationAuthority?.validate()
        try self.roomLocation?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthority != nil {
            map["ReservationAuthority"] = self.reservationAuthority?.toMap()
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomLabelIds != nil {
            map["RoomLabelIds"] = self.roomLabelIds!
        }
        if self.roomLocation != nil {
            map["RoomLocation"] = self.roomLocation?.toMap()
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") {
            var model = UpdateMeetingRoomRequest.ReservationAuthority()
            model.fromMap(dict["ReservationAuthority"] as! [String: Any])
            self.reservationAuthority = model
        }
        if dict.keys.contains("RoomCapacity") {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomLabelIds") {
            self.roomLabelIds = dict["RoomLabelIds"] as! [Int64]
        }
        if dict.keys.contains("RoomLocation") {
            var model = UpdateMeetingRoomRequest.RoomLocation()
            model.fromMap(dict["RoomLocation"] as! [String: Any])
            self.roomLocation = model
        }
        if dict.keys.contains("RoomName") {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateMeetingRoomShrinkRequest : Tea.TeaModel {
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthorityShrink: String?

    public var roomCapacity: Int32?

    public var roomId: String?

    public var roomLabelIdsShrink: String?

    public var roomLocationShrink: String?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthorityShrink != nil {
            map["ReservationAuthority"] = self.reservationAuthorityShrink!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomLabelIdsShrink != nil {
            map["RoomLabelIds"] = self.roomLabelIdsShrink!
        }
        if self.roomLocationShrink != nil {
            map["RoomLocation"] = self.roomLocationShrink!
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") {
            self.reservationAuthorityShrink = dict["ReservationAuthority"] as! String
        }
        if dict.keys.contains("RoomCapacity") {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomLabelIds") {
            self.roomLabelIdsShrink = dict["RoomLabelIds"] as! String
        }
        if dict.keys.contains("RoomLocation") {
            self.roomLocationShrink = dict["RoomLocation"] as! String
        }
        if dict.keys.contains("RoomName") {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateMeetingRoomResponseBody : Tea.TeaModel {
    public var result: Bool?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var groupName: String?

    public var tenantContext: UpdateMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRangeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateRangeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateRangeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateRangeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateRangeRequest : Tea.TeaModel {
    public class Hyperlinks : Tea.TeaModel {
        public var type: String?

        public var link: String?

        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Link") {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Text") {
                self.text = dict["Text"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var backgroundColors: [[String]]?

    public var hyperlinks: [[UpdateRangeRequest.Hyperlinks]]?

    public var numberFormat: String?

    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: UpdateRangeRequest.TenantContext?

    public var values: [[String]]?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColors != nil {
            map["BackgroundColors"] = self.backgroundColors!
        }
        if self.hyperlinks != nil {
            var tmp : [Any] = []
            for k in self.hyperlinks! {
                var l1 : [Any] = []
                for k1 in k {
                    l1.append(k1.toMap())
                }
                tmp.append(l1)
            }
            map["Hyperlinks"] = tmp
        }
        if self.numberFormat != nil {
            map["NumberFormat"] = self.numberFormat!
        }
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackgroundColors") {
            self.backgroundColors = dict["BackgroundColors"] as! [[String]]
        }
        if dict.keys.contains("Hyperlinks") {
            var tmp : [[UpdateRangeRequest.Hyperlinks]] = []
            for v in dict["Hyperlinks"] as! [Any] {
                var l1 : [UpdateRangeRequest.Hyperlinks] = []
                for v1 in v as! [Any] {
                    var model = UpdateRangeRequest.Hyperlinks()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp.append(l1)
            }
            self.hyperlinks = tmp
        }
        if dict.keys.contains("NumberFormat") {
            self.numberFormat = dict["NumberFormat"] as! String
        }
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateRangeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Values") {
            self.values = dict["Values"] as! [[String]]
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class UpdateRangeShrinkRequest : Tea.TeaModel {
    public var backgroundColorsShrink: String?

    public var hyperlinksShrink: String?

    public var numberFormat: String?

    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var valuesShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColorsShrink != nil {
            map["BackgroundColors"] = self.backgroundColorsShrink!
        }
        if self.hyperlinksShrink != nil {
            map["Hyperlinks"] = self.hyperlinksShrink!
        }
        if self.numberFormat != nil {
            map["NumberFormat"] = self.numberFormat!
        }
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.valuesShrink != nil {
            map["Values"] = self.valuesShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackgroundColors") {
            self.backgroundColorsShrink = dict["BackgroundColors"] as! String
        }
        if dict.keys.contains("Hyperlinks") {
            self.hyperlinksShrink = dict["Hyperlinks"] as! String
        }
        if dict.keys.contains("NumberFormat") {
            self.numberFormat = dict["NumberFormat"] as! String
        }
        if dict.keys.contains("RangeAddress") {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Values") {
            self.valuesShrink = dict["Values"] as! String
        }
        if dict.keys.contains("WorkbookId") {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class UpdateRangeResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScheduleConfSettingsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateScheduleConfSettingsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateScheduleConfSettingsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateScheduleConfSettingsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateScheduleConfSettingsRequest : Tea.TeaModel {
    public class ScheduleConfSettingModel : Tea.TeaModel {
        public class MoziConfOpenRecordSetting : Tea.TeaModel {
            public var isFollowHost: Bool?

            public var mode: String?

            public var recordAutoStart: Int32?

            public var recordAutoStartType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isFollowHost != nil {
                    map["IsFollowHost"] = self.isFollowHost!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.recordAutoStart != nil {
                    map["RecordAutoStart"] = self.recordAutoStart!
                }
                if self.recordAutoStartType != nil {
                    map["RecordAutoStartType"] = self.recordAutoStartType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsFollowHost") {
                    self.isFollowHost = dict["IsFollowHost"] as! Bool
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("RecordAutoStart") {
                    self.recordAutoStart = dict["RecordAutoStart"] as! Int32
                }
                if dict.keys.contains("RecordAutoStartType") {
                    self.recordAutoStartType = dict["RecordAutoStartType"] as! Int32
                }
            }
        }
        public class MoziConfVirtualExtraSetting : Tea.TeaModel {
            public class MoziConfExtensionAppSettings : Tea.TeaModel {
                public var autoOpenMode: Int32?

                public var coolAppCode: String?

                public var extensionAppBizData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoOpenMode != nil {
                        map["AutoOpenMode"] = self.autoOpenMode!
                    }
                    if self.coolAppCode != nil {
                        map["CoolAppCode"] = self.coolAppCode!
                    }
                    if self.extensionAppBizData != nil {
                        map["ExtensionAppBizData"] = self.extensionAppBizData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoOpenMode") {
                        self.autoOpenMode = dict["AutoOpenMode"] as! Int32
                    }
                    if dict.keys.contains("CoolAppCode") {
                        self.coolAppCode = dict["CoolAppCode"] as! String
                    }
                    if dict.keys.contains("ExtensionAppBizData") {
                        self.extensionAppBizData = dict["ExtensionAppBizData"] as! String
                    }
                }
            }
            public var cloudRecordOwnerUserId: String?

            public var enableChat: Int32?

            public var enableWebAnonymousJoin: Bool?

            public var joinBeforeHost: Int32?

            public var lockMediaStatusMicMute: Int32?

            public var lockNick: Int32?

            public var minutesOwnerUserId: String?

            public var moziConfExtensionAppSettings: [UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting.MoziConfExtensionAppSettings]?

            public var pushAllMeetingRecords: Bool?

            public var pushCloudRecordCard: Bool?

            public var pushMinutesCard: Bool?

            public var waitingRoom: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cloudRecordOwnerUserId != nil {
                    map["CloudRecordOwnerUserId"] = self.cloudRecordOwnerUserId!
                }
                if self.enableChat != nil {
                    map["EnableChat"] = self.enableChat!
                }
                if self.enableWebAnonymousJoin != nil {
                    map["EnableWebAnonymousJoin"] = self.enableWebAnonymousJoin!
                }
                if self.joinBeforeHost != nil {
                    map["JoinBeforeHost"] = self.joinBeforeHost!
                }
                if self.lockMediaStatusMicMute != nil {
                    map["LockMediaStatusMicMute"] = self.lockMediaStatusMicMute!
                }
                if self.lockNick != nil {
                    map["LockNick"] = self.lockNick!
                }
                if self.minutesOwnerUserId != nil {
                    map["MinutesOwnerUserId"] = self.minutesOwnerUserId!
                }
                if self.moziConfExtensionAppSettings != nil {
                    var tmp : [Any] = []
                    for k in self.moziConfExtensionAppSettings! {
                        tmp.append(k.toMap())
                    }
                    map["MoziConfExtensionAppSettings"] = tmp
                }
                if self.pushAllMeetingRecords != nil {
                    map["PushAllMeetingRecords"] = self.pushAllMeetingRecords!
                }
                if self.pushCloudRecordCard != nil {
                    map["PushCloudRecordCard"] = self.pushCloudRecordCard!
                }
                if self.pushMinutesCard != nil {
                    map["PushMinutesCard"] = self.pushMinutesCard!
                }
                if self.waitingRoom != nil {
                    map["WaitingRoom"] = self.waitingRoom!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CloudRecordOwnerUserId") {
                    self.cloudRecordOwnerUserId = dict["CloudRecordOwnerUserId"] as! String
                }
                if dict.keys.contains("EnableChat") {
                    self.enableChat = dict["EnableChat"] as! Int32
                }
                if dict.keys.contains("EnableWebAnonymousJoin") {
                    self.enableWebAnonymousJoin = dict["EnableWebAnonymousJoin"] as! Bool
                }
                if dict.keys.contains("JoinBeforeHost") {
                    self.joinBeforeHost = dict["JoinBeforeHost"] as! Int32
                }
                if dict.keys.contains("LockMediaStatusMicMute") {
                    self.lockMediaStatusMicMute = dict["LockMediaStatusMicMute"] as! Int32
                }
                if dict.keys.contains("LockNick") {
                    self.lockNick = dict["LockNick"] as! Int32
                }
                if dict.keys.contains("MinutesOwnerUserId") {
                    self.minutesOwnerUserId = dict["MinutesOwnerUserId"] as! String
                }
                if dict.keys.contains("MoziConfExtensionAppSettings") {
                    var tmp : [UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting.MoziConfExtensionAppSettings] = []
                    for v in dict["MoziConfExtensionAppSettings"] as! [Any] {
                        var model = UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting.MoziConfExtensionAppSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.moziConfExtensionAppSettings = tmp
                }
                if dict.keys.contains("PushAllMeetingRecords") {
                    self.pushAllMeetingRecords = dict["PushAllMeetingRecords"] as! Bool
                }
                if dict.keys.contains("PushCloudRecordCard") {
                    self.pushCloudRecordCard = dict["PushCloudRecordCard"] as! Bool
                }
                if dict.keys.contains("PushMinutesCard") {
                    self.pushMinutesCard = dict["PushMinutesCard"] as! Bool
                }
                if dict.keys.contains("WaitingRoom") {
                    self.waitingRoom = dict["WaitingRoom"] as! Int32
                }
            }
        }
        public var cohostUserIds: [String]?

        public var confAllowedCorpId: String?

        public var hostUserId: String?

        public var lockRoom: Int32?

        public var moziConfOpenRecordSetting: UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfOpenRecordSetting?

        public var moziConfVirtualExtraSetting: UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting?

        public var muteOnJoin: Int32?

        public var screenShareForbidden: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.moziConfOpenRecordSetting?.validate()
            try self.moziConfVirtualExtraSetting?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cohostUserIds != nil {
                map["CohostUserIds"] = self.cohostUserIds!
            }
            if self.confAllowedCorpId != nil {
                map["ConfAllowedCorpId"] = self.confAllowedCorpId!
            }
            if self.hostUserId != nil {
                map["HostUserId"] = self.hostUserId!
            }
            if self.lockRoom != nil {
                map["LockRoom"] = self.lockRoom!
            }
            if self.moziConfOpenRecordSetting != nil {
                map["MoziConfOpenRecordSetting"] = self.moziConfOpenRecordSetting?.toMap()
            }
            if self.moziConfVirtualExtraSetting != nil {
                map["MoziConfVirtualExtraSetting"] = self.moziConfVirtualExtraSetting?.toMap()
            }
            if self.muteOnJoin != nil {
                map["MuteOnJoin"] = self.muteOnJoin!
            }
            if self.screenShareForbidden != nil {
                map["ScreenShareForbidden"] = self.screenShareForbidden!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CohostUserIds") {
                self.cohostUserIds = dict["CohostUserIds"] as! [String]
            }
            if dict.keys.contains("ConfAllowedCorpId") {
                self.confAllowedCorpId = dict["ConfAllowedCorpId"] as! String
            }
            if dict.keys.contains("HostUserId") {
                self.hostUserId = dict["HostUserId"] as! String
            }
            if dict.keys.contains("LockRoom") {
                self.lockRoom = dict["LockRoom"] as! Int32
            }
            if dict.keys.contains("MoziConfOpenRecordSetting") {
                var model = UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfOpenRecordSetting()
                model.fromMap(dict["MoziConfOpenRecordSetting"] as! [String: Any])
                self.moziConfOpenRecordSetting = model
            }
            if dict.keys.contains("MoziConfVirtualExtraSetting") {
                var model = UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel.MoziConfVirtualExtraSetting()
                model.fromMap(dict["MoziConfVirtualExtraSetting"] as! [String: Any])
                self.moziConfVirtualExtraSetting = model
            }
            if dict.keys.contains("MuteOnJoin") {
                self.muteOnJoin = dict["MuteOnJoin"] as! Int32
            }
            if dict.keys.contains("ScreenShareForbidden") {
                self.screenShareForbidden = dict["ScreenShareForbidden"] as! Int32
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var scheduleConfSettingModel: UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel?

    public var scheduleConferenceId: String?

    public var tenantContext: UpdateScheduleConfSettingsRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scheduleConfSettingModel?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConfSettingModel != nil {
            map["ScheduleConfSettingModel"] = self.scheduleConfSettingModel?.toMap()
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConfSettingModel") {
            var model = UpdateScheduleConfSettingsRequest.ScheduleConfSettingModel()
            model.fromMap(dict["ScheduleConfSettingModel"] as! [String: Any])
            self.scheduleConfSettingModel = model
        }
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateScheduleConfSettingsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateScheduleConfSettingsShrinkRequest : Tea.TeaModel {
    public var scheduleConfSettingModelShrink: String?

    public var scheduleConferenceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConfSettingModelShrink != nil {
            map["ScheduleConfSettingModel"] = self.scheduleConfSettingModelShrink!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConfSettingModel") {
            self.scheduleConfSettingModelShrink = dict["ScheduleConfSettingModel"] as! String
        }
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateScheduleConfSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateScheduleConfSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScheduleConfSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateScheduleConfSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var tenantContext: UpdateScheduleConferenceRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConferenceId") {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateScheduleConferenceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateStatusHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateStatusHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateStatusHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateStatusShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateStatusRequest : Tea.TeaModel {
    public var appType: String?

    public var errorLines: [Int32]?

    public var importSequence: String?

    public var language: String?

    public var status: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.errorLines != nil {
            map["ErrorLines"] = self.errorLines!
        }
        if self.importSequence != nil {
            map["ImportSequence"] = self.importSequence!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ErrorLines") {
            self.errorLines = dict["ErrorLines"] as! [Int32]
        }
        if dict.keys.contains("ImportSequence") {
            self.importSequence = dict["ImportSequence"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class UpdateStatusShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var errorLinesShrink: String?

    public var importSequence: String?

    public var language: String?

    public var status: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.errorLinesShrink != nil {
            map["ErrorLines"] = self.errorLinesShrink!
        }
        if self.importSequence != nil {
            map["ImportSequence"] = self.importSequence!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ErrorLines") {
            self.errorLinesShrink = dict["ErrorLines"] as! String
        }
        if dict.keys.contains("ImportSequence") {
            self.importSequence = dict["ImportSequence"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemToken") {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class UpdateStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSubscribedCalendarsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateSubscribedCalendarsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateSubscribedCalendarsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateSubscribedCalendarsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateSubscribedCalendarsRequest : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserIds") {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var calendarId: String?

    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var subscribeScope: UpdateSubscribedCalendarsRequest.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScope != nil {
            map["SubscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") {
            self.managers = dict["Managers"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") {
            var model = UpdateSubscribedCalendarsRequest.SubscribeScope()
            model.fromMap(dict["SubscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class UpdateSubscribedCalendarsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var description_: String?

    public var managersShrink: String?

    public var name: String?

    public var subscribeScopeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScopeShrink != nil {
            map["SubscribeScope"] = self.subscribeScopeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") {
            self.managersShrink = dict["Managers"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") {
            self.subscribeScopeShrink = dict["SubscribeScope"] as! String
        }
    }
}

public class UpdateSubscribedCalendarsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateSubscribedCalendarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSubscribedCalendarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSubscribedCalendarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: UpdateTodoTaskRequest.TenantContext?

    public var description_: String?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var participantIds: [String]?

    public var subject: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = UpdateTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("done") {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("participantIds") {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var description_: String?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var participantIdsShrink: String?

    public var subject: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["executorIds"] = self.executorIdsShrink!
        }
        if self.participantIdsShrink != nil {
            map["participantIds"] = self.participantIdsShrink!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("done") {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") {
            self.executorIdsShrink = dict["executorIds"] as! String
        }
        if dict.keys.contains("participantIds") {
            self.participantIdsShrink = dict["participantIds"] as! String
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTodoTaskExecutorStatusHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateTodoTaskExecutorStatusHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateTodoTaskExecutorStatusHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateTodoTaskExecutorStatusShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class ExecutorStatusList : Tea.TeaModel {
        public var id: String?

        public var isDone: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isDone") {
                self.isDone = dict["isDone"] as! Bool
            }
        }
    }
    public var tenantContext: UpdateTodoTaskExecutorStatusRequest.TenantContext?

    public var executorStatusList: [UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList]?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.executorStatusList != nil {
            var tmp : [Any] = []
            for k in self.executorStatusList! {
                tmp.append(k.toMap())
            }
            map["executorStatusList"] = tmp
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = UpdateTodoTaskExecutorStatusRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("executorStatusList") {
            var tmp : [UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList] = []
            for v in dict["executorStatusList"] as! [Any] {
                var model = UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.executorStatusList = tmp
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var executorStatusListShrink: String?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.executorStatusListShrink != nil {
            map["executorStatusList"] = self.executorStatusListShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("executorStatusList") {
            self.executorStatusListShrink = dict["executorStatusList"] as! String
        }
        if dict.keys.contains("operatorId") {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateTodoTaskExecutorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTodoTaskExecutorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTodoTaskExecutorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserAvatarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateUserAvatarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateUserAvatarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateUserAvatarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateUserAvatarRequest : Tea.TeaModel {
    public var avatarMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarMediaId != nil {
            map["AvatarMediaId"] = self.avatarMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarMediaId") {
            self.avatarMediaId = dict["AvatarMediaId"] as! String
        }
    }
}

public class UpdateUserAvatarResponseBody : Tea.TeaModel {
    public var errcode: String?

    public var errmsg: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errcode != nil {
            map["errcode"] = self.errcode!
        }
        if self.errmsg != nil {
            map["errmsg"] = self.errmsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errcode") {
            self.errcode = dict["errcode"] as! String
        }
        if dict.keys.contains("errmsg") {
            self.errmsg = dict["errmsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateUserAvatarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserAvatarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateUserAvatarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVideoConferenceSettingHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateVideoConferenceSettingHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateVideoConferenceSettingHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateVideoConferenceSettingShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateVideoConferenceSettingRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var allowUnmuteSelf: Bool?

    public var autoTransferHost: Bool?

    public var forbiddenShareScreen: Bool?

    public var lockConference: Bool?

    public var muteAll: Bool?

    public var onlyInternalEmployeesJoin: Bool?

    public var tenantContext: UpdateVideoConferenceSettingRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowUnmuteSelf != nil {
            map["AllowUnmuteSelf"] = self.allowUnmuteSelf!
        }
        if self.autoTransferHost != nil {
            map["AutoTransferHost"] = self.autoTransferHost!
        }
        if self.forbiddenShareScreen != nil {
            map["ForbiddenShareScreen"] = self.forbiddenShareScreen!
        }
        if self.lockConference != nil {
            map["LockConference"] = self.lockConference!
        }
        if self.muteAll != nil {
            map["MuteAll"] = self.muteAll!
        }
        if self.onlyInternalEmployeesJoin != nil {
            map["OnlyInternalEmployeesJoin"] = self.onlyInternalEmployeesJoin!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowUnmuteSelf") {
            self.allowUnmuteSelf = dict["AllowUnmuteSelf"] as! Bool
        }
        if dict.keys.contains("AutoTransferHost") {
            self.autoTransferHost = dict["AutoTransferHost"] as! Bool
        }
        if dict.keys.contains("ForbiddenShareScreen") {
            self.forbiddenShareScreen = dict["ForbiddenShareScreen"] as! Bool
        }
        if dict.keys.contains("LockConference") {
            self.lockConference = dict["LockConference"] as! Bool
        }
        if dict.keys.contains("MuteAll") {
            self.muteAll = dict["MuteAll"] as! Bool
        }
        if dict.keys.contains("OnlyInternalEmployeesJoin") {
            self.onlyInternalEmployeesJoin = dict["OnlyInternalEmployeesJoin"] as! Bool
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateVideoConferenceSettingRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class UpdateVideoConferenceSettingShrinkRequest : Tea.TeaModel {
    public var allowUnmuteSelf: Bool?

    public var autoTransferHost: Bool?

    public var forbiddenShareScreen: Bool?

    public var lockConference: Bool?

    public var muteAll: Bool?

    public var onlyInternalEmployeesJoin: Bool?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowUnmuteSelf != nil {
            map["AllowUnmuteSelf"] = self.allowUnmuteSelf!
        }
        if self.autoTransferHost != nil {
            map["AutoTransferHost"] = self.autoTransferHost!
        }
        if self.forbiddenShareScreen != nil {
            map["ForbiddenShareScreen"] = self.forbiddenShareScreen!
        }
        if self.lockConference != nil {
            map["LockConference"] = self.lockConference!
        }
        if self.muteAll != nil {
            map["MuteAll"] = self.muteAll!
        }
        if self.onlyInternalEmployeesJoin != nil {
            map["OnlyInternalEmployeesJoin"] = self.onlyInternalEmployeesJoin!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowUnmuteSelf") {
            self.allowUnmuteSelf = dict["AllowUnmuteSelf"] as! Bool
        }
        if dict.keys.contains("AutoTransferHost") {
            self.autoTransferHost = dict["AutoTransferHost"] as! Bool
        }
        if dict.keys.contains("ForbiddenShareScreen") {
            self.forbiddenShareScreen = dict["ForbiddenShareScreen"] as! Bool
        }
        if dict.keys.contains("LockConference") {
            self.lockConference = dict["LockConference"] as! Bool
        }
        if dict.keys.contains("MuteAll") {
            self.muteAll = dict["MuteAll"] as! Bool
        }
        if dict.keys.contains("OnlyInternalEmployeesJoin") {
            self.onlyInternalEmployeesJoin = dict["OnlyInternalEmployeesJoin"] as! Bool
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class UpdateVideoConferenceSettingResponseBody : Tea.TeaModel {
    public var caseResult: String?

    public var code: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.caseResult != nil {
            map["caseResult"] = self.caseResult!
        }
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("caseResult") {
            self.caseResult = dict["caseResult"] as! String
        }
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateVideoConferenceSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVideoConferenceSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVideoConferenceSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [UpdateWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: UpdateWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [UpdateWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = UpdateWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UpdateWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [UpdateWorkspaceMembersRequest.Members]?

    public var tenantContext: UpdateWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            var tmp : [UpdateWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = UpdateWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") {
            var model = UpdateWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UploadMediaHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = UploadMediaHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UploadMediaShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UploadMediaRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: UploadMediaRequest.TenantContext?

    public var mediaName: String?

    public var mediaType: String?

    public var orgId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.mediaName != nil {
            map["mediaName"] = self.mediaName!
        }
        if self.mediaType != nil {
            map["mediaType"] = self.mediaType!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = UploadMediaRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("mediaName") {
            self.mediaName = dict["mediaName"] as! String
        }
        if dict.keys.contains("mediaType") {
            self.mediaType = dict["mediaType"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
    }
}

public class UploadMediaShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var mediaName: String?

    public var mediaType: String?

    public var orgId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.mediaName != nil {
            map["mediaName"] = self.mediaName!
        }
        if self.mediaType != nil {
            map["mediaType"] = self.mediaType!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("mediaName") {
            self.mediaName = dict["mediaName"] as! String
        }
        if dict.keys.contains("mediaType") {
            self.mediaType = dict["mediaType"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
    }
}

public class UploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["mediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("mediaId") {
            self.mediaId = dict["mediaId"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WearOrgHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: WearOrgHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            var model = WearOrgHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class WearOrgHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class WearOrgHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: WearOrgHonorRequest.TenantContext?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public var wear: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.wear != nil {
            map["wear"] = self.wear!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            var model = WearOrgHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("wear") {
            self.wear = dict["wear"] as! Bool
        }
    }
}

public class WearOrgHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public var wear: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.wear != nil {
            map["wear"] = self.wear!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("honorId") {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("wear") {
            self.wear = dict["wear"] as! Bool
        }
    }
}

public class WearOrgHonorResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: WearOrgHonorResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            var model = WearOrgHonorResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class WearOrgHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WearOrgHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WearOrgHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
