import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddAttendeeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddAttendeeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddAttendeeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddAttendeeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddAttendeeRequest : Tea.TeaModel {
    public class AttendeesToAdd : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") && dict["isOptional"] != nil {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public var attendeesToAdd: [AddAttendeeRequest.AttendeesToAdd]?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToAdd != nil {
            var tmp : [Any] = []
            for k in self.attendeesToAdd! {
                tmp.append(k.toMap())
            }
            map["AttendeesToAdd"] = tmp
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToAdd") && dict["AttendeesToAdd"] != nil {
            var tmp : [AddAttendeeRequest.AttendeesToAdd] = []
            for v in dict["AttendeesToAdd"] as! [Any] {
                var model = AddAttendeeRequest.AttendeesToAdd()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendeesToAdd = tmp
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class AddAttendeeShrinkRequest : Tea.TeaModel {
    public var attendeesToAddShrink: String?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToAddShrink != nil {
            map["AttendeesToAdd"] = self.attendeesToAddShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToAdd") && dict["AttendeesToAdd"] != nil {
            self.attendeesToAddShrink = dict["AttendeesToAdd"] as! String
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class AddAttendeeResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! Any
            }
        }
    }
    public var content: AddAttendeeResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["ErrorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            var model = AddAttendeeResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorCtx") && dict["ErrorCtx"] != nil {
            self.errorCtx = dict["ErrorCtx"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAttendeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAttendeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAttendeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMeetingRoomsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddMeetingRoomsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddMeetingRoomsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddMeetingRoomsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddMeetingRoomsRequest : Tea.TeaModel {
    public class MeetingRoomsToAdd : Tea.TeaModel {
        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToAdd: [AddMeetingRoomsRequest.MeetingRoomsToAdd]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToAdd != nil {
            var tmp : [Any] = []
            for k in self.meetingRoomsToAdd! {
                tmp.append(k.toMap())
            }
            map["MeetingRoomsToAdd"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToAdd") && dict["MeetingRoomsToAdd"] != nil {
            var tmp : [AddMeetingRoomsRequest.MeetingRoomsToAdd] = []
            for v in dict["MeetingRoomsToAdd"] as! [Any] {
                var model = AddMeetingRoomsRequest.MeetingRoomsToAdd()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRoomsToAdd = tmp
        }
    }
}

public class AddMeetingRoomsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToAddShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToAddShrink != nil {
            map["MeetingRoomsToAdd"] = self.meetingRoomsToAddShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToAdd") && dict["MeetingRoomsToAdd"] != nil {
            self.meetingRoomsToAddShrink = dict["MeetingRoomsToAdd"] as! String
        }
    }
}

public class AddMeetingRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class AddMeetingRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMeetingRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddMeetingRoomsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddScenegroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddScenegroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddScenegroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddScenegroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddScenegroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") && dict["OpenConversationId"] != nil {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class AddScenegroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddScenegroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddScenegroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddScenegroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var description_: String?

        public var teamId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var option: AddWorkspaceRequest.Option?

    public var tenantContext: AddWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = AddWorkspaceRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = AddWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class AddWorkspaceShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var optionShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class AddWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: AddWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = AddWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: AddWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var model = AddWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class AddWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [AddWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: AddWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [AddWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = AddWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [AddWorkspaceMembersRequest.Members]?

    public var tenantContext: AddWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [AddWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = AddWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceMembersResponseBody : Tea.TeaModel {
    public var notInOrgList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notInOrgList != nil {
            map["NotInOrgList"] = self.notInOrgList!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotInOrgList") && dict["NotInOrgList"] != nil {
            self.notInOrgList = dict["NotInOrgList"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CancelScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CancelScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CancelScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CancelScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var scheduleConferenceId: String?

    public var tenantContext: CancelScheduleConferenceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CancelScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CancelScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var scheduleConferenceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CancelScheduleConferenceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CancelScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ClearHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ClearHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ClearShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ClearRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: ClearRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ClearRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") && dict["a1Notation"] != nil {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ClearResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ClearResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ClearDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ClearDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ClearDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ClearDataRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: ClearDataRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ClearDataRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearDataShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearDataResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") && dict["a1Notation"] != nil {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ClearDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ClearDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CommentListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CommentListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CommentListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CommentListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CommentListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: CommentListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CommentListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CommentListReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CommentListReportResponseBody : Tea.TeaModel {
    public class Comments : Tea.TeaModel {
        public var content: String?

        public var createTime: String?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.userid != nil {
                map["Userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Userid") && dict["Userid"] != nil {
                self.userid = dict["Userid"] as! String
            }
        }
    }
    public var comments: [CommentListReportResponseBody.Comments]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comments != nil {
            var tmp : [Any] = []
            for k in self.comments! {
                tmp.append(k.toMap())
            }
            map["comments"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("comments") && dict["comments"] != nil {
            var tmp : [CommentListReportResponseBody.Comments] = []
            for v in dict["comments"] as! [Any] {
                var model = CommentListReportResponseBody.Comments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.comments = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CommentListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CommentListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CommentListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateEventRequest : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") && dict["isOptional"] != nil {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayName") && dict["displayName"] != nil {
                self.displayName = dict["displayName"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("type") && dict["type"] != nil {
                self.type = dict["type"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["dayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["daysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.interval != nil {
                    map["interval"] = self.interval!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dayOfMonth") && dict["dayOfMonth"] != nil {
                    self.dayOfMonth = dict["dayOfMonth"] as! Int32
                }
                if dict.keys.contains("daysOfWeek") && dict["daysOfWeek"] != nil {
                    self.daysOfWeek = dict["daysOfWeek"] as! String
                }
                if dict.keys.contains("index") && dict["index"] != nil {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("interval") && dict["interval"] != nil {
                    self.interval = dict["interval"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["endDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["numberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("endDate") && dict["endDate"] != nil {
                    self.endDate = dict["endDate"] as! String
                }
                if dict.keys.contains("numberOfOccurrences") && dict["numberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["numberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var pattern: CreateEventRequest.Recurrence.Pattern?

        public var range: CreateEventRequest.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("pattern") && dict["pattern"] != nil {
                var model = CreateEventRequest.Recurrence.Pattern()
                model.fromMap(dict["pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("range") && dict["range"] != nil {
                var model = CreateEventRequest.Recurrence.Range()
                model.fromMap(dict["range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["method"] = self.method!
            }
            if self.minutes != nil {
                map["minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("method") && dict["method"] != nil {
                self.method = dict["method"] as! String
            }
            if dict.keys.contains("minutes") && dict["minutes"] != nil {
                self.minutes = dict["minutes"] as! Int32
            }
        }
    }
    public class UiConfigs : Tea.TeaModel {
        public var uiName: String?

        public var uiStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uiName != nil {
                map["uiName"] = self.uiName!
            }
            if self.uiStatus != nil {
                map["uiStatus"] = self.uiStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("uiName") && dict["uiName"] != nil {
                self.uiName = dict["uiName"] as! String
            }
            if dict.keys.contains("uiStatus") && dict["uiStatus"] != nil {
                self.uiStatus = dict["uiStatus"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public var attendees: [CreateEventRequest.Attendees]?

    public var description_: String?

    public var end: CreateEventRequest.End?

    public var extra: [String: String]?

    public var isAllDay: Bool?

    public var location: CreateEventRequest.Location?

    public var onlineMeetingInfo: CreateEventRequest.OnlineMeetingInfo?

    public var recurrence: CreateEventRequest.Recurrence?

    public var reminders: [CreateEventRequest.Reminders]?

    public var summary: String?

    public var uiConfigs: [CreateEventRequest.UiConfigs]?

    public var calendarId: String?

    public var start: CreateEventRequest.Start?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["Attendees"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.end != nil {
            map["End"] = self.end?.toMap()
        }
        if self.extra != nil {
            map["Extra"] = self.extra!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["Location"] = self.location?.toMap()
        }
        if self.onlineMeetingInfo != nil {
            map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["Reminders"] = tmp
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.uiConfigs != nil {
            var tmp : [Any] = []
            for k in self.uiConfigs! {
                tmp.append(k.toMap())
            }
            map["UiConfigs"] = tmp
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            var tmp : [CreateEventRequest.Attendees] = []
            for v in dict["Attendees"] as! [Any] {
                var model = CreateEventRequest.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            var model = CreateEventRequest.End()
            model.fromMap(dict["End"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extra = dict["Extra"] as! [String: String]
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            var model = CreateEventRequest.Location()
            model.fromMap(dict["Location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
            var model = CreateEventRequest.OnlineMeetingInfo()
            model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            var model = CreateEventRequest.Recurrence()
            model.fromMap(dict["Recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            var tmp : [CreateEventRequest.Reminders] = []
            for v in dict["Reminders"] as! [Any] {
                var model = CreateEventRequest.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("UiConfigs") && dict["UiConfigs"] != nil {
            var tmp : [CreateEventRequest.UiConfigs] = []
            for v in dict["UiConfigs"] as! [Any] {
                var model = CreateEventRequest.UiConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uiConfigs = tmp
        }
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = CreateEventRequest.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
    }
}

public class CreateEventShrinkRequest : Tea.TeaModel {
    public var attendeesShrink: String?

    public var description_: String?

    public var endShrink: String?

    public var extraShrink: String?

    public var isAllDay: Bool?

    public var locationShrink: String?

    public var onlineMeetingInfoShrink: String?

    public var recurrenceShrink: String?

    public var remindersShrink: String?

    public var summary: String?

    public var uiConfigsShrink: String?

    public var calendarId: String?

    public var startShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesShrink != nil {
            map["Attendees"] = self.attendeesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endShrink != nil {
            map["End"] = self.endShrink!
        }
        if self.extraShrink != nil {
            map["Extra"] = self.extraShrink!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.locationShrink != nil {
            map["Location"] = self.locationShrink!
        }
        if self.onlineMeetingInfoShrink != nil {
            map["OnlineMeetingInfo"] = self.onlineMeetingInfoShrink!
        }
        if self.recurrenceShrink != nil {
            map["Recurrence"] = self.recurrenceShrink!
        }
        if self.remindersShrink != nil {
            map["Reminders"] = self.remindersShrink!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.uiConfigsShrink != nil {
            map["UiConfigs"] = self.uiConfigsShrink!
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.startShrink != nil {
            map["start"] = self.startShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            self.attendeesShrink = dict["Attendees"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            self.endShrink = dict["End"] as! String
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extraShrink = dict["Extra"] as! String
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            self.locationShrink = dict["Location"] as! String
        }
        if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
            self.onlineMeetingInfoShrink = dict["OnlineMeetingInfo"] as! String
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            self.recurrenceShrink = dict["Recurrence"] as! String
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            self.remindersShrink = dict["Reminders"] as! String
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("UiConfigs") && dict["UiConfigs"] != nil {
            self.uiConfigsShrink = dict["UiConfigs"] as! String
        }
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            self.startShrink = dict["start"] as! String
        }
    }
}

public class CreateEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var conferenceId: String?

        public var extraInfo: [String: Any]?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: CreateEventResponseBody.Recurrence.Pattern?

        public var range: CreateEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                var model = CreateEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                var model = CreateEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class UiConfigs : Tea.TeaModel {
        public var uiName: String?

        public var uiStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uiName != nil {
                map["UiName"] = self.uiName!
            }
            if self.uiStatus != nil {
                map["UiStatus"] = self.uiStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UiName") && dict["UiName"] != nil {
                self.uiName = dict["UiName"] as! String
            }
            if dict.keys.contains("UiStatus") && dict["UiStatus"] != nil {
                self.uiStatus = dict["UiStatus"] as! String
            }
        }
    }
    public var attendees: [CreateEventResponseBody.Attendees]?

    public var createTime: String?

    public var description_: String?

    public var end: CreateEventResponseBody.End?

    public var id: String?

    public var isAllDay: Bool?

    public var location: CreateEventResponseBody.Location?

    public var onlineMeetingInfo: CreateEventResponseBody.OnlineMeetingInfo?

    public var organizer: CreateEventResponseBody.Organizer?

    public var recurrence: CreateEventResponseBody.Recurrence?

    public var reminders: [CreateEventResponseBody.Reminders]?

    public var requestId: String?

    public var start: CreateEventResponseBody.Start?

    public var summary: String?

    public var uiConfigs: [CreateEventResponseBody.UiConfigs]?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.organizer?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.onlineMeetingInfo != nil {
            map["onlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.uiConfigs != nil {
            var tmp : [Any] = []
            for k in self.uiConfigs! {
                tmp.append(k.toMap())
            }
            map["uiConfigs"] = tmp
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") && dict["attendees"] != nil {
            var tmp : [CreateEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = CreateEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") && dict["end"] != nil {
            var model = CreateEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") && dict["isAllDay"] != nil {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") && dict["location"] != nil {
            var model = CreateEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("onlineMeetingInfo") && dict["onlineMeetingInfo"] != nil {
            var model = CreateEventResponseBody.OnlineMeetingInfo()
            model.fromMap(dict["onlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("organizer") && dict["organizer"] != nil {
            var model = CreateEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("recurrence") && dict["recurrence"] != nil {
            var model = CreateEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") && dict["reminders"] != nil {
            var tmp : [CreateEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = CreateEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = CreateEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("summary") && dict["summary"] != nil {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("uiConfigs") && dict["uiConfigs"] != nil {
            var tmp : [CreateEventResponseBody.UiConfigs] = []
            for v in dict["uiConfigs"] as! [Any] {
                var model = CreateEventResponseBody.UiConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uiConfigs = tmp
        }
        if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class CreateEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var coverUrl: String?

    public var introduction: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var publicType: Int64?

    public var tenantContext: CreateLiveRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.publicType != nil {
            map["PublicType"] = self.publicType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("PublicType") && dict["PublicType"] != nil {
            self.publicType = dict["PublicType"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateLiveShrinkRequest : Tea.TeaModel {
    public var coverUrl: String?

    public var introduction: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var publicType: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.publicType != nil {
            map["PublicType"] = self.publicType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("PublicType") && dict["PublicType"] != nil {
            self.publicType = dict["PublicType"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateLiveResponseBody : Tea.TeaModel {
    public var liveId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("liveId") && dict["liveId"] != nil {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateMeetingRoomRequest : Tea.TeaModel {
    public class RoomLocation : Tea.TeaModel {
        public var desc: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: Int64?

    public var isvRoomId: String?

    public var roomCapacity: Int32?

    public var roomLabelIds: [Int64]?

    public var roomLocation: CreateMeetingRoomRequest.RoomLocation?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContext: CreateMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.roomLocation?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomLabelIds != nil {
            map["RoomLabelIds"] = self.roomLabelIds!
        }
        if self.roomLocation != nil {
            map["RoomLocation"] = self.roomLocation?.toMap()
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIds = dict["RoomLabelIds"] as! [Int64]
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            var model = CreateMeetingRoomRequest.RoomLocation()
            model.fromMap(dict["RoomLocation"] as! [String: Any])
            self.roomLocation = model
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateMeetingRoomShrinkRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var isvRoomId: String?

    public var roomCapacity: Int32?

    public var roomLabelIdsShrink: String?

    public var roomLocationShrink: String?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomLabelIdsShrink != nil {
            map["RoomLabelIds"] = self.roomLabelIdsShrink!
        }
        if self.roomLocationShrink != nil {
            map["RoomLocation"] = self.roomLocationShrink!
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIdsShrink = dict["RoomLabelIds"] as! String
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            self.roomLocationShrink = dict["RoomLocation"] as! String
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateMeetingRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
    }
}

public class CreateMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupName: String?

    public var parentGroupId: Int64?

    public var tenantContext: CreateMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ParentGroupId") && dict["ParentGroupId"] != nil {
            self.parentGroupId = dict["ParentGroupId"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupName: String?

    public var parentGroupId: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ParentGroupId") && dict["ParentGroupId"] != nil {
            self.parentGroupId = dict["ParentGroupId"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Int64
        }
    }
}

public class CreateMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrgHonorTemplateHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateOrgHonorTemplateHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateOrgHonorTemplateHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateOrgHonorTemplateShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateOrgHonorTemplateRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: CreateOrgHonorTemplateRequest.TenantContext?

    public var avatarFrameMediaId: String?

    public var defaultBgColor: String?

    public var medalDesc: String?

    public var medalMediaId: String?

    public var medalName: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.avatarFrameMediaId != nil {
            map["avatarFrameMediaId"] = self.avatarFrameMediaId!
        }
        if self.defaultBgColor != nil {
            map["defaultBgColor"] = self.defaultBgColor!
        }
        if self.medalDesc != nil {
            map["medalDesc"] = self.medalDesc!
        }
        if self.medalMediaId != nil {
            map["medalMediaId"] = self.medalMediaId!
        }
        if self.medalName != nil {
            map["medalName"] = self.medalName!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateOrgHonorTemplateRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("avatarFrameMediaId") && dict["avatarFrameMediaId"] != nil {
            self.avatarFrameMediaId = dict["avatarFrameMediaId"] as! String
        }
        if dict.keys.contains("defaultBgColor") && dict["defaultBgColor"] != nil {
            self.defaultBgColor = dict["defaultBgColor"] as! String
        }
        if dict.keys.contains("medalDesc") && dict["medalDesc"] != nil {
            self.medalDesc = dict["medalDesc"] as! String
        }
        if dict.keys.contains("medalMediaId") && dict["medalMediaId"] != nil {
            self.medalMediaId = dict["medalMediaId"] as! String
        }
        if dict.keys.contains("medalName") && dict["medalName"] != nil {
            self.medalName = dict["medalName"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var avatarFrameMediaId: String?

    public var defaultBgColor: String?

    public var medalDesc: String?

    public var medalMediaId: String?

    public var medalName: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.avatarFrameMediaId != nil {
            map["avatarFrameMediaId"] = self.avatarFrameMediaId!
        }
        if self.defaultBgColor != nil {
            map["defaultBgColor"] = self.defaultBgColor!
        }
        if self.medalDesc != nil {
            map["medalDesc"] = self.medalDesc!
        }
        if self.medalMediaId != nil {
            map["medalMediaId"] = self.medalMediaId!
        }
        if self.medalName != nil {
            map["medalName"] = self.medalName!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("avatarFrameMediaId") && dict["avatarFrameMediaId"] != nil {
            self.avatarFrameMediaId = dict["avatarFrameMediaId"] as! String
        }
        if dict.keys.contains("defaultBgColor") && dict["defaultBgColor"] != nil {
            self.defaultBgColor = dict["defaultBgColor"] as! String
        }
        if dict.keys.contains("medalDesc") && dict["medalDesc"] != nil {
            self.medalDesc = dict["medalDesc"] as! String
        }
        if dict.keys.contains("medalMediaId") && dict["medalMediaId"] != nil {
            self.medalMediaId = dict["medalMediaId"] as! String
        }
        if dict.keys.contains("medalName") && dict["medalName"] != nil {
            self.medalName = dict["medalName"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateResponseBody : Tea.TeaModel {
    public var honorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrgHonorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrgHonorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateReportRequest : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var content: String?

        public var contentType: String?

        public var key: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var contents: [CreateReportRequest.Contents]?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContext: CreateReportRequest.TenantContext?

    public var toChat: Bool?

    public var toCids: [String]?

    public var toUserids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.toChat != nil {
            map["ToChat"] = self.toChat!
        }
        if self.toCids != nil {
            map["ToCids"] = self.toCids!
        }
        if self.toUserids != nil {
            map["ToUserids"] = self.toUserids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            var tmp : [CreateReportRequest.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = CreateReportRequest.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("ToChat") && dict["ToChat"] != nil {
            self.toChat = dict["ToChat"] as! Bool
        }
        if dict.keys.contains("ToCids") && dict["ToCids"] != nil {
            self.toCids = dict["ToCids"] as! [String]
        }
        if dict.keys.contains("ToUserids") && dict["ToUserids"] != nil {
            self.toUserids = dict["ToUserids"] as! [String]
        }
    }
}

public class CreateReportShrinkRequest : Tea.TeaModel {
    public var contentsShrink: String?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContextShrink: String?

    public var toChat: Bool?

    public var toCidsShrink: String?

    public var toUseridsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentsShrink != nil {
            map["Contents"] = self.contentsShrink!
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.toChat != nil {
            map["ToChat"] = self.toChat!
        }
        if self.toCidsShrink != nil {
            map["ToCids"] = self.toCidsShrink!
        }
        if self.toUseridsShrink != nil {
            map["ToUserids"] = self.toUseridsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            self.contentsShrink = dict["Contents"] as! String
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("ToChat") && dict["ToChat"] != nil {
            self.toChat = dict["ToChat"] as! Bool
        }
        if dict.keys.contains("ToCids") && dict["ToCids"] != nil {
            self.toCidsShrink = dict["ToCids"] as! String
        }
        if dict.keys.contains("ToUserids") && dict["ToUserids"] != nil {
            self.toUseridsShrink = dict["ToUserids"] as! String
        }
    }
}

public class CreateReportResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScenegroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateScenegroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateScenegroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateScenegroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateScenegroupRequest : Tea.TeaModel {
    public var addFriendForbidden: Int64?

    public var allMembersCanCreateCalendar: Int64?

    public var allMembersCanCreateMcsConf: Int64?

    public var chatBannedType: Int64?

    public var groupEmailDisabled: Int64?

    public var groupLiveSwitch: Int64?

    public var icon: String?

    public var managementType: Int64?

    public var membersToAdminChat: Int64?

    public var mentionAllAuthority: Int64?

    public var onlyAdminCanDing: Int64?

    public var onlyAdminCanSetMsgTop: Int64?

    public var searchable: Int64?

    public var showHistoryType: Int64?

    public var subadminIds: String?

    public var templateId: String?

    public var title: String?

    public var userIds: String?

    public var uuid: String?

    public var validationType: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addFriendForbidden != nil {
            map["AddFriendForbidden"] = self.addFriendForbidden!
        }
        if self.allMembersCanCreateCalendar != nil {
            map["AllMembersCanCreateCalendar"] = self.allMembersCanCreateCalendar!
        }
        if self.allMembersCanCreateMcsConf != nil {
            map["AllMembersCanCreateMcsConf"] = self.allMembersCanCreateMcsConf!
        }
        if self.chatBannedType != nil {
            map["ChatBannedType"] = self.chatBannedType!
        }
        if self.groupEmailDisabled != nil {
            map["GroupEmailDisabled"] = self.groupEmailDisabled!
        }
        if self.groupLiveSwitch != nil {
            map["GroupLiveSwitch"] = self.groupLiveSwitch!
        }
        if self.icon != nil {
            map["Icon"] = self.icon!
        }
        if self.managementType != nil {
            map["ManagementType"] = self.managementType!
        }
        if self.membersToAdminChat != nil {
            map["MembersToAdminChat"] = self.membersToAdminChat!
        }
        if self.mentionAllAuthority != nil {
            map["MentionAllAuthority"] = self.mentionAllAuthority!
        }
        if self.onlyAdminCanDing != nil {
            map["OnlyAdminCanDing"] = self.onlyAdminCanDing!
        }
        if self.onlyAdminCanSetMsgTop != nil {
            map["OnlyAdminCanSetMsgTop"] = self.onlyAdminCanSetMsgTop!
        }
        if self.searchable != nil {
            map["Searchable"] = self.searchable!
        }
        if self.showHistoryType != nil {
            map["ShowHistoryType"] = self.showHistoryType!
        }
        if self.subadminIds != nil {
            map["SubadminIds"] = self.subadminIds!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.validationType != nil {
            map["ValidationType"] = self.validationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddFriendForbidden") && dict["AddFriendForbidden"] != nil {
            self.addFriendForbidden = dict["AddFriendForbidden"] as! Int64
        }
        if dict.keys.contains("AllMembersCanCreateCalendar") && dict["AllMembersCanCreateCalendar"] != nil {
            self.allMembersCanCreateCalendar = dict["AllMembersCanCreateCalendar"] as! Int64
        }
        if dict.keys.contains("AllMembersCanCreateMcsConf") && dict["AllMembersCanCreateMcsConf"] != nil {
            self.allMembersCanCreateMcsConf = dict["AllMembersCanCreateMcsConf"] as! Int64
        }
        if dict.keys.contains("ChatBannedType") && dict["ChatBannedType"] != nil {
            self.chatBannedType = dict["ChatBannedType"] as! Int64
        }
        if dict.keys.contains("GroupEmailDisabled") && dict["GroupEmailDisabled"] != nil {
            self.groupEmailDisabled = dict["GroupEmailDisabled"] as! Int64
        }
        if dict.keys.contains("GroupLiveSwitch") && dict["GroupLiveSwitch"] != nil {
            self.groupLiveSwitch = dict["GroupLiveSwitch"] as! Int64
        }
        if dict.keys.contains("Icon") && dict["Icon"] != nil {
            self.icon = dict["Icon"] as! String
        }
        if dict.keys.contains("ManagementType") && dict["ManagementType"] != nil {
            self.managementType = dict["ManagementType"] as! Int64
        }
        if dict.keys.contains("MembersToAdminChat") && dict["MembersToAdminChat"] != nil {
            self.membersToAdminChat = dict["MembersToAdminChat"] as! Int64
        }
        if dict.keys.contains("MentionAllAuthority") && dict["MentionAllAuthority"] != nil {
            self.mentionAllAuthority = dict["MentionAllAuthority"] as! Int64
        }
        if dict.keys.contains("OnlyAdminCanDing") && dict["OnlyAdminCanDing"] != nil {
            self.onlyAdminCanDing = dict["OnlyAdminCanDing"] as! Int64
        }
        if dict.keys.contains("OnlyAdminCanSetMsgTop") && dict["OnlyAdminCanSetMsgTop"] != nil {
            self.onlyAdminCanSetMsgTop = dict["OnlyAdminCanSetMsgTop"] as! Int64
        }
        if dict.keys.contains("Searchable") && dict["Searchable"] != nil {
            self.searchable = dict["Searchable"] as! Int64
        }
        if dict.keys.contains("ShowHistoryType") && dict["ShowHistoryType"] != nil {
            self.showHistoryType = dict["ShowHistoryType"] as! Int64
        }
        if dict.keys.contains("SubadminIds") && dict["SubadminIds"] != nil {
            self.subadminIds = dict["SubadminIds"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("ValidationType") && dict["ValidationType"] != nil {
            self.validationType = dict["ValidationType"] as! Int64
        }
    }
}

public class CreateScenegroupResponseBody : Tea.TeaModel {
    public var openConversationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["openConversationId"] = self.openConversationId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("openConversationId") && dict["openConversationId"] != nil {
            self.openConversationId = dict["openConversationId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateScenegroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScenegroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScenegroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: CreateScheduleConferenceRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateScheduleConferenceResponseBody : Tea.TeaModel {
    public var phones: [String]?

    public var requestId: String?

    public var roomCode: String?

    public var scheduleConferenceId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.phones != nil {
            map["phones"] = self.phones!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("phones") && dict["phones"] != nil {
            self.phones = dict["phones"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") && dict["roomCode"] != nil {
            self.roomCode = dict["roomCode"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") && dict["scheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class CreateScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var tenantContext: CreateSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class CreateSheetShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class CreateSheetResponseBody : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var requestId: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.visibility != nil {
            map["visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("visibility") && dict["visibility"] != nil {
            self.visibility = dict["visibility"] as! String
        }
    }
}

public class CreateSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSubscribedCalendarRequest : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var subscribeScope: CreateSubscribedCalendarRequest.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScope != nil {
            map["SubscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managers = dict["Managers"] as! [String]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            var model = CreateSubscribedCalendarRequest.SubscribeScope()
            model.fromMap(dict["SubscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class CreateSubscribedCalendarShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var managersShrink: String?

    public var name: String?

    public var subscribeScopeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScopeShrink != nil {
            map["SubscribeScope"] = self.subscribeScopeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managersShrink = dict["Managers"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            self.subscribeScopeShrink = dict["SubscribeScope"] as! String
        }
    }
}

public class CreateSubscribedCalendarResponseBody : Tea.TeaModel {
    public var calendarId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class ContentFieldList : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") && dict["fieldKey"] != nil {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") && dict["fieldValue"] != nil {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["appUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUrl") && dict["appUrl"] != nil {
                self.appUrl = dict["appUrl"] as! String
            }
            if dict.keys.contains("pcUrl") && dict["pcUrl"] != nil {
                self.pcUrl = dict["pcUrl"] as! String
            }
        }
    }
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["dingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dingNotify") && dict["dingNotify"] != nil {
                self.dingNotify = dict["dingNotify"] as! String
            }
        }
    }
    public var tenantContext: CreateTodoTaskRequest.TenantContext?

    public var contentFieldList: [CreateTodoTaskRequest.ContentFieldList]?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: CreateTodoTaskRequest.DetailUrl?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var isOnlyShowExecutor: Bool?

    public var notifyConfigs: CreateTodoTaskRequest.NotifyConfigs?

    public var operatorId: String?

    public var participantIds: [String]?

    public var priority: Int32?

    public var sourceId: String?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
        try self.detailUrl?.validate()
        try self.notifyConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.contentFieldList != nil {
            var tmp : [Any] = []
            for k in self.contentFieldList! {
                tmp.append(k.toMap())
            }
            map["contentFieldList"] = tmp
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.notifyConfigs != nil {
            map["notifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("contentFieldList") && dict["contentFieldList"] != nil {
            var tmp : [CreateTodoTaskRequest.ContentFieldList] = []
            for v in dict["contentFieldList"] as! [Any] {
                var model = CreateTodoTaskRequest.ContentFieldList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contentFieldList = tmp
        }
        if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
            var model = CreateTodoTaskRequest.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("isOnlyShowExecutor") && dict["isOnlyShowExecutor"] != nil {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("notifyConfigs") && dict["notifyConfigs"] != nil {
            var model = CreateTodoTaskRequest.NotifyConfigs()
            model.fromMap(dict["notifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var contentFieldListShrink: String?

    public var creatorId: String?

    public var description_: String?

    public var detailUrlShrink: String?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var isOnlyShowExecutor: Bool?

    public var notifyConfigsShrink: String?

    public var operatorId: String?

    public var participantIdsShrink: String?

    public var priority: Int32?

    public var sourceId: String?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.contentFieldListShrink != nil {
            map["contentFieldList"] = self.contentFieldListShrink!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrlShrink != nil {
            map["detailUrl"] = self.detailUrlShrink!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["executorIds"] = self.executorIdsShrink!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.notifyConfigsShrink != nil {
            map["notifyConfigs"] = self.notifyConfigsShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.participantIdsShrink != nil {
            map["participantIds"] = self.participantIdsShrink!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("contentFieldList") && dict["contentFieldList"] != nil {
            self.contentFieldListShrink = dict["contentFieldList"] as! String
        }
        if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
            self.detailUrlShrink = dict["detailUrl"] as! String
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIdsShrink = dict["executorIds"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") && dict["isOnlyShowExecutor"] != nil {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("notifyConfigs") && dict["notifyConfigs"] != nil {
            self.notifyConfigsShrink = dict["notifyConfigs"] as! String
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIdsShrink = dict["participantIds"] as! String
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskResponseBody : Tea.TeaModel {
    public class ContentFieldList : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") && dict["fieldKey"] != nil {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") && dict["fieldValue"] != nil {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["appUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUrl") && dict["appUrl"] != nil {
                self.appUrl = dict["appUrl"] as! String
            }
            if dict.keys.contains("pcUrl") && dict["pcUrl"] != nil {
                self.pcUrl = dict["pcUrl"] as! String
            }
        }
    }
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["dingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dingNotify") && dict["dingNotify"] != nil {
                self.dingNotify = dict["dingNotify"] as! String
            }
        }
    }
    public var bizTag: String?

    public var contentFieldList: [CreateTodoTaskResponseBody.ContentFieldList]?

    public var createdTime: Int64?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: CreateTodoTaskResponseBody.DetailUrl?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var finishTime: Int64?

    public var id: String?

    public var isOnlyShowExecutor: Bool?

    public var modifiedTime: Int64?

    public var modifierId: String?

    public var notifyConfigs: CreateTodoTaskResponseBody.NotifyConfigs?

    public var participantIds: [String]?

    public var priority: Int32?

    public var requestId: String?

    public var source: String?

    public var sourceId: String?

    public var startTime: Int64?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailUrl?.validate()
        try self.notifyConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizTag != nil {
            map["bizTag"] = self.bizTag!
        }
        if self.contentFieldList != nil {
            var tmp : [Any] = []
            for k in self.contentFieldList! {
                tmp.append(k.toMap())
            }
            map["contentFieldList"] = tmp
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.finishTime != nil {
            map["finishTime"] = self.finishTime!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.modifiedTime != nil {
            map["modifiedTime"] = self.modifiedTime!
        }
        if self.modifierId != nil {
            map["modifierId"] = self.modifierId!
        }
        if self.notifyConfigs != nil {
            map["notifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("bizTag") && dict["bizTag"] != nil {
            self.bizTag = dict["bizTag"] as! String
        }
        if dict.keys.contains("contentFieldList") && dict["contentFieldList"] != nil {
            var tmp : [CreateTodoTaskResponseBody.ContentFieldList] = []
            for v in dict["contentFieldList"] as! [Any] {
                var model = CreateTodoTaskResponseBody.ContentFieldList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contentFieldList = tmp
        }
        if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
            var model = CreateTodoTaskResponseBody.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("done") && dict["done"] != nil {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("finishTime") && dict["finishTime"] != nil {
            self.finishTime = dict["finishTime"] as! Int64
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") && dict["isOnlyShowExecutor"] != nil {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("modifiedTime") && dict["modifiedTime"] != nil {
            self.modifiedTime = dict["modifiedTime"] as! Int64
        }
        if dict.keys.contains("modifierId") && dict["modifierId"] != nil {
            self.modifierId = dict["modifierId"] as! String
        }
        if dict.keys.contains("notifyConfigs") && dict["notifyConfigs"] != nil {
            var model = CreateTodoTaskResponseBody.NotifyConfigs()
            model.fromMap(dict["notifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("source") && dict["source"] != nil {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVideoConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateVideoConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateVideoConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateVideoConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateVideoConferenceRequest : Tea.TeaModel {
    public var confTitle: String?

    public var inviteCaller: Bool?

    public var inviteUserIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confTitle != nil {
            map["ConfTitle"] = self.confTitle!
        }
        if self.inviteCaller != nil {
            map["InviteCaller"] = self.inviteCaller!
        }
        if self.inviteUserIds != nil {
            map["InviteUserIds"] = self.inviteUserIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfTitle") && dict["ConfTitle"] != nil {
            self.confTitle = dict["ConfTitle"] as! String
        }
        if dict.keys.contains("InviteCaller") && dict["InviteCaller"] != nil {
            self.inviteCaller = dict["InviteCaller"] as! Bool
        }
        if dict.keys.contains("InviteUserIds") && dict["InviteUserIds"] != nil {
            self.inviteUserIds = dict["InviteUserIds"] as! [String]
        }
    }
}

public class CreateVideoConferenceShrinkRequest : Tea.TeaModel {
    public var confTitle: String?

    public var inviteCaller: Bool?

    public var inviteUserIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confTitle != nil {
            map["ConfTitle"] = self.confTitle!
        }
        if self.inviteCaller != nil {
            map["InviteCaller"] = self.inviteCaller!
        }
        if self.inviteUserIdsShrink != nil {
            map["InviteUserIds"] = self.inviteUserIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfTitle") && dict["ConfTitle"] != nil {
            self.confTitle = dict["ConfTitle"] as! String
        }
        if dict.keys.contains("InviteCaller") && dict["InviteCaller"] != nil {
            self.inviteCaller = dict["InviteCaller"] as! Bool
        }
        if dict.keys.contains("InviteUserIds") && dict["InviteUserIds"] != nil {
            self.inviteUserIdsShrink = dict["InviteUserIds"] as! String
        }
    }
}

public class CreateVideoConferenceResponseBody : Tea.TeaModel {
    public var conferenceId: String?

    public var conferencePassword: String?

    public var externalLinkUrl: String?

    public var hostPassword: String?

    public var phoneNumbers: [String]?

    public var requestId: String?

    public var roomCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.conferencePassword != nil {
            map["conferencePassword"] = self.conferencePassword!
        }
        if self.externalLinkUrl != nil {
            map["externalLinkUrl"] = self.externalLinkUrl!
        }
        if self.hostPassword != nil {
            map["hostPassword"] = self.hostPassword!
        }
        if self.phoneNumbers != nil {
            map["phoneNumbers"] = self.phoneNumbers!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("conferencePassword") && dict["conferencePassword"] != nil {
            self.conferencePassword = dict["conferencePassword"] as! String
        }
        if dict.keys.contains("externalLinkUrl") && dict["externalLinkUrl"] != nil {
            self.externalLinkUrl = dict["externalLinkUrl"] as! String
        }
        if dict.keys.contains("hostPassword") && dict["hostPassword"] != nil {
            self.hostPassword = dict["hostPassword"] as! String
        }
        if dict.keys.contains("phoneNumbers") && dict["phoneNumbers"] != nil {
            self.phoneNumbers = dict["phoneNumbers"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") && dict["roomCode"] != nil {
            self.roomCode = dict["roomCode"] as! String
        }
    }
}

public class CreateVideoConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVideoConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateVideoConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var description_: String?

    public var name: String?

    public var tenantContext: CreateWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateWorkspaceShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateWorkspaceResponseBody : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var requestId: String?

    public var url: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.workspaceId != nil {
            map["workspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("workspaceId") && dict["workspaceId"] != nil {
            self.workspaceId = dict["workspaceId"] as! String
        }
    }
}

public class CreateWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceDocHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateWorkspaceDocHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateWorkspaceDocHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateWorkspaceDocShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateWorkspaceDocRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var docType: String?

    public var name: String?

    public var parentNodeId: String?

    public var templateId: String?

    public var templateType: String?

    public var tenantContext: CreateWorkspaceDocRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docType != nil {
            map["DocType"] = self.docType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocType") && dict["DocType"] != nil {
            self.docType = dict["DocType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateWorkspaceDocRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocShrinkRequest : Tea.TeaModel {
    public var docType: String?

    public var name: String?

    public var parentNodeId: String?

    public var templateId: String?

    public var templateType: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docType != nil {
            map["DocType"] = self.docType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocType") && dict["DocType"] != nil {
            self.docType = dict["DocType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocResponseBody : Tea.TeaModel {
    public var docKey: String?

    public var nodeId: String?

    public var requestId: String?

    public var url: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.nodeId != nil {
            map["nodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.workspaceId != nil {
            map["workspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("docKey") && dict["docKey"] != nil {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("nodeId") && dict["nodeId"] != nil {
            self.nodeId = dict["nodeId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("workspaceId") && dict["workspaceId"] != nil {
            self.workspaceId = dict["workspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceDocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateWorkspaceDocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteColumnsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteColumnsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteColumnsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteColumnsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteColumnsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: DeleteColumnsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteColumnsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteColumnsShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteColumnsResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteEventRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class DeleteEventResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") && dict["data"] != nil {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: DeleteEventResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") && dict["content"] != nil {
            var model = DeleteEventResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") && dict["errorCode"] != nil {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") && dict["errorCtx"] != nil {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") && dict["errorMsg"] != nil {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") && dict["httpStatusCode"] != nil {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: DeleteLiveRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteLiveShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteLiveResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteMeetingRoomRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var roomId: String?

    public var tenantContext: DeleteMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteMeetingRoomShrinkRequest : Tea.TeaModel {
    public var roomId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteMeetingRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var tenantContext: DeleteMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRowsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteRowsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteRowsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteRowsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteRowsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: DeleteRowsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteRowsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteRowsShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteRowsResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteRowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteRowsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenegroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteScenegroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteScenegroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteScenegroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteScenegroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") && dict["OpenConversationId"] != nil {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class DeleteScenegroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteScenegroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenegroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScenegroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var sheetId: String?

    public var tenantContext: DeleteSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteSheetShrinkRequest : Tea.TeaModel {
    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteSheetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteSubscribedCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class DeleteSubscribedCalendarResponseBody : Tea.TeaModel {
    public var result: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: DeleteTodoTaskRequest.TenantContext?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteTodoTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [DeleteWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: DeleteWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [DeleteWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = DeleteWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [DeleteWorkspaceMembersRequest.Members]?

    public var tenantContext: DeleteWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [DeleteWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = DeleteWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAllSheetsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetAllSheetsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetAllSheetsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetAllSheetsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetAllSheetsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetAllSheetsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetAllSheetsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetAllSheetsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetAllSheetsResponseBody : Tea.TeaModel {
    public class Value : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var requestId: String?

    public var value: [GetAllSheetsResponseBody.Value]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.value != nil {
            var tmp : [Any] = []
            for k in self.value! {
                tmp.append(k.toMap())
            }
            map["value"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("value") && dict["value"] != nil {
            var tmp : [GetAllSheetsResponseBody.Value] = []
            for v in dict["value"] as! [Any] {
                var model = GetAllSheetsResponseBody.Value()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.value = tmp
        }
    }
}

public class GetAllSheetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAllSheetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAllSheetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetEventRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var maxAttendees: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MaxAttendees") && dict["MaxAttendees"] != nil {
            self.maxAttendees = dict["MaxAttendees"] as! Int64
        }
    }
}

public class GetEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Categories : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class ExtendedProperties : Tea.TeaModel {
        public class SharedProperties : Tea.TeaModel {
            public var belongCorpId: String?

            public var sourceOpenCid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.belongCorpId != nil {
                    map["BelongCorpId"] = self.belongCorpId!
                }
                if self.sourceOpenCid != nil {
                    map["SourceOpenCid"] = self.sourceOpenCid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BelongCorpId") && dict["BelongCorpId"] != nil {
                    self.belongCorpId = dict["BelongCorpId"] as! String
                }
                if dict.keys.contains("SourceOpenCid") && dict["SourceOpenCid"] != nil {
                    self.sourceOpenCid = dict["SourceOpenCid"] as! String
                }
            }
        }
        public var sharedProperties: GetEventResponseBody.ExtendedProperties.SharedProperties?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sharedProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sharedProperties != nil {
                map["SharedProperties"] = self.sharedProperties?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SharedProperties") && dict["SharedProperties"] != nil {
                var model = GetEventResponseBody.ExtendedProperties.SharedProperties()
                model.fromMap(dict["SharedProperties"] as! [String: Any])
                self.sharedProperties = model
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public var meetingRooms: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.meetingRooms != nil {
                map["MeetingRooms"] = self.meetingRooms!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                self.meetingRooms = dict["MeetingRooms"] as! [String]
            }
        }
    }
    public class MeetingRooms : Tea.TeaModel {
        public var displayName: String?

        public var responseStatus: String?

        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var conferenceId: String?

        public var extraInfo: [String: Any]?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class OriginStart : Tea.TeaModel {
        public var dateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: GetEventResponseBody.Recurrence.Pattern?

        public var range: GetEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                var model = GetEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                var model = GetEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class RichTextDescription : Tea.TeaModel {
        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Text") && dict["Text"] != nil {
                self.text = dict["Text"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var attendees: [GetEventResponseBody.Attendees]?

    public var categories: [GetEventResponseBody.Categories]?

    public var createTime: String?

    public var description_: String?

    public var end: GetEventResponseBody.End?

    public var extendedProperties: GetEventResponseBody.ExtendedProperties?

    public var id: String?

    public var isAllDay: Bool?

    public var location: GetEventResponseBody.Location?

    public var meetingRooms: [GetEventResponseBody.MeetingRooms]?

    public var onlineMeetingInfo: GetEventResponseBody.OnlineMeetingInfo?

    public var organizer: GetEventResponseBody.Organizer?

    public var originStart: GetEventResponseBody.OriginStart?

    public var recurrence: GetEventResponseBody.Recurrence?

    public var reminders: [GetEventResponseBody.Reminders]?

    public var requestId: String?

    public var richTextDescription: GetEventResponseBody.RichTextDescription?

    public var seriesMasterId: String?

    public var start: GetEventResponseBody.Start?

    public var status: String?

    public var summary: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.extendedProperties?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.organizer?.validate()
        try self.originStart?.validate()
        try self.recurrence?.validate()
        try self.richTextDescription?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.categories != nil {
            var tmp : [Any] = []
            for k in self.categories! {
                tmp.append(k.toMap())
            }
            map["categories"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.extendedProperties != nil {
            map["extendedProperties"] = self.extendedProperties?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.meetingRooms != nil {
            var tmp : [Any] = []
            for k in self.meetingRooms! {
                tmp.append(k.toMap())
            }
            map["meetingRooms"] = tmp
        }
        if self.onlineMeetingInfo != nil {
            map["onlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.originStart != nil {
            map["originStart"] = self.originStart?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.richTextDescription != nil {
            map["richTextDescription"] = self.richTextDescription?.toMap()
        }
        if self.seriesMasterId != nil {
            map["seriesMasterId"] = self.seriesMasterId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") && dict["attendees"] != nil {
            var tmp : [GetEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = GetEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("categories") && dict["categories"] != nil {
            var tmp : [GetEventResponseBody.Categories] = []
            for v in dict["categories"] as! [Any] {
                var model = GetEventResponseBody.Categories()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.categories = tmp
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") && dict["end"] != nil {
            var model = GetEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("extendedProperties") && dict["extendedProperties"] != nil {
            var model = GetEventResponseBody.ExtendedProperties()
            model.fromMap(dict["extendedProperties"] as! [String: Any])
            self.extendedProperties = model
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") && dict["isAllDay"] != nil {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") && dict["location"] != nil {
            var model = GetEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("meetingRooms") && dict["meetingRooms"] != nil {
            var tmp : [GetEventResponseBody.MeetingRooms] = []
            for v in dict["meetingRooms"] as! [Any] {
                var model = GetEventResponseBody.MeetingRooms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRooms = tmp
        }
        if dict.keys.contains("onlineMeetingInfo") && dict["onlineMeetingInfo"] != nil {
            var model = GetEventResponseBody.OnlineMeetingInfo()
            model.fromMap(dict["onlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("organizer") && dict["organizer"] != nil {
            var model = GetEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("originStart") && dict["originStart"] != nil {
            var model = GetEventResponseBody.OriginStart()
            model.fromMap(dict["originStart"] as! [String: Any])
            self.originStart = model
        }
        if dict.keys.contains("recurrence") && dict["recurrence"] != nil {
            var model = GetEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") && dict["reminders"] != nil {
            var tmp : [GetEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = GetEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("richTextDescription") && dict["richTextDescription"] != nil {
            var model = GetEventResponseBody.RichTextDescription()
            model.fromMap(dict["richTextDescription"] as! [String: Any])
            self.richTextDescription = model
        }
        if dict.keys.contains("seriesMasterId") && dict["seriesMasterId"] != nil {
            self.seriesMasterId = dict["seriesMasterId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = GetEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("summary") && dict["summary"] != nil {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class GetEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMeetingRoomsScheduleHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMeetingRoomsScheduleHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetMeetingRoomsScheduleHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMeetingRoomsScheduleShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleRequest : Tea.TeaModel {
    public var endTime: String?

    public var roomIds: [String]?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.roomIds != nil {
            map["RoomIds"] = self.roomIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RoomIds") && dict["RoomIds"] != nil {
            self.roomIds = dict["RoomIds"] as! [String]
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleShrinkRequest : Tea.TeaModel {
    public var endTime: String?

    public var roomIdsShrink: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.roomIdsShrink != nil {
            map["RoomIds"] = self.roomIdsShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RoomIds") && dict["RoomIds"] != nil {
            self.roomIdsShrink = dict["RoomIds"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleResponseBody : Tea.TeaModel {
    public class ScheduleInformation : Tea.TeaModel {
        public class ScheduleItems : Tea.TeaModel {
            public class End : Tea.TeaModel {
                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public class Organizer : Tea.TeaModel {
                public var id: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                }
            }
            public class Start : Tea.TeaModel {
                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public var end: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.End?

            public var eventId: String?

            public var organizer: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Organizer?

            public var start: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Start?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.end?.validate()
                try self.organizer?.validate()
                try self.start?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end?.toMap()
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.organizer != nil {
                    map["Organizer"] = self.organizer?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") && dict["End"] != nil {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.End()
                    model.fromMap(dict["End"] as! [String: Any])
                    self.end = model
                }
                if dict.keys.contains("EventId") && dict["EventId"] != nil {
                    self.eventId = dict["EventId"] as! String
                }
                if dict.keys.contains("Organizer") && dict["Organizer"] != nil {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Organizer()
                    model.fromMap(dict["Organizer"] as! [String: Any])
                    self.organizer = model
                }
                if dict.keys.contains("Start") && dict["Start"] != nil {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Start()
                    model.fromMap(dict["Start"] as! [String: Any])
                    self.start = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var error: String?

        public var roomId: String?

        public var scheduleItems: [GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.scheduleItems != nil {
                var tmp : [Any] = []
                for k in self.scheduleItems! {
                    tmp.append(k.toMap())
                }
                map["ScheduleItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Error") && dict["Error"] != nil {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("ScheduleItems") && dict["ScheduleItems"] != nil {
                var tmp : [GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems] = []
                for v in dict["ScheduleItems"] as! [Any] {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scheduleItems = tmp
            }
        }
    }
    public var requestId: String?

    public var scheduleInformation: [GetMeetingRoomsScheduleResponseBody.ScheduleInformation]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.scheduleInformation != nil {
            var tmp : [Any] = []
            for k in self.scheduleInformation! {
                tmp.append(k.toMap())
            }
            map["scheduleInformation"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("scheduleInformation") && dict["scheduleInformation"] != nil {
            var tmp : [GetMeetingRoomsScheduleResponseBody.ScheduleInformation] = []
            for v in dict["scheduleInformation"] as! [Any] {
                var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scheduleInformation = tmp
        }
    }
}

public class GetMeetingRoomsScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMeetingRoomsScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMeetingRoomsScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMineWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMineWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetMineWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMineWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMineWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: GetMineWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetMineWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMineWorkspaceShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMineWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetMineWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = GetMineWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: GetMineWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var model = GetMineWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetMineWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMineWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMineWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNodeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var nodeId: String?

    public var tenantContext: GetNodeRequest.TenantContext?

    public var withPermissionRole: Bool?

    public var withStatisticalInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.withStatisticalInfo != nil {
            map["WithStatisticalInfo"] = self.withStatisticalInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetNodeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
            self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
        }
    }
}

public class GetNodeShrinkRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public var withStatisticalInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.withStatisticalInfo != nil {
            map["WithStatisticalInfo"] = self.withStatisticalInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
            self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodeResponseBody.Node.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetNodeResponseBody.Node.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var node: GetNodeResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("node") && dict["node"] != nil {
            var model = GetNodeResponseBody.Node()
            model.fromMap(dict["node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeByUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodeByUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNodeByUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodeByUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodeByUrlRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public var withStatisticalInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            if self.withStatisticalInfo != nil {
                map["WithStatisticalInfo"] = self.withStatisticalInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
            if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
                self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetNodeByUrlRequest.Option?

    public var tenantContext: GetNodeByUrlRequest.TenantContext?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = GetNodeByUrlRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetNodeByUrlRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetNodeByUrlShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var tenantContextShrink: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetNodeByUrlResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodeByUrlResponseBody.Node.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetNodeByUrlResponseBody.Node.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var node: GetNodeByUrlResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("node") && dict["node"] != nil {
            var model = GetNodeByUrlResponseBody.Node()
            model.fromMap(dict["node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodeByUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeByUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNodeByUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNodesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodesRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public var withStatisticalInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            if self.withStatisticalInfo != nil {
                map["WithStatisticalInfo"] = self.withStatisticalInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
            if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
                self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var nodeIds: [String]?

    public var option: GetNodesRequest.Option?

    public var tenantContext: GetNodesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeIds") && dict["NodeIds"] != nil {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = GetNodesRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetNodesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetNodesShrinkRequest : Tea.TeaModel {
    public var nodeIdsShrink: String?

    public var optionShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeIdsShrink != nil {
            map["NodeIds"] = self.nodeIdsShrink!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeIds") && dict["NodeIds"] != nil {
            self.nodeIdsShrink = dict["NodeIds"] as! String
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodesResponseBody.Nodes.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetNodesResponseBody.Nodes.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nodes: [GetNodesResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["nodes"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nodes") && dict["nodes"] != nil {
            var tmp : [GetNodesResponseBody.Nodes] = []
            for v in dict["nodes"] as! [Any] {
                var model = GetNodesResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpenUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOpenUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetOpenUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOpenUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOpenUrlRequest : Tea.TeaModel {
    public var appType: String?

    public var fileUrl: String?

    public var language: String?

    public var systemToken: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetOpenUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
    }
}

public class GetOpenUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpenUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpenUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRangeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetRangeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetRangeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetRangeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetRangeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var select: String?

    public var sheetId: String?

    public var tenantContext: GetRangeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.select != nil {
            map["Select"] = self.select!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("Select") && dict["Select"] != nil {
            self.select = dict["Select"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetRangeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetRangeShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var select: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.select != nil {
            map["Select"] = self.select!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("Select") && dict["Select"] != nil {
            self.select = dict["Select"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetRangeResponseBody : Tea.TeaModel {
    public class BackgroundColors : Tea.TeaModel {
        public var red: Int32?

        public var green: Int32?

        public var blue: Int32?

        public var hexString: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.red != nil {
                map["Red"] = self.red!
            }
            if self.green != nil {
                map["Green"] = self.green!
            }
            if self.blue != nil {
                map["Blue"] = self.blue!
            }
            if self.hexString != nil {
                map["HexString"] = self.hexString!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Red") && dict["Red"] != nil {
                self.red = dict["Red"] as! Int32
            }
            if dict.keys.contains("Green") && dict["Green"] != nil {
                self.green = dict["Green"] as! Int32
            }
            if dict.keys.contains("Blue") && dict["Blue"] != nil {
                self.blue = dict["Blue"] as! Int32
            }
            if dict.keys.contains("HexString") && dict["HexString"] != nil {
                self.hexString = dict["HexString"] as! String
            }
        }
    }
    public var backgroundColors: [[GetRangeResponseBody.BackgroundColors]]?

    public var displayValues: [[String]]?

    public var formulas: [[String]]?

    public var requestId: String?

    public var values: [[Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColors != nil {
            var tmp : [Any] = []
            for k in self.backgroundColors! {
                var l1 : [Any] = []
                for k1 in k {
                    l1.append(k1.toMap())
                }
                tmp.append(l1)
            }
            map["backgroundColors"] = tmp
        }
        if self.displayValues != nil {
            map["displayValues"] = self.displayValues!
        }
        if self.formulas != nil {
            map["formulas"] = self.formulas!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.values != nil {
            map["values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("backgroundColors") && dict["backgroundColors"] != nil {
            var tmp : [[GetRangeResponseBody.BackgroundColors]] = []
            for v in dict["backgroundColors"] as! [Any] {
                var l1 : [GetRangeResponseBody.BackgroundColors] = []
                for v1 in v as! [Any] {
                    var model = GetRangeResponseBody.BackgroundColors()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp.append(l1)
            }
            self.backgroundColors = tmp
        }
        if dict.keys.contains("displayValues") && dict["displayValues"] != nil {
            self.displayValues = dict["displayValues"] as! [[String]]
        }
        if dict.keys.contains("formulas") && dict["formulas"] != nil {
            self.formulas = dict["formulas"] as! [[String]]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("values") && dict["values"] != nil {
            self.values = dict["values"] as! [[Any]]
        }
    }
}

public class GetRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetReportTemplateByNameHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetReportTemplateByNameHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetReportTemplateByNameHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetReportTemplateByNameShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetReportTemplateByNameRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var templateName: String?

    public var tenantContext: GetReportTemplateByNameRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetReportTemplateByNameRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetReportTemplateByNameShrinkRequest : Tea.TeaModel {
    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetReportTemplateByNameResponseBody : Tea.TeaModel {
    public class DefaultReceivedConvs : Tea.TeaModel {
        public var conversationId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conversationId != nil {
                map["ConversationId"] = self.conversationId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConversationId") && dict["ConversationId"] != nil {
                self.conversationId = dict["ConversationId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class DefaultReceivers : Tea.TeaModel {
        public var userName: String?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userid != nil {
                map["Userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("Userid") && dict["Userid"] != nil {
                self.userid = dict["Userid"] as! String
            }
        }
    }
    public class Fields : Tea.TeaModel {
        public var fieldName: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
                self.fieldName = dict["FieldName"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public var defaultReceivedConvs: [GetReportTemplateByNameResponseBody.DefaultReceivedConvs]?

    public var defaultReceivers: [GetReportTemplateByNameResponseBody.DefaultReceivers]?

    public var fields: [GetReportTemplateByNameResponseBody.Fields]?

    public var id: String?

    public var name: String?

    public var requestId: String?

    public var userName: String?

    public var userid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultReceivedConvs != nil {
            var tmp : [Any] = []
            for k in self.defaultReceivedConvs! {
                tmp.append(k.toMap())
            }
            map["defaultReceivedConvs"] = tmp
        }
        if self.defaultReceivers != nil {
            var tmp : [Any] = []
            for k in self.defaultReceivers! {
                tmp.append(k.toMap())
            }
            map["defaultReceivers"] = tmp
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        if self.userid != nil {
            map["userid"] = self.userid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("defaultReceivedConvs") && dict["defaultReceivedConvs"] != nil {
            var tmp : [GetReportTemplateByNameResponseBody.DefaultReceivedConvs] = []
            for v in dict["defaultReceivedConvs"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.DefaultReceivedConvs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultReceivedConvs = tmp
        }
        if dict.keys.contains("defaultReceivers") && dict["defaultReceivers"] != nil {
            var tmp : [GetReportTemplateByNameResponseBody.DefaultReceivers] = []
            for v in dict["defaultReceivers"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.DefaultReceivers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultReceivers = tmp
        }
        if dict.keys.contains("fields") && dict["fields"] != nil {
            var tmp : [GetReportTemplateByNameResponseBody.Fields] = []
            for v in dict["fields"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.Fields()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fields = tmp
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("userName") && dict["userName"] != nil {
            self.userName = dict["userName"] as! String
        }
        if dict.keys.contains("userid") && dict["userid"] != nil {
            self.userid = dict["userid"] as! String
        }
    }
}

public class GetReportTemplateByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReportTemplateByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetReportTemplateByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetReportUnReadCountHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetReportUnReadCountHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetReportUnReadCountHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetReportUnReadCountShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetReportUnReadCountRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: GetReportUnReadCountRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetReportUnReadCountRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetReportUnReadCountShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetReportUnReadCountResponseBody : Tea.TeaModel {
    public var count: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("count") && dict["count"] != nil {
            self.count = dict["count"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetReportUnReadCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReportUnReadCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetReportUnReadCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var sheetId: String?

    public var tenantContext: GetSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetSheetShrinkRequest : Tea.TeaModel {
    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetSheetResponseBody : Tea.TeaModel {
    public var columnCount: Int64?

    public var id: String?

    public var lastNonEmptyColumn: Int64?

    public var lastNonEmptyRow: Int64?

    public var name: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnCount != nil {
            map["columnCount"] = self.columnCount!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastNonEmptyColumn != nil {
            map["lastNonEmptyColumn"] = self.lastNonEmptyColumn!
        }
        if self.lastNonEmptyRow != nil {
            map["lastNonEmptyRow"] = self.lastNonEmptyRow!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["rowCount"] = self.rowCount!
        }
        if self.visibility != nil {
            map["visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("columnCount") && dict["columnCount"] != nil {
            self.columnCount = dict["columnCount"] as! Int64
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("lastNonEmptyColumn") && dict["lastNonEmptyColumn"] != nil {
            self.lastNonEmptyColumn = dict["lastNonEmptyColumn"] as! Int64
        }
        if dict.keys.contains("lastNonEmptyRow") && dict["lastNonEmptyRow"] != nil {
            self.lastNonEmptyRow = dict["lastNonEmptyRow"] as! Int64
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("rowCount") && dict["rowCount"] != nil {
            self.rowCount = dict["rowCount"] as! Int64
        }
        if dict.keys.contains("visibility") && dict["visibility"] != nil {
            self.visibility = dict["visibility"] as! String
        }
    }
}

public class GetSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSpaceDirectoriesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSpaceDirectoriesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetSpaceDirectoriesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSpaceDirectoriesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSpaceDirectoriesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceId: String?

    public var tenantContext: GetSpaceDirectoriesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetSpaceDirectoriesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetSpaceDirectoriesShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetSpaceDirectoriesResponseBody : Tea.TeaModel {
    public class Children : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class LinkSourceInfo : Tea.TeaModel {
            public class IconUrl : Tea.TeaModel {
                public var line: String?

                public var small: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        map["Line"] = self.line!
                    }
                    if self.small != nil {
                        map["Small"] = self.small!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") && dict["Line"] != nil {
                        self.line = dict["Line"] as! String
                    }
                    if dict.keys.contains("Small") && dict["Small"] != nil {
                        self.small = dict["Small"] as! String
                    }
                }
            }
            public var extension_: String?

            public var iconUrl: GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo.IconUrl?

            public var id: String?

            public var linkType: Int64?

            public var spaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.iconUrl?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.iconUrl != nil {
                    map["IconUrl"] = self.iconUrl?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.linkType != nil {
                    map["LinkType"] = self.linkType!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo.IconUrl()
                    model.fromMap(dict["IconUrl"] as! [String: Any])
                    self.iconUrl = model
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LinkType") && dict["LinkType"] != nil {
                    self.linkType = dict["LinkType"] as! Int64
                }
                if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                    self.spaceId = dict["SpaceId"] as! String
                }
            }
        }
        public class Space : Tea.TeaModel {
            public class HdIconVO : Tea.TeaModel {
                public var icon: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class IconVO : Tea.TeaModel {
                public var icon: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Owner : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var cover: String?

            public var description_: String?

            public var hdIconVO: GetSpaceDirectoriesResponseBody.Children.Space.HdIconVO?

            public var iconVO: GetSpaceDirectoriesResponseBody.Children.Space.IconVO?

            public var id: String?

            public var name: String?

            public var owner: GetSpaceDirectoriesResponseBody.Children.Space.Owner?

            public var recentList: [Any]?

            public var type: Int32?

            public var url: String?

            public var visitorInfo: GetSpaceDirectoriesResponseBody.Children.Space.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hdIconVO?.validate()
                try self.iconVO?.validate()
                try self.owner?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cover != nil {
                    map["Cover"] = self.cover!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hdIconVO != nil {
                    map["HdIconVO"] = self.hdIconVO?.toMap()
                }
                if self.iconVO != nil {
                    map["IconVO"] = self.iconVO?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner?.toMap()
                }
                if self.recentList != nil {
                    map["RecentList"] = self.recentList!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cover") && dict["Cover"] != nil {
                    self.cover = dict["Cover"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HdIconVO") && dict["HdIconVO"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.HdIconVO()
                    model.fromMap(dict["HdIconVO"] as! [String: Any])
                    self.hdIconVO = model
                }
                if dict.keys.contains("IconVO") && dict["IconVO"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.IconVO()
                    model.fromMap(dict["IconVO"] as! [String: Any])
                    self.iconVO = model
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") && dict["Owner"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.Owner()
                    model.fromMap(dict["Owner"] as! [String: Any])
                    self.owner = model
                }
                if dict.keys.contains("RecentList") && dict["RecentList"] != nil {
                    self.recentList = dict["RecentList"] as! [Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public class Updater : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var contentType: String?

        public var createdTime: Int64?

        public var creator: GetSpaceDirectoriesResponseBody.Children.Creator?

        public var dentryId: String?

        public var dentryType: String?

        public var dentryUuid: String?

        public var docKey: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var linkSourceInfo: GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo?

        public var name: String?

        public var path: String?

        public var space: GetSpaceDirectoriesResponseBody.Children.Space?

        public var spaceId: String?

        public var statisticalInfo: GetSpaceDirectoriesResponseBody.Children.StatisticalInfo?

        public var updatedTime: Int64?

        public var updater: GetSpaceDirectoriesResponseBody.Children.Updater?

        public var url: String?

        public var visitorInfo: GetSpaceDirectoriesResponseBody.Children.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
            try self.linkSourceInfo?.validate()
            try self.space?.validate()
            try self.statisticalInfo?.validate()
            try self.updater?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator?.toMap()
            }
            if self.dentryId != nil {
                map["DentryId"] = self.dentryId!
            }
            if self.dentryType != nil {
                map["DentryType"] = self.dentryType!
            }
            if self.dentryUuid != nil {
                map["DentryUuid"] = self.dentryUuid!
            }
            if self.docKey != nil {
                map["DocKey"] = self.docKey!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.linkSourceInfo != nil {
                map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.space != nil {
                map["Space"] = self.space?.toMap()
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updater != nil {
                map["Updater"] = self.updater?.toMap()
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Creator") && dict["Creator"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.Creator()
                model.fromMap(dict["Creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
                self.dentryId = dict["DentryId"] as! String
            }
            if dict.keys.contains("DentryType") && dict["DentryType"] != nil {
                self.dentryType = dict["DentryType"] as! String
            }
            if dict.keys.contains("DentryUuid") && dict["DentryUuid"] != nil {
                self.dentryUuid = dict["DentryUuid"] as! String
            }
            if dict.keys.contains("DocKey") && dict["DocKey"] != nil {
                self.docKey = dict["DocKey"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("LinkSourceInfo") && dict["LinkSourceInfo"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo()
                model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                self.linkSourceInfo = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Space") && dict["Space"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.Space()
                model.fromMap(dict["Space"] as! [String: Any])
                self.space = model
            }
            if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                self.spaceId = dict["SpaceId"] as! String
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("Updater") && dict["Updater"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.Updater()
                model.fromMap(dict["Updater"] as! [String: Any])
                self.updater = model
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public var children: [GetSpaceDirectoriesResponseBody.Children]?

    public var hasMore: Bool?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["children"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("children") && dict["children"] != nil {
            var tmp : [GetSpaceDirectoriesResponseBody.Children] = []
            for v in dict["children"] as! [Any] {
                var model = GetSpaceDirectoriesResponseBody.Children()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.children = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetSpaceDirectoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSpaceDirectoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSpaceDirectoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSubscribedCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class GetSubscribedCalendarResponseBody : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var corpIds: [String]?

        public var openConversationIds: [String]?

        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpIds != nil {
                map["CorpIds"] = self.corpIds!
            }
            if self.openConversationIds != nil {
                map["OpenConversationIds"] = self.openConversationIds!
            }
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpIds") && dict["CorpIds"] != nil {
                self.corpIds = dict["CorpIds"] as! [String]
            }
            if dict.keys.contains("OpenConversationIds") && dict["OpenConversationIds"] != nil {
                self.openConversationIds = dict["OpenConversationIds"] as! [String]
            }
            if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var author: String?

    public var calendarId: String?

    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var requestId: String?

    public var subscribeScope: GetSubscribedCalendarResponseBody.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.author != nil {
            map["author"] = self.author!
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.managers != nil {
            map["managers"] = self.managers!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.subscribeScope != nil {
            map["subscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("author") && dict["author"] != nil {
            self.author = dict["author"] as! String
        }
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("managers") && dict["managers"] != nil {
            self.managers = dict["managers"] as! [String]
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("subscribeScope") && dict["subscribeScope"] != nil {
            var model = GetSubscribedCalendarResponseBody.SubscribeScope()
            model.fromMap(dict["subscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class GetSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateListByUserIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTemplateListByUserIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetTemplateListByUserIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTemplateListByUserIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTemplateListByUserIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var size: Int64?

    public var tenantContext: GetTemplateListByUserIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetTemplateListByUserIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetTemplateListByUserIdShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetTemplateListByUserIdResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var iconUrl: String?

        public var name: String?

        public var reportCode: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reportCode != nil {
                map["ReportCode"] = self.reportCode!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                self.iconUrl = dict["IconUrl"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ReportCode") && dict["ReportCode"] != nil {
                self.reportCode = dict["ReportCode"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var nextCursor: Int64?

    public var requestId: String?

    public var templateList: [GetTemplateListByUserIdResponseBody.TemplateList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["templateList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("templateList") && dict["templateList"] != nil {
            var tmp : [GetTemplateListByUserIdResponseBody.TemplateList] = []
            for v in dict["templateList"] as! [Any] {
                var model = GetTemplateListByUserIdResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
    }
}

public class GetTemplateListByUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateListByUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTemplateListByUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetUserHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetUserHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetUserShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetUserRequest.TenantContext?

    public var language: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetUserRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("language") && dict["language"] != nil {
            self.language = dict["language"] as! String
        }
    }
}

public class GetUserShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var language: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("language") && dict["language"] != nil {
            self.language = dict["language"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class DeptOrderList : Tea.TeaModel {
        public var deptId: Int64?

        public var order: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptId != nil {
                map["deptId"] = self.deptId!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deptId") && dict["deptId"] != nil {
                self.deptId = dict["deptId"] as! Int64
            }
            if dict.keys.contains("order") && dict["order"] != nil {
                self.order = dict["order"] as! Int64
            }
        }
    }
    public class LeaderInDept : Tea.TeaModel {
        public var deptId: Int64?

        public var leader: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptId != nil {
                map["deptId"] = self.deptId!
            }
            if self.leader != nil {
                map["leader"] = self.leader!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deptId") && dict["deptId"] != nil {
                self.deptId = dict["deptId"] as! Int64
            }
            if dict.keys.contains("leader") && dict["leader"] != nil {
                self.leader = dict["leader"] as! Bool
            }
        }
    }
    public class RoleList : Tea.TeaModel {
        public var groupName: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupName") && dict["groupName"] != nil {
                self.groupName = dict["groupName"] as! String
            }
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") && dict["name"] != nil {
                self.name = dict["name"] as! String
            }
        }
    }
    public class UnionEmpExt : Tea.TeaModel {
        public class UnionEmpMapList : Tea.TeaModel {
            public var cropId: String?

            public var userid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cropId != nil {
                    map["cropId"] = self.cropId!
                }
                if self.userid != nil {
                    map["userid"] = self.userid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cropId") && dict["cropId"] != nil {
                    self.cropId = dict["cropId"] as! String
                }
                if dict.keys.contains("userid") && dict["userid"] != nil {
                    self.userid = dict["userid"] as! String
                }
            }
        }
        public var corpId: String?

        public var unionEmpMapList: [GetUserResponseBody.UnionEmpExt.UnionEmpMapList]?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["corpId"] = self.corpId!
            }
            if self.unionEmpMapList != nil {
                var tmp : [Any] = []
                for k in self.unionEmpMapList! {
                    tmp.append(k.toMap())
                }
                map["unionEmpMapList"] = tmp
            }
            if self.userid != nil {
                map["userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("corpId") && dict["corpId"] != nil {
                self.corpId = dict["corpId"] as! String
            }
            if dict.keys.contains("unionEmpMapList") && dict["unionEmpMapList"] != nil {
                var tmp : [GetUserResponseBody.UnionEmpExt.UnionEmpMapList] = []
                for v in dict["unionEmpMapList"] as! [Any] {
                    var model = GetUserResponseBody.UnionEmpExt.UnionEmpMapList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.unionEmpMapList = tmp
            }
            if dict.keys.contains("userid") && dict["userid"] != nil {
                self.userid = dict["userid"] as! String
            }
        }
    }
    public var active: Bool?

    public var admin: Bool?

    public var avatar: String?

    public var boss: Bool?

    public var deptIdList: [Int64]?

    public var deptOrderList: [GetUserResponseBody.DeptOrderList]?

    public var email: String?

    public var exclusiveAccount: Bool?

    public var exclusiveAccountCorpId: String?

    public var exclusiveAccountCorpName: String?

    public var exclusiveAccountType: String?

    public var extension_: String?

    public var hideMobile: Bool?

    public var hiredDate: Int64?

    public var jobNumber: String?

    public var leaderInDept: [GetUserResponseBody.LeaderInDept]?

    public var loginId: String?

    public var managerUserid: String?

    public var mobile: String?

    public var name: String?

    public var nickname: String?

    public var orgEmail: String?

    public var realAuthed: Bool?

    public var remark: String?

    public var requestId: String?

    public var roleList: [GetUserResponseBody.RoleList]?

    public var senior: Bool?

    public var stateCode: String?

    public var telephone: String?

    public var title: String?

    public var unionEmpExt: GetUserResponseBody.UnionEmpExt?

    public var userid: String?

    public var workPlace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.unionEmpExt?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["active"] = self.active!
        }
        if self.admin != nil {
            map["admin"] = self.admin!
        }
        if self.avatar != nil {
            map["avatar"] = self.avatar!
        }
        if self.boss != nil {
            map["boss"] = self.boss!
        }
        if self.deptIdList != nil {
            map["deptIdList"] = self.deptIdList!
        }
        if self.deptOrderList != nil {
            var tmp : [Any] = []
            for k in self.deptOrderList! {
                tmp.append(k.toMap())
            }
            map["deptOrderList"] = tmp
        }
        if self.email != nil {
            map["email"] = self.email!
        }
        if self.exclusiveAccount != nil {
            map["exclusiveAccount"] = self.exclusiveAccount!
        }
        if self.exclusiveAccountCorpId != nil {
            map["exclusiveAccountCorpId"] = self.exclusiveAccountCorpId!
        }
        if self.exclusiveAccountCorpName != nil {
            map["exclusiveAccountCorpName"] = self.exclusiveAccountCorpName!
        }
        if self.exclusiveAccountType != nil {
            map["exclusiveAccountType"] = self.exclusiveAccountType!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hideMobile != nil {
            map["hideMobile"] = self.hideMobile!
        }
        if self.hiredDate != nil {
            map["hiredDate"] = self.hiredDate!
        }
        if self.jobNumber != nil {
            map["jobNumber"] = self.jobNumber!
        }
        if self.leaderInDept != nil {
            var tmp : [Any] = []
            for k in self.leaderInDept! {
                tmp.append(k.toMap())
            }
            map["leaderInDept"] = tmp
        }
        if self.loginId != nil {
            map["loginId"] = self.loginId!
        }
        if self.managerUserid != nil {
            map["managerUserid"] = self.managerUserid!
        }
        if self.mobile != nil {
            map["mobile"] = self.mobile!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.nickname != nil {
            map["nickname"] = self.nickname!
        }
        if self.orgEmail != nil {
            map["orgEmail"] = self.orgEmail!
        }
        if self.realAuthed != nil {
            map["realAuthed"] = self.realAuthed!
        }
        if self.remark != nil {
            map["remark"] = self.remark!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roleList != nil {
            var tmp : [Any] = []
            for k in self.roleList! {
                tmp.append(k.toMap())
            }
            map["roleList"] = tmp
        }
        if self.senior != nil {
            map["senior"] = self.senior!
        }
        if self.stateCode != nil {
            map["stateCode"] = self.stateCode!
        }
        if self.telephone != nil {
            map["telephone"] = self.telephone!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.unionEmpExt != nil {
            map["unionEmpExt"] = self.unionEmpExt?.toMap()
        }
        if self.userid != nil {
            map["userid"] = self.userid!
        }
        if self.workPlace != nil {
            map["workPlace"] = self.workPlace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("active") && dict["active"] != nil {
            self.active = dict["active"] as! Bool
        }
        if dict.keys.contains("admin") && dict["admin"] != nil {
            self.admin = dict["admin"] as! Bool
        }
        if dict.keys.contains("avatar") && dict["avatar"] != nil {
            self.avatar = dict["avatar"] as! String
        }
        if dict.keys.contains("boss") && dict["boss"] != nil {
            self.boss = dict["boss"] as! Bool
        }
        if dict.keys.contains("deptIdList") && dict["deptIdList"] != nil {
            self.deptIdList = dict["deptIdList"] as! [Int64]
        }
        if dict.keys.contains("deptOrderList") && dict["deptOrderList"] != nil {
            var tmp : [GetUserResponseBody.DeptOrderList] = []
            for v in dict["deptOrderList"] as! [Any] {
                var model = GetUserResponseBody.DeptOrderList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deptOrderList = tmp
        }
        if dict.keys.contains("email") && dict["email"] != nil {
            self.email = dict["email"] as! String
        }
        if dict.keys.contains("exclusiveAccount") && dict["exclusiveAccount"] != nil {
            self.exclusiveAccount = dict["exclusiveAccount"] as! Bool
        }
        if dict.keys.contains("exclusiveAccountCorpId") && dict["exclusiveAccountCorpId"] != nil {
            self.exclusiveAccountCorpId = dict["exclusiveAccountCorpId"] as! String
        }
        if dict.keys.contains("exclusiveAccountCorpName") && dict["exclusiveAccountCorpName"] != nil {
            self.exclusiveAccountCorpName = dict["exclusiveAccountCorpName"] as! String
        }
        if dict.keys.contains("exclusiveAccountType") && dict["exclusiveAccountType"] != nil {
            self.exclusiveAccountType = dict["exclusiveAccountType"] as! String
        }
        if dict.keys.contains("extension") && dict["extension"] != nil {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hideMobile") && dict["hideMobile"] != nil {
            self.hideMobile = dict["hideMobile"] as! Bool
        }
        if dict.keys.contains("hiredDate") && dict["hiredDate"] != nil {
            self.hiredDate = dict["hiredDate"] as! Int64
        }
        if dict.keys.contains("jobNumber") && dict["jobNumber"] != nil {
            self.jobNumber = dict["jobNumber"] as! String
        }
        if dict.keys.contains("leaderInDept") && dict["leaderInDept"] != nil {
            var tmp : [GetUserResponseBody.LeaderInDept] = []
            for v in dict["leaderInDept"] as! [Any] {
                var model = GetUserResponseBody.LeaderInDept()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.leaderInDept = tmp
        }
        if dict.keys.contains("loginId") && dict["loginId"] != nil {
            self.loginId = dict["loginId"] as! String
        }
        if dict.keys.contains("managerUserid") && dict["managerUserid"] != nil {
            self.managerUserid = dict["managerUserid"] as! String
        }
        if dict.keys.contains("mobile") && dict["mobile"] != nil {
            self.mobile = dict["mobile"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("nickname") && dict["nickname"] != nil {
            self.nickname = dict["nickname"] as! String
        }
        if dict.keys.contains("orgEmail") && dict["orgEmail"] != nil {
            self.orgEmail = dict["orgEmail"] as! String
        }
        if dict.keys.contains("realAuthed") && dict["realAuthed"] != nil {
            self.realAuthed = dict["realAuthed"] as! Bool
        }
        if dict.keys.contains("remark") && dict["remark"] != nil {
            self.remark = dict["remark"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roleList") && dict["roleList"] != nil {
            var tmp : [GetUserResponseBody.RoleList] = []
            for v in dict["roleList"] as! [Any] {
                var model = GetUserResponseBody.RoleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.roleList = tmp
        }
        if dict.keys.contains("senior") && dict["senior"] != nil {
            self.senior = dict["senior"] as! Bool
        }
        if dict.keys.contains("stateCode") && dict["stateCode"] != nil {
            self.stateCode = dict["stateCode"] as! String
        }
        if dict.keys.contains("telephone") && dict["telephone"] != nil {
            self.telephone = dict["telephone"] as! String
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("unionEmpExt") && dict["unionEmpExt"] != nil {
            var model = GetUserResponseBody.UnionEmpExt()
            model.fromMap(dict["unionEmpExt"] as! [String: Any])
            self.unionEmpExt = model
        }
        if dict.keys.contains("userid") && dict["userid"] != nil {
            self.userid = dict["userid"] as! String
        }
        if dict.keys.contains("workPlace") && dict["workPlace"] != nil {
            self.workPlace = dict["workPlace"] as! String
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetWorkspaceRequest.TenantContext?

    public var withPermissionRole: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetWorkspaceShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = GetWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: GetWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var model = GetWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetWorkspacesRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetWorkspacesRequest.Option?

    public var tenantContext: GetWorkspacesRequest.TenantContext?

    public var workspaceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceIds != nil {
            map["WorkspaceIds"] = self.workspaceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = GetWorkspacesRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceIds") && dict["WorkspaceIds"] != nil {
            self.workspaceIds = dict["WorkspaceIds"] as! [String]
        }
    }
}

public class GetWorkspacesShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var tenantContextShrink: String?

    public var workspaceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceIdsShrink != nil {
            map["WorkspaceIds"] = self.workspaceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceIds") && dict["WorkspaceIds"] != nil {
            self.workspaceIdsShrink = dict["WorkspaceIds"] as! String
        }
    }
}

public class GetWorkspacesResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetWorkspacesResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = GetWorkspacesResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: [GetWorkspacesResponseBody.Workspace]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            var tmp : [Any] = []
            for k in self.workspace! {
                tmp.append(k.toMap())
            }
            map["workspace"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var tmp : [GetWorkspacesResponseBody.Workspace] = []
            for v in dict["workspace"] as! [Any] {
                var model = GetWorkspacesResponseBody.Workspace()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspace = tmp
        }
    }
}

public class GetWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GrantHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GrantHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GrantHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GrantHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GrantHonorRequest.TenantContext?

    public var expirationTime: Int64?

    public var grantReason: String?

    public var granterName: String?

    public var honorId: String?

    public var noticeAnnouncer: Bool?

    public var noticeSingle: Bool?

    public var openConversationIds: [String]?

    public var orgId: Int64?

    public var receiverUserIds: [String]?

    public var senderUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.expirationTime != nil {
            map["expirationTime"] = self.expirationTime!
        }
        if self.grantReason != nil {
            map["grantReason"] = self.grantReason!
        }
        if self.granterName != nil {
            map["granterName"] = self.granterName!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.noticeAnnouncer != nil {
            map["noticeAnnouncer"] = self.noticeAnnouncer!
        }
        if self.noticeSingle != nil {
            map["noticeSingle"] = self.noticeSingle!
        }
        if self.openConversationIds != nil {
            map["openConversationIds"] = self.openConversationIds!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.receiverUserIds != nil {
            map["receiverUserIds"] = self.receiverUserIds!
        }
        if self.senderUserId != nil {
            map["senderUserId"] = self.senderUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GrantHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("expirationTime") && dict["expirationTime"] != nil {
            self.expirationTime = dict["expirationTime"] as! Int64
        }
        if dict.keys.contains("grantReason") && dict["grantReason"] != nil {
            self.grantReason = dict["grantReason"] as! String
        }
        if dict.keys.contains("granterName") && dict["granterName"] != nil {
            self.granterName = dict["granterName"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("noticeAnnouncer") && dict["noticeAnnouncer"] != nil {
            self.noticeAnnouncer = dict["noticeAnnouncer"] as! Bool
        }
        if dict.keys.contains("noticeSingle") && dict["noticeSingle"] != nil {
            self.noticeSingle = dict["noticeSingle"] as! Bool
        }
        if dict.keys.contains("openConversationIds") && dict["openConversationIds"] != nil {
            self.openConversationIds = dict["openConversationIds"] as! [String]
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("receiverUserIds") && dict["receiverUserIds"] != nil {
            self.receiverUserIds = dict["receiverUserIds"] as! [String]
        }
        if dict.keys.contains("senderUserId") && dict["senderUserId"] != nil {
            self.senderUserId = dict["senderUserId"] as! String
        }
    }
}

public class GrantHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var expirationTime: Int64?

    public var grantReason: String?

    public var granterName: String?

    public var honorId: String?

    public var noticeAnnouncer: Bool?

    public var noticeSingle: Bool?

    public var openConversationIdsShrink: String?

    public var orgId: Int64?

    public var receiverUserIdsShrink: String?

    public var senderUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.expirationTime != nil {
            map["expirationTime"] = self.expirationTime!
        }
        if self.grantReason != nil {
            map["grantReason"] = self.grantReason!
        }
        if self.granterName != nil {
            map["granterName"] = self.granterName!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.noticeAnnouncer != nil {
            map["noticeAnnouncer"] = self.noticeAnnouncer!
        }
        if self.noticeSingle != nil {
            map["noticeSingle"] = self.noticeSingle!
        }
        if self.openConversationIdsShrink != nil {
            map["openConversationIds"] = self.openConversationIdsShrink!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.receiverUserIdsShrink != nil {
            map["receiverUserIds"] = self.receiverUserIdsShrink!
        }
        if self.senderUserId != nil {
            map["senderUserId"] = self.senderUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("expirationTime") && dict["expirationTime"] != nil {
            self.expirationTime = dict["expirationTime"] as! Int64
        }
        if dict.keys.contains("grantReason") && dict["grantReason"] != nil {
            self.grantReason = dict["grantReason"] as! String
        }
        if dict.keys.contains("granterName") && dict["granterName"] != nil {
            self.granterName = dict["granterName"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("noticeAnnouncer") && dict["noticeAnnouncer"] != nil {
            self.noticeAnnouncer = dict["noticeAnnouncer"] as! Bool
        }
        if dict.keys.contains("noticeSingle") && dict["noticeSingle"] != nil {
            self.noticeSingle = dict["noticeSingle"] as! Bool
        }
        if dict.keys.contains("openConversationIds") && dict["openConversationIds"] != nil {
            self.openConversationIdsShrink = dict["openConversationIds"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("receiverUserIds") && dict["receiverUserIds"] != nil {
            self.receiverUserIdsShrink = dict["receiverUserIds"] as! String
        }
        if dict.keys.contains("senderUserId") && dict["senderUserId"] != nil {
            self.senderUserId = dict["senderUserId"] as! String
        }
    }
}

public class GrantHonorResponseBody : Tea.TeaModel {
    public var failedUserIds: [String]?

    public var requestId: String?

    public var successUserIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedUserIds != nil {
            map["failedUserIds"] = self.failedUserIds!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.successUserIds != nil {
            map["successUserIds"] = self.successUserIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failedUserIds") && dict["failedUserIds"] != nil {
            self.failedUserIds = dict["failedUserIds"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("successUserIds") && dict["successUserIds"] != nil {
            self.successUserIds = dict["successUserIds"] as! [String]
        }
    }
}

public class GrantHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GrantHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertColumnsBeforeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InsertColumnsBeforeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = InsertColumnsBeforeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InsertColumnsBeforeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InsertColumnsBeforeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: InsertColumnsBeforeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = InsertColumnsBeforeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertColumnsBeforeShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertColumnsBeforeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InsertColumnsBeforeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertColumnsBeforeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertColumnsBeforeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertRowsBeforeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InsertRowsBeforeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = InsertRowsBeforeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InsertRowsBeforeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InsertRowsBeforeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: InsertRowsBeforeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = InsertRowsBeforeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertRowsBeforeShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertRowsBeforeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InsertRowsBeforeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertRowsBeforeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertRowsBeforeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InviteUsersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InviteUsersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = InviteUsersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InviteUsersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InviteUsersRequest : Tea.TeaModel {
    public class InviteeList : Tea.TeaModel {
        public var nick: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nick != nil {
                map["Nick"] = self.nick!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nick") && dict["Nick"] != nil {
                self.nick = dict["Nick"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var inviteeList: [InviteUsersRequest.InviteeList]?

    public var tenantContext: InviteUsersRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inviteeList != nil {
            var tmp : [Any] = []
            for k in self.inviteeList! {
                tmp.append(k.toMap())
            }
            map["InviteeList"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InviteeList") && dict["InviteeList"] != nil {
            var tmp : [InviteUsersRequest.InviteeList] = []
            for v in dict["InviteeList"] as! [Any] {
                var model = InviteUsersRequest.InviteeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inviteeList = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = InviteUsersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class InviteUsersShrinkRequest : Tea.TeaModel {
    public var inviteeListShrink: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inviteeListShrink != nil {
            map["InviteeList"] = self.inviteeListShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InviteeList") && dict["InviteeList"] != nil {
            self.inviteeListShrink = dict["InviteeList"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class InviteUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class InviteUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InviteUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InviteUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCalendarsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListCalendarsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListCalendarsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListCalendarsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListCalendarsRequest : Tea.TeaModel {
    public var request: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
    }
}

public class ListCalendarsShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
    }
}

public class ListCalendarsResponseBody : Tea.TeaModel {
    public class Response : Tea.TeaModel {
        public class Calendars : Tea.TeaModel {
            public var description_: String?

            public var ETag: String?

            public var id: String?

            public var privilege: String?

            public var summary: String?

            public var timeZone: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ETag != nil {
                    map["ETag"] = self.ETag!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.privilege != nil {
                    map["Privilege"] = self.privilege!
                }
                if self.summary != nil {
                    map["Summary"] = self.summary!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ETag") && dict["ETag"] != nil {
                    self.ETag = dict["ETag"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Privilege") && dict["Privilege"] != nil {
                    self.privilege = dict["Privilege"] as! String
                }
                if dict.keys.contains("Summary") && dict["Summary"] != nil {
                    self.summary = dict["Summary"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var calendars: [ListCalendarsResponseBody.Response.Calendars]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.calendars != nil {
                var tmp : [Any] = []
                for k in self.calendars! {
                    tmp.append(k.toMap())
                }
                map["Calendars"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Calendars") && dict["Calendars"] != nil {
                var tmp : [ListCalendarsResponseBody.Response.Calendars] = []
                for v in dict["Calendars"] as! [Any] {
                    var model = ListCalendarsResponseBody.Response.Calendars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.calendars = tmp
            }
        }
    }
    public var requestId: String?

    public var response: ListCalendarsResponseBody.Response?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.response?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.response != nil {
            map["response"] = self.response?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("response") && dict["response"] != nil {
            var model = ListCalendarsResponseBody.Response()
            model.fromMap(dict["response"] as! [String: Any])
            self.response = model
        }
    }
}

public class ListCalendarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCalendarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCalendarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListEventsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListEventsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListEventsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListEventsRequest : Tea.TeaModel {
    public var calendarId: String?

    public var maxAttendees: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var seriesMasterId: String?

    public var showDeleted: Bool?

    public var syncToken: String?

    public var timeMax: String?

    public var timeMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.seriesMasterId != nil {
            map["SeriesMasterId"] = self.seriesMasterId!
        }
        if self.showDeleted != nil {
            map["ShowDeleted"] = self.showDeleted!
        }
        if self.syncToken != nil {
            map["SyncToken"] = self.syncToken!
        }
        if self.timeMax != nil {
            map["TimeMax"] = self.timeMax!
        }
        if self.timeMin != nil {
            map["TimeMin"] = self.timeMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("MaxAttendees") && dict["MaxAttendees"] != nil {
            self.maxAttendees = dict["MaxAttendees"] as! Int32
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SeriesMasterId") && dict["SeriesMasterId"] != nil {
            self.seriesMasterId = dict["SeriesMasterId"] as! String
        }
        if dict.keys.contains("ShowDeleted") && dict["ShowDeleted"] != nil {
            self.showDeleted = dict["ShowDeleted"] as! Bool
        }
        if dict.keys.contains("SyncToken") && dict["SyncToken"] != nil {
            self.syncToken = dict["SyncToken"] as! String
        }
        if dict.keys.contains("TimeMax") && dict["TimeMax"] != nil {
            self.timeMax = dict["TimeMax"] as! String
        }
        if dict.keys.contains("TimeMin") && dict["TimeMin"] != nil {
            self.timeMin = dict["TimeMin"] as! String
        }
    }
}

public class ListEventsResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class Attendees : Tea.TeaModel {
            public var displayName: String?

            public var isOptional: Bool?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.isOptional != nil {
                    map["IsOptional"] = self.isOptional!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                    self.isOptional = dict["IsOptional"] as! Bool
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class Categories : Tea.TeaModel {
            public var displayName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
            }
        }
        public class End : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public class ExtendedProperties : Tea.TeaModel {
            public class SharedProperties : Tea.TeaModel {
                public var belongCorpId: String?

                public var sourceOpenCid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.belongCorpId != nil {
                        map["BelongCorpId"] = self.belongCorpId!
                    }
                    if self.sourceOpenCid != nil {
                        map["SourceOpenCid"] = self.sourceOpenCid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BelongCorpId") && dict["BelongCorpId"] != nil {
                        self.belongCorpId = dict["BelongCorpId"] as! String
                    }
                    if dict.keys.contains("SourceOpenCid") && dict["SourceOpenCid"] != nil {
                        self.sourceOpenCid = dict["SourceOpenCid"] as! String
                    }
                }
            }
            public var sharedProperties: ListEventsResponseBody.Events.ExtendedProperties.SharedProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sharedProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sharedProperties != nil {
                    map["SharedProperties"] = self.sharedProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SharedProperties") && dict["SharedProperties"] != nil {
                    var model = ListEventsResponseBody.Events.ExtendedProperties.SharedProperties()
                    model.fromMap(dict["SharedProperties"] as! [String: Any])
                    self.sharedProperties = model
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var displayName: String?

            public var meetingRooms: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.meetingRooms != nil {
                    map["MeetingRooms"] = self.meetingRooms!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                    self.meetingRooms = dict["MeetingRooms"] as! [String]
                }
            }
        }
        public class MeetingRooms : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var roomId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.roomId != nil {
                    map["RoomId"] = self.roomId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                    self.roomId = dict["RoomId"] as! String
                }
            }
        }
        public class OnlineMeetingInfo : Tea.TeaModel {
            public var conferenceId: String?

            public var extraInfo: [String: Any]?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conferenceId != nil {
                    map["ConferenceId"] = self.conferenceId!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                    self.conferenceId = dict["ConferenceId"] as! String
                }
                if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                    self.extraInfo = dict["ExtraInfo"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Organizer : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class OriginStart : Tea.TeaModel {
            public var dateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
            }
        }
        public class Recurrence : Tea.TeaModel {
            public class Pattern : Tea.TeaModel {
                public var dayOfMonth: Int32?

                public var daysOfWeek: String?

                public var index: String?

                public var interval: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dayOfMonth != nil {
                        map["DayOfMonth"] = self.dayOfMonth!
                    }
                    if self.daysOfWeek != nil {
                        map["DaysOfWeek"] = self.daysOfWeek!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                        self.dayOfMonth = dict["DayOfMonth"] as! Int32
                    }
                    if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                        self.daysOfWeek = dict["DaysOfWeek"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Range : Tea.TeaModel {
                public var endDate: String?

                public var numberOfOccurrences: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.numberOfOccurrences != nil {
                        map["NumberOfOccurrences"] = self.numberOfOccurrences!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                        self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pattern: ListEventsResponseBody.Events.Recurrence.Pattern?

            public var range: ListEventsResponseBody.Events.Recurrence.Range?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pattern?.validate()
                try self.range?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pattern != nil {
                    map["Pattern"] = self.pattern?.toMap()
                }
                if self.range != nil {
                    map["Range"] = self.range?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    var model = ListEventsResponseBody.Events.Recurrence.Pattern()
                    model.fromMap(dict["Pattern"] as! [String: Any])
                    self.pattern = model
                }
                if dict.keys.contains("Range") && dict["Range"] != nil {
                    var model = ListEventsResponseBody.Events.Recurrence.Range()
                    model.fromMap(dict["Range"] as! [String: Any])
                    self.range = model
                }
            }
        }
        public class Reminders : Tea.TeaModel {
            public var method: String?

            public var minutes: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.minutes != nil {
                    map["Minutes"] = self.minutes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                    self.minutes = dict["Minutes"] as! String
                }
            }
        }
        public class RichTextDescription : Tea.TeaModel {
            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Text") && dict["Text"] != nil {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class Start : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var attendees: [ListEventsResponseBody.Events.Attendees]?

        public var categories: [ListEventsResponseBody.Events.Categories]?

        public var createTime: String?

        public var description_: String?

        public var end: ListEventsResponseBody.Events.End?

        public var extendedProperties: ListEventsResponseBody.Events.ExtendedProperties?

        public var id: String?

        public var isAllDay: Bool?

        public var location: ListEventsResponseBody.Events.Location?

        public var meetingRooms: [ListEventsResponseBody.Events.MeetingRooms]?

        public var onlineMeetingInfo: ListEventsResponseBody.Events.OnlineMeetingInfo?

        public var organizer: ListEventsResponseBody.Events.Organizer?

        public var originStart: ListEventsResponseBody.Events.OriginStart?

        public var recurrence: ListEventsResponseBody.Events.Recurrence?

        public var reminders: [ListEventsResponseBody.Events.Reminders]?

        public var richTextDescription: ListEventsResponseBody.Events.RichTextDescription?

        public var seriesMasterId: String?

        public var start: ListEventsResponseBody.Events.Start?

        public var status: String?

        public var summary: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.end?.validate()
            try self.extendedProperties?.validate()
            try self.location?.validate()
            try self.onlineMeetingInfo?.validate()
            try self.organizer?.validate()
            try self.originStart?.validate()
            try self.recurrence?.validate()
            try self.richTextDescription?.validate()
            try self.start?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendees != nil {
                var tmp : [Any] = []
                for k in self.attendees! {
                    tmp.append(k.toMap())
                }
                map["Attendees"] = tmp
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.end != nil {
                map["End"] = self.end?.toMap()
            }
            if self.extendedProperties != nil {
                map["ExtendedProperties"] = self.extendedProperties?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAllDay != nil {
                map["IsAllDay"] = self.isAllDay!
            }
            if self.location != nil {
                map["Location"] = self.location?.toMap()
            }
            if self.meetingRooms != nil {
                var tmp : [Any] = []
                for k in self.meetingRooms! {
                    tmp.append(k.toMap())
                }
                map["MeetingRooms"] = tmp
            }
            if self.onlineMeetingInfo != nil {
                map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
            }
            if self.organizer != nil {
                map["Organizer"] = self.organizer?.toMap()
            }
            if self.originStart != nil {
                map["OriginStart"] = self.originStart?.toMap()
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence?.toMap()
            }
            if self.reminders != nil {
                var tmp : [Any] = []
                for k in self.reminders! {
                    tmp.append(k.toMap())
                }
                map["Reminders"] = tmp
            }
            if self.richTextDescription != nil {
                map["RichTextDescription"] = self.richTextDescription?.toMap()
            }
            if self.seriesMasterId != nil {
                map["SeriesMasterId"] = self.seriesMasterId!
            }
            if self.start != nil {
                map["Start"] = self.start?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
                var tmp : [ListEventsResponseBody.Events.Attendees] = []
                for v in dict["Attendees"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Attendees()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attendees = tmp
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                var tmp : [ListEventsResponseBody.Events.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("End") && dict["End"] != nil {
                var model = ListEventsResponseBody.Events.End()
                model.fromMap(dict["End"] as! [String: Any])
                self.end = model
            }
            if dict.keys.contains("ExtendedProperties") && dict["ExtendedProperties"] != nil {
                var model = ListEventsResponseBody.Events.ExtendedProperties()
                model.fromMap(dict["ExtendedProperties"] as! [String: Any])
                self.extendedProperties = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
                self.isAllDay = dict["IsAllDay"] as! Bool
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                var model = ListEventsResponseBody.Events.Location()
                model.fromMap(dict["Location"] as! [String: Any])
                self.location = model
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                var tmp : [ListEventsResponseBody.Events.MeetingRooms] = []
                for v in dict["MeetingRooms"] as! [Any] {
                    var model = ListEventsResponseBody.Events.MeetingRooms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.meetingRooms = tmp
            }
            if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
                var model = ListEventsResponseBody.Events.OnlineMeetingInfo()
                model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
                self.onlineMeetingInfo = model
            }
            if dict.keys.contains("Organizer") && dict["Organizer"] != nil {
                var model = ListEventsResponseBody.Events.Organizer()
                model.fromMap(dict["Organizer"] as! [String: Any])
                self.organizer = model
            }
            if dict.keys.contains("OriginStart") && dict["OriginStart"] != nil {
                var model = ListEventsResponseBody.Events.OriginStart()
                model.fromMap(dict["OriginStart"] as! [String: Any])
                self.originStart = model
            }
            if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
                var model = ListEventsResponseBody.Events.Recurrence()
                model.fromMap(dict["Recurrence"] as! [String: Any])
                self.recurrence = model
            }
            if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
                var tmp : [ListEventsResponseBody.Events.Reminders] = []
                for v in dict["Reminders"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Reminders()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reminders = tmp
            }
            if dict.keys.contains("RichTextDescription") && dict["RichTextDescription"] != nil {
                var model = ListEventsResponseBody.Events.RichTextDescription()
                model.fromMap(dict["RichTextDescription"] as! [String: Any])
                self.richTextDescription = model
            }
            if dict.keys.contains("SeriesMasterId") && dict["SeriesMasterId"] != nil {
                self.seriesMasterId = dict["SeriesMasterId"] as! String
            }
            if dict.keys.contains("Start") && dict["Start"] != nil {
                var model = ListEventsResponseBody.Events.Start()
                model.fromMap(dict["Start"] as! [String: Any])
                self.start = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var events: [ListEventsResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public var syncToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["events"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.syncToken != nil {
            map["syncToken"] = self.syncToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("events") && dict["events"] != nil {
            var tmp : [ListEventsResponseBody.Events] = []
            for v in dict["events"] as! [Any] {
                var model = ListEventsResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("syncToken") && dict["syncToken"] != nil {
            self.syncToken = dict["syncToken"] as! String
        }
    }
}

public class ListEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventsViewHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListEventsViewHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListEventsViewHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListEventsViewShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListEventsViewRequest : Tea.TeaModel {
    public var calendarId: String?

    public var maxAttendees: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var timeMax: String?

    public var timeMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.timeMax != nil {
            map["TimeMax"] = self.timeMax!
        }
        if self.timeMin != nil {
            map["TimeMin"] = self.timeMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("MaxAttendees") && dict["MaxAttendees"] != nil {
            self.maxAttendees = dict["MaxAttendees"] as! Int32
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TimeMax") && dict["TimeMax"] != nil {
            self.timeMax = dict["TimeMax"] as! String
        }
        if dict.keys.contains("TimeMin") && dict["TimeMin"] != nil {
            self.timeMin = dict["TimeMin"] as! String
        }
    }
}

public class ListEventsViewResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class Attendees : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var isOptional: Bool?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isOptional != nil {
                    map["IsOptional"] = self.isOptional!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                    self.isOptional = dict["IsOptional"] as! Bool
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class Categories : Tea.TeaModel {
            public var displayName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
            }
        }
        public class End : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public class ExtendedProperties : Tea.TeaModel {
            public class SharedProperties : Tea.TeaModel {
                public var belongCorpId: String?

                public var sourceOpenCid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.belongCorpId != nil {
                        map["BelongCorpId"] = self.belongCorpId!
                    }
                    if self.sourceOpenCid != nil {
                        map["SourceOpenCid"] = self.sourceOpenCid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BelongCorpId") && dict["BelongCorpId"] != nil {
                        self.belongCorpId = dict["BelongCorpId"] as! String
                    }
                    if dict.keys.contains("SourceOpenCid") && dict["SourceOpenCid"] != nil {
                        self.sourceOpenCid = dict["SourceOpenCid"] as! String
                    }
                }
            }
            public var sharedProperties: ListEventsViewResponseBody.Events.ExtendedProperties.SharedProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sharedProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sharedProperties != nil {
                    map["SharedProperties"] = self.sharedProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SharedProperties") && dict["SharedProperties"] != nil {
                    var model = ListEventsViewResponseBody.Events.ExtendedProperties.SharedProperties()
                    model.fromMap(dict["SharedProperties"] as! [String: Any])
                    self.sharedProperties = model
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var displayName: String?

            public var meetingRooms: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.meetingRooms != nil {
                    map["MeetingRooms"] = self.meetingRooms!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                    self.meetingRooms = dict["MeetingRooms"] as! [String]
                }
            }
        }
        public class MeetingRooms : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var roomId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.roomId != nil {
                    map["RoomId"] = self.roomId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                    self.roomId = dict["RoomId"] as! String
                }
            }
        }
        public class OnlineMeetingInfo : Tea.TeaModel {
            public var conferenceId: String?

            public var extraInfo: [String: Any]?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conferenceId != nil {
                    map["ConferenceId"] = self.conferenceId!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                    self.conferenceId = dict["ConferenceId"] as! String
                }
                if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                    self.extraInfo = dict["ExtraInfo"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Organizer : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class OriginStart : Tea.TeaModel {
            public var dateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
            }
        }
        public class Recurrence : Tea.TeaModel {
            public class Pattern : Tea.TeaModel {
                public var dayOfMonth: Int32?

                public var daysOfWeek: String?

                public var index: String?

                public var interval: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dayOfMonth != nil {
                        map["DayOfMonth"] = self.dayOfMonth!
                    }
                    if self.daysOfWeek != nil {
                        map["DaysOfWeek"] = self.daysOfWeek!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                        self.dayOfMonth = dict["DayOfMonth"] as! Int32
                    }
                    if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                        self.daysOfWeek = dict["DaysOfWeek"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Range : Tea.TeaModel {
                public var endDate: String?

                public var numberOfOccurrences: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.numberOfOccurrences != nil {
                        map["NumberOfOccurrences"] = self.numberOfOccurrences!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                        self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pattern: ListEventsViewResponseBody.Events.Recurrence.Pattern?

            public var range: ListEventsViewResponseBody.Events.Recurrence.Range?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pattern?.validate()
                try self.range?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pattern != nil {
                    map["Pattern"] = self.pattern?.toMap()
                }
                if self.range != nil {
                    map["Range"] = self.range?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    var model = ListEventsViewResponseBody.Events.Recurrence.Pattern()
                    model.fromMap(dict["Pattern"] as! [String: Any])
                    self.pattern = model
                }
                if dict.keys.contains("Range") && dict["Range"] != nil {
                    var model = ListEventsViewResponseBody.Events.Recurrence.Range()
                    model.fromMap(dict["Range"] as! [String: Any])
                    self.range = model
                }
            }
        }
        public class RichTextDescription : Tea.TeaModel {
            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Text") && dict["Text"] != nil {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class Start : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var attendees: [ListEventsViewResponseBody.Events.Attendees]?

        public var categories: [ListEventsViewResponseBody.Events.Categories]?

        public var createTime: String?

        public var description_: String?

        public var end: ListEventsViewResponseBody.Events.End?

        public var extendedProperties: ListEventsViewResponseBody.Events.ExtendedProperties?

        public var id: String?

        public var isAllDay: Bool?

        public var location: ListEventsViewResponseBody.Events.Location?

        public var meetingRooms: [ListEventsViewResponseBody.Events.MeetingRooms]?

        public var onlineMeetingInfo: ListEventsViewResponseBody.Events.OnlineMeetingInfo?

        public var organizer: ListEventsViewResponseBody.Events.Organizer?

        public var originStart: ListEventsViewResponseBody.Events.OriginStart?

        public var recurrence: ListEventsViewResponseBody.Events.Recurrence?

        public var richTextDescription: ListEventsViewResponseBody.Events.RichTextDescription?

        public var seriesMasterId: String?

        public var start: ListEventsViewResponseBody.Events.Start?

        public var status: String?

        public var summary: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.end?.validate()
            try self.extendedProperties?.validate()
            try self.location?.validate()
            try self.onlineMeetingInfo?.validate()
            try self.organizer?.validate()
            try self.originStart?.validate()
            try self.recurrence?.validate()
            try self.richTextDescription?.validate()
            try self.start?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendees != nil {
                var tmp : [Any] = []
                for k in self.attendees! {
                    tmp.append(k.toMap())
                }
                map["Attendees"] = tmp
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.end != nil {
                map["End"] = self.end?.toMap()
            }
            if self.extendedProperties != nil {
                map["ExtendedProperties"] = self.extendedProperties?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAllDay != nil {
                map["IsAllDay"] = self.isAllDay!
            }
            if self.location != nil {
                map["Location"] = self.location?.toMap()
            }
            if self.meetingRooms != nil {
                var tmp : [Any] = []
                for k in self.meetingRooms! {
                    tmp.append(k.toMap())
                }
                map["MeetingRooms"] = tmp
            }
            if self.onlineMeetingInfo != nil {
                map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
            }
            if self.organizer != nil {
                map["Organizer"] = self.organizer?.toMap()
            }
            if self.originStart != nil {
                map["OriginStart"] = self.originStart?.toMap()
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence?.toMap()
            }
            if self.richTextDescription != nil {
                map["RichTextDescription"] = self.richTextDescription?.toMap()
            }
            if self.seriesMasterId != nil {
                map["SeriesMasterId"] = self.seriesMasterId!
            }
            if self.start != nil {
                map["Start"] = self.start?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
                var tmp : [ListEventsViewResponseBody.Events.Attendees] = []
                for v in dict["Attendees"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.Attendees()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attendees = tmp
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                var tmp : [ListEventsViewResponseBody.Events.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("End") && dict["End"] != nil {
                var model = ListEventsViewResponseBody.Events.End()
                model.fromMap(dict["End"] as! [String: Any])
                self.end = model
            }
            if dict.keys.contains("ExtendedProperties") && dict["ExtendedProperties"] != nil {
                var model = ListEventsViewResponseBody.Events.ExtendedProperties()
                model.fromMap(dict["ExtendedProperties"] as! [String: Any])
                self.extendedProperties = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
                self.isAllDay = dict["IsAllDay"] as! Bool
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                var model = ListEventsViewResponseBody.Events.Location()
                model.fromMap(dict["Location"] as! [String: Any])
                self.location = model
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                var tmp : [ListEventsViewResponseBody.Events.MeetingRooms] = []
                for v in dict["MeetingRooms"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.MeetingRooms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.meetingRooms = tmp
            }
            if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
                var model = ListEventsViewResponseBody.Events.OnlineMeetingInfo()
                model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
                self.onlineMeetingInfo = model
            }
            if dict.keys.contains("Organizer") && dict["Organizer"] != nil {
                var model = ListEventsViewResponseBody.Events.Organizer()
                model.fromMap(dict["Organizer"] as! [String: Any])
                self.organizer = model
            }
            if dict.keys.contains("OriginStart") && dict["OriginStart"] != nil {
                var model = ListEventsViewResponseBody.Events.OriginStart()
                model.fromMap(dict["OriginStart"] as! [String: Any])
                self.originStart = model
            }
            if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
                var model = ListEventsViewResponseBody.Events.Recurrence()
                model.fromMap(dict["Recurrence"] as! [String: Any])
                self.recurrence = model
            }
            if dict.keys.contains("RichTextDescription") && dict["RichTextDescription"] != nil {
                var model = ListEventsViewResponseBody.Events.RichTextDescription()
                model.fromMap(dict["RichTextDescription"] as! [String: Any])
                self.richTextDescription = model
            }
            if dict.keys.contains("SeriesMasterId") && dict["SeriesMasterId"] != nil {
                self.seriesMasterId = dict["SeriesMasterId"] as! String
            }
            if dict.keys.contains("Start") && dict["Start"] != nil {
                var model = ListEventsViewResponseBody.Events.Start()
                model.fromMap(dict["Start"] as! [String: Any])
                self.start = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var events: [ListEventsViewResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["events"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("events") && dict["events"] != nil {
            var tmp : [ListEventsViewResponseBody.Events] = []
            for v in dict["events"] as! [Any] {
                var model = ListEventsViewResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListEventsViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventsViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEventsViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListNodesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListNodesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListNodesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var parentNodeId: String?

    public var tenantContext: ListNodesRequest.TenantContext?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListNodesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListNodesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var parentNodeId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: ListNodesResponseBody.Nodes.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = ListNodesResponseBody.Nodes.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var nodes: [ListNodesResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["nodes"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("nodes") && dict["nodes"] != nil {
            var tmp : [ListNodesResponseBody.Nodes] = []
            for v in dict["nodes"] as! [Any] {
                var model = ListNodesResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var cursor: Int64?

    public var endTime: Int64?

    public var modifiedEndTime: Int64?

    public var modifiedStartTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContext: ListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modifiedEndTime != nil {
            map["ModifiedEndTime"] = self.modifiedEndTime!
        }
        if self.modifiedStartTime != nil {
            map["ModifiedStartTime"] = self.modifiedStartTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedEndTime") && dict["ModifiedEndTime"] != nil {
            self.modifiedEndTime = dict["ModifiedEndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedStartTime") && dict["ModifiedStartTime"] != nil {
            self.modifiedStartTime = dict["ModifiedStartTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListReportShrinkRequest : Tea.TeaModel {
    public var cursor: Int64?

    public var endTime: Int64?

    public var modifiedEndTime: Int64?

    public var modifiedStartTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modifiedEndTime != nil {
            map["ModifiedEndTime"] = self.modifiedEndTime!
        }
        if self.modifiedStartTime != nil {
            map["ModifiedStartTime"] = self.modifiedStartTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedEndTime") && dict["ModifiedEndTime"] != nil {
            self.modifiedEndTime = dict["ModifiedEndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedStartTime") && dict["ModifiedStartTime"] != nil {
            self.modifiedStartTime = dict["ModifiedStartTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListReportResponseBody : Tea.TeaModel {
    public class DataList : Tea.TeaModel {
        public class Contents : Tea.TeaModel {
            public var key: String?

            public var sort: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.sort != nil {
                    map["Sort"] = self.sort!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Sort") && dict["Sort"] != nil {
                    self.sort = dict["Sort"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var contents: [ListReportResponseBody.DataList.Contents]?

        public var createTime: Int64?

        public var creatorId: String?

        public var creatorName: String?

        public var deptName: String?

        public var images: [String]?

        public var latitude: String?

        public var longitude: String?

        public var modifiedTime: Int64?

        public var remark: String?

        public var reportId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contents != nil {
                var tmp : [Any] = []
                for k in self.contents! {
                    tmp.append(k.toMap())
                }
                map["Contents"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.images != nil {
                map["Images"] = self.images!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contents") && dict["Contents"] != nil {
                var tmp : [ListReportResponseBody.DataList.Contents] = []
                for v in dict["Contents"] as! [Any] {
                    var model = ListReportResponseBody.DataList.Contents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contents = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorName") && dict["CreatorName"] != nil {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Images") && dict["Images"] != nil {
                self.images = dict["Images"] as! [String]
            }
            if dict.keys.contains("Latitude") && dict["Latitude"] != nil {
                self.latitude = dict["Latitude"] as! String
            }
            if dict.keys.contains("Longitude") && dict["Longitude"] != nil {
                self.longitude = dict["Longitude"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! Int64
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var dataList: [ListReportResponseBody.DataList]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataList != nil {
            var tmp : [Any] = []
            for k in self.dataList! {
                tmp.append(k.toMap())
            }
            map["dataList"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataList") && dict["dataList"] != nil {
            var tmp : [ListReportResponseBody.DataList] = []
            for v in dict["dataList"] as! [Any] {
                var model = ListReportResponseBody.DataList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataList = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int64
        }
    }
}

public class ListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListWorkspacesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var teamId: String?

    public var tenantContext: ListWorkspacesRequest.TenantContext?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.teamId != nil {
            map["TeamId"] = self.teamId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
            self.teamId = dict["TeamId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListWorkspacesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var teamId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.teamId != nil {
            map["TeamId"] = self.teamId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
            self.teamId = dict["TeamId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListWorkspacesResponseBody : Tea.TeaModel {
    public class Workspaces : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: ListWorkspacesResponseBody.Workspaces.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = ListWorkspacesResponseBody.Workspaces.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var workspaces: [ListWorkspacesResponseBody.Workspaces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspaces != nil {
            var tmp : [Any] = []
            for k in self.workspaces! {
                tmp.append(k.toMap())
            }
            map["workspaces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspaces") && dict["workspaces"] != nil {
            var tmp : [ListWorkspacesResponseBody.Workspaces] = []
            for v in dict["workspaces"] as! [Any] {
                var model = ListWorkspacesResponseBody.Workspaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspaces = tmp
        }
    }
}

public class ListWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PatchEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: PatchEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = PatchEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class PatchEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class PatchEventRequest : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") && dict["isOptional"] != nil {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayName") && dict["displayName"] != nil {
                self.displayName = dict["displayName"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["dayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["daysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.interval != nil {
                    map["interval"] = self.interval!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dayOfMonth") && dict["dayOfMonth"] != nil {
                    self.dayOfMonth = dict["dayOfMonth"] as! Int32
                }
                if dict.keys.contains("daysOfWeek") && dict["daysOfWeek"] != nil {
                    self.daysOfWeek = dict["daysOfWeek"] as! String
                }
                if dict.keys.contains("index") && dict["index"] != nil {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("interval") && dict["interval"] != nil {
                    self.interval = dict["interval"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["endDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["numberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("endDate") && dict["endDate"] != nil {
                    self.endDate = dict["endDate"] as! String
                }
                if dict.keys.contains("numberOfOccurrences") && dict["numberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["numberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var pattern: PatchEventRequest.Recurrence.Pattern?

        public var range: PatchEventRequest.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("pattern") && dict["pattern"] != nil {
                var model = PatchEventRequest.Recurrence.Pattern()
                model.fromMap(dict["pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("range") && dict["range"] != nil {
                var model = PatchEventRequest.Recurrence.Range()
                model.fromMap(dict["range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["method"] = self.method!
            }
            if self.minutes != nil {
                map["minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("method") && dict["method"] != nil {
                self.method = dict["method"] as! String
            }
            if dict.keys.contains("minutes") && dict["minutes"] != nil {
                self.minutes = dict["minutes"] as! Int32
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public var attendees: [PatchEventRequest.Attendees]?

    public var calendarId: String?

    public var description_: String?

    public var end: PatchEventRequest.End?

    public var eventId: String?

    public var extra: [String: String]?

    public var isAllDay: Bool?

    public var location: PatchEventRequest.Location?

    public var recurrence: PatchEventRequest.Recurrence?

    public var reminders: [PatchEventRequest.Reminders]?

    public var start: PatchEventRequest.Start?

    public var summary: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["Attendees"] = tmp
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.end != nil {
            map["End"] = self.end?.toMap()
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.extra != nil {
            map["Extra"] = self.extra!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["Location"] = self.location?.toMap()
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["Reminders"] = tmp
        }
        if self.start != nil {
            map["Start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            var tmp : [PatchEventRequest.Attendees] = []
            for v in dict["Attendees"] as! [Any] {
                var model = PatchEventRequest.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            var model = PatchEventRequest.End()
            model.fromMap(dict["End"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extra = dict["Extra"] as! [String: String]
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            var model = PatchEventRequest.Location()
            model.fromMap(dict["Location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            var model = PatchEventRequest.Recurrence()
            model.fromMap(dict["Recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            var tmp : [PatchEventRequest.Reminders] = []
            for v in dict["Reminders"] as! [Any] {
                var model = PatchEventRequest.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("Start") && dict["Start"] != nil {
            var model = PatchEventRequest.Start()
            model.fromMap(dict["Start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
    }
}

public class PatchEventShrinkRequest : Tea.TeaModel {
    public var attendeesShrink: String?

    public var calendarId: String?

    public var description_: String?

    public var endShrink: String?

    public var eventId: String?

    public var extraShrink: String?

    public var isAllDay: Bool?

    public var locationShrink: String?

    public var recurrenceShrink: String?

    public var remindersShrink: String?

    public var startShrink: String?

    public var summary: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesShrink != nil {
            map["Attendees"] = self.attendeesShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endShrink != nil {
            map["End"] = self.endShrink!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.extraShrink != nil {
            map["Extra"] = self.extraShrink!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.locationShrink != nil {
            map["Location"] = self.locationShrink!
        }
        if self.recurrenceShrink != nil {
            map["Recurrence"] = self.recurrenceShrink!
        }
        if self.remindersShrink != nil {
            map["Reminders"] = self.remindersShrink!
        }
        if self.startShrink != nil {
            map["Start"] = self.startShrink!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            self.attendeesShrink = dict["Attendees"] as! String
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            self.endShrink = dict["End"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extraShrink = dict["Extra"] as! String
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            self.locationShrink = dict["Location"] as! String
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            self.recurrenceShrink = dict["Recurrence"] as! String
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            self.remindersShrink = dict["Reminders"] as! String
        }
        if dict.keys.contains("Start") && dict["Start"] != nil {
            self.startShrink = dict["Start"] as! String
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
    }
}

public class PatchEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public var meetingRooms: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.meetingRooms != nil {
                map["MeetingRooms"] = self.meetingRooms!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                self.meetingRooms = dict["MeetingRooms"] as! [String]
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: PatchEventResponseBody.Recurrence.Pattern?

        public var range: PatchEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                var model = PatchEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                var model = PatchEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var attendees: [PatchEventResponseBody.Attendees]?

    public var createTime: String?

    public var description_: String?

    public var end: PatchEventResponseBody.End?

    public var id: String?

    public var isAllDay: Bool?

    public var location: PatchEventResponseBody.Location?

    public var organizer: PatchEventResponseBody.Organizer?

    public var recurrence: PatchEventResponseBody.Recurrence?

    public var reminders: [PatchEventResponseBody.Reminders]?

    public var requestId: String?

    public var start: PatchEventResponseBody.Start?

    public var summary: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.organizer?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") && dict["attendees"] != nil {
            var tmp : [PatchEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = PatchEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") && dict["end"] != nil {
            var model = PatchEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") && dict["isAllDay"] != nil {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") && dict["location"] != nil {
            var model = PatchEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("organizer") && dict["organizer"] != nil {
            var model = PatchEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("recurrence") && dict["recurrence"] != nil {
            var model = PatchEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") && dict["reminders"] != nil {
            var tmp : [PatchEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = PatchEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = PatchEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("summary") && dict["summary"] != nil {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class PatchEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PatchEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PatchEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordTextHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordTextHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryCloudRecordTextHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordTextShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordTextRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: Int64?

    public var startTime: Int64?

    public var tenantContext: QueryCloudRecordTextRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryCloudRecordTextRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordTextShrinkRequest : Tea.TeaModel {
    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordTextResponseBody : Tea.TeaModel {
    public class ParagraphList : Tea.TeaModel {
        public class SentenceList : Tea.TeaModel {
            public class WordList : Tea.TeaModel {
                public var endTime: Int64?

                public var startTime: Int64?

                public var word: String?

                public var wordId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.word != nil {
                        map["Word"] = self.word!
                    }
                    if self.wordId != nil {
                        map["WordId"] = self.wordId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Word") && dict["Word"] != nil {
                        self.word = dict["Word"] as! String
                    }
                    if dict.keys.contains("WordId") && dict["WordId"] != nil {
                        self.wordId = dict["WordId"] as! String
                    }
                }
            }
            public var endTime: Int64?

            public var sentence: String?

            public var startTime: Int64?

            public var userId: String?

            public var wordList: [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.sentence != nil {
                    map["Sentence"] = self.sentence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.wordList != nil {
                    var tmp : [Any] = []
                    for k in self.wordList! {
                        tmp.append(k.toMap())
                    }
                    map["WordList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Sentence") && dict["Sentence"] != nil {
                    self.sentence = dict["Sentence"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WordList") && dict["WordList"] != nil {
                    var tmp : [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList] = []
                    for v in dict["WordList"] as! [Any] {
                        var model = QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wordList = tmp
                }
            }
        }
        public var endTime: Int64?

        public var nextTtoken: Int64?

        public var nickName: String?

        public var paragraph: String?

        public var recordId: Int64?

        public var sentenceList: [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList]?

        public var startTime: Int64?

        public var status: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.nextTtoken != nil {
                map["NextTtoken"] = self.nextTtoken!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.paragraph != nil {
                map["Paragraph"] = self.paragraph!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.sentenceList != nil {
                var tmp : [Any] = []
                for k in self.sentenceList! {
                    tmp.append(k.toMap())
                }
                map["SentenceList"] = tmp
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("NextTtoken") && dict["NextTtoken"] != nil {
                self.nextTtoken = dict["NextTtoken"] as! Int64
            }
            if dict.keys.contains("NickName") && dict["NickName"] != nil {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("Paragraph") && dict["Paragraph"] != nil {
                self.paragraph = dict["Paragraph"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! Int64
            }
            if dict.keys.contains("SentenceList") && dict["SentenceList"] != nil {
                var tmp : [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList] = []
                for v in dict["SentenceList"] as! [Any] {
                    var model = QueryCloudRecordTextResponseBody.ParagraphList.SentenceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sentenceList = tmp
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var hasMore: Bool?

    public var paragraphList: [QueryCloudRecordTextResponseBody.ParagraphList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.paragraphList != nil {
            var tmp : [Any] = []
            for k in self.paragraphList! {
                tmp.append(k.toMap())
            }
            map["paragraphList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("paragraphList") && dict["paragraphList"] != nil {
            var tmp : [QueryCloudRecordTextResponseBody.ParagraphList] = []
            for v in dict["paragraphList"] as! [Any] {
                var model = QueryCloudRecordTextResponseBody.ParagraphList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paragraphList = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryCloudRecordTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCloudRecordTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordVideoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordVideoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryCloudRecordVideoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordVideoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryCloudRecordVideoRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryCloudRecordVideoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordVideoShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordVideoResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public var duration: Int64?

        public var endTime: Int64?

        public var fileSize: Int64?

        public var mediaId: String?

        public var recordId: String?

        public var recordType: Int64?

        public var regionId: String?

        public var startTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordType != nil {
                map["RecordType"] = self.recordType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordType") && dict["RecordType"] != nil {
                self.recordType = dict["RecordType"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var videoList: [QueryCloudRecordVideoResponseBody.VideoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.videoList != nil {
            var tmp : [Any] = []
            for k in self.videoList! {
                tmp.append(k.toMap())
            }
            map["videoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("videoList") && dict["videoList"] != nil {
            var tmp : [QueryCloudRecordVideoResponseBody.VideoList] = []
            for v in dict["videoList"] as! [Any] {
                var model = QueryCloudRecordVideoResponseBody.VideoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoList = tmp
        }
    }
}

public class QueryCloudRecordVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCloudRecordVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordVideoPlayInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryCloudRecordVideoPlayInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoPlayInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var conferenceId: String?

    public var mediaId: String?

    public var regionId: String?

    public var tenantContext: QueryCloudRecordVideoPlayInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryCloudRecordVideoPlayInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoShrinkRequest : Tea.TeaModel {
    public var conferenceId: String?

    public var mediaId: String?

    public var regionId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoPlayInfoResponseBody : Tea.TeaModel {
    public var duration: Int64?

    public var fileSize: Int64?

    public var mp4FileUrl: String?

    public var playUrl: String?

    public var requestId: String?

    public var status: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.fileSize != nil {
            map["fileSize"] = self.fileSize!
        }
        if self.mp4FileUrl != nil {
            map["mp4FileUrl"] = self.mp4FileUrl!
        }
        if self.playUrl != nil {
            map["playUrl"] = self.playUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("duration") && dict["duration"] != nil {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("fileSize") && dict["fileSize"] != nil {
            self.fileSize = dict["fileSize"] as! Int64
        }
        if dict.keys.contains("mp4FileUrl") && dict["mp4FileUrl"] != nil {
            self.mp4FileUrl = dict["mp4FileUrl"] as! String
        }
        if dict.keys.contains("playUrl") && dict["playUrl"] != nil {
            self.playUrl = dict["playUrl"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! Int64
        }
    }
}

public class QueryCloudRecordVideoPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordVideoPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCloudRecordVideoPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryConferenceInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceInfoRequest : Tea.TeaModel {
    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceInfoResponseBody : Tea.TeaModel {
    public class ConfInfo : Tea.TeaModel {
        public var activeNum: Int32?

        public var attendNum: Int32?

        public var confDuration: Int64?

        public var conferenceId: String?

        public var creatorId: String?

        public var creatorNick: String?

        public var endTime: Int64?

        public var externalLinkUrl: String?

        public var invitedNum: Int32?

        public var roomCode: String?

        public var startTime: Int64?

        public var status: Int32?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeNum != nil {
                map["ActiveNum"] = self.activeNum!
            }
            if self.attendNum != nil {
                map["AttendNum"] = self.attendNum!
            }
            if self.confDuration != nil {
                map["ConfDuration"] = self.confDuration!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorNick != nil {
                map["CreatorNick"] = self.creatorNick!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.externalLinkUrl != nil {
                map["ExternalLinkUrl"] = self.externalLinkUrl!
            }
            if self.invitedNum != nil {
                map["InvitedNum"] = self.invitedNum!
            }
            if self.roomCode != nil {
                map["RoomCode"] = self.roomCode!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveNum") && dict["ActiveNum"] != nil {
                self.activeNum = dict["ActiveNum"] as! Int32
            }
            if dict.keys.contains("AttendNum") && dict["AttendNum"] != nil {
                self.attendNum = dict["AttendNum"] as! Int32
            }
            if dict.keys.contains("ConfDuration") && dict["ConfDuration"] != nil {
                self.confDuration = dict["ConfDuration"] as! Int64
            }
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorNick") && dict["CreatorNick"] != nil {
                self.creatorNick = dict["CreatorNick"] as! String
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExternalLinkUrl") && dict["ExternalLinkUrl"] != nil {
                self.externalLinkUrl = dict["ExternalLinkUrl"] as! String
            }
            if dict.keys.contains("InvitedNum") && dict["InvitedNum"] != nil {
                self.invitedNum = dict["InvitedNum"] as! Int32
            }
            if dict.keys.contains("RoomCode") && dict["RoomCode"] != nil {
                self.roomCode = dict["RoomCode"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var confInfo: QueryConferenceInfoResponseBody.ConfInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.confInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confInfo != nil {
            map["confInfo"] = self.confInfo?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("confInfo") && dict["confInfo"] != nil {
            var model = QueryConferenceInfoResponseBody.ConfInfo()
            model.fromMap(dict["confInfo"] as! [String: Any])
            self.confInfo = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryConferenceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryConferenceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryConferenceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceMembersRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContext: QueryConferenceMembersRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryConferenceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceMembersShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceMembersResponseBody : Tea.TeaModel {
    public class MemberModels : Tea.TeaModel {
        public var attendStatus: Int32?

        public var coHost: Bool?

        public var conferenceId: String?

        public var duration: Int64?

        public var host: Bool?

        public var joinTime: Int64?

        public var leaveTime: Int64?

        public var outerOrgMember: Bool?

        public var pstnJoin: Bool?

        public var userId: String?

        public var userNick: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendStatus != nil {
                map["AttendStatus"] = self.attendStatus!
            }
            if self.coHost != nil {
                map["CoHost"] = self.coHost!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.joinTime != nil {
                map["JoinTime"] = self.joinTime!
            }
            if self.leaveTime != nil {
                map["LeaveTime"] = self.leaveTime!
            }
            if self.outerOrgMember != nil {
                map["OuterOrgMember"] = self.outerOrgMember!
            }
            if self.pstnJoin != nil {
                map["PstnJoin"] = self.pstnJoin!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userNick != nil {
                map["UserNick"] = self.userNick!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttendStatus") && dict["AttendStatus"] != nil {
                self.attendStatus = dict["AttendStatus"] as! Int32
            }
            if dict.keys.contains("CoHost") && dict["CoHost"] != nil {
                self.coHost = dict["CoHost"] as! Bool
            }
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! Bool
            }
            if dict.keys.contains("JoinTime") && dict["JoinTime"] != nil {
                self.joinTime = dict["JoinTime"] as! Int64
            }
            if dict.keys.contains("LeaveTime") && dict["LeaveTime"] != nil {
                self.leaveTime = dict["LeaveTime"] as! Int64
            }
            if dict.keys.contains("OuterOrgMember") && dict["OuterOrgMember"] != nil {
                self.outerOrgMember = dict["OuterOrgMember"] as! Bool
            }
            if dict.keys.contains("PstnJoin") && dict["PstnJoin"] != nil {
                self.pstnJoin = dict["PstnJoin"] as! Bool
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
                self.userNick = dict["UserNick"] as! String
            }
        }
    }
    public var memberModels: [QueryConferenceMembersResponseBody.MemberModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberModels != nil {
            var tmp : [Any] = []
            for k in self.memberModels! {
                tmp.append(k.toMap())
            }
            map["memberModels"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("memberModels") && dict["memberModels"] != nil {
            var tmp : [QueryConferenceMembersResponseBody.MemberModels] = []
            for v in dict["memberModels"] as! [Any] {
                var model = QueryConferenceMembersResponseBody.MemberModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.memberModels = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class QueryConferenceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryConferenceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDentryHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryDentryHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryDentryHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryDentryShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryDentryRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var includeSpace: Bool?

    public var spaceId: String?

    public var tenantContext: QueryDentryRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.includeSpace != nil {
            map["IncludeSpace"] = self.includeSpace!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("IncludeSpace") && dict["IncludeSpace"] != nil {
            self.includeSpace = dict["IncludeSpace"] as! Bool
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryDentryRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryDentryShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var includeSpace: Bool?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.includeSpace != nil {
            map["IncludeSpace"] = self.includeSpace!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("IncludeSpace") && dict["IncludeSpace"] != nil {
            self.includeSpace = dict["IncludeSpace"] as! Bool
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryDentryResponseBody : Tea.TeaModel {
    public class Creator : Tea.TeaModel {
        public var name: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class LinkSourceInfo : Tea.TeaModel {
        public class IconUrl : Tea.TeaModel {
            public var line: String?

            public var small: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.small != nil {
                    map["Small"] = self.small!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Line") && dict["Line"] != nil {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Small") && dict["Small"] != nil {
                    self.small = dict["Small"] as! String
                }
            }
        }
        public var extension_: String?

        public var iconUrl: QueryDentryResponseBody.LinkSourceInfo.IconUrl?

        public var id: String?

        public var linkType: Int64?

        public var spaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.iconUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.linkType != nil {
                map["LinkType"] = self.linkType!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                var model = QueryDentryResponseBody.LinkSourceInfo.IconUrl()
                model.fromMap(dict["IconUrl"] as! [String: Any])
                self.iconUrl = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LinkType") && dict["LinkType"] != nil {
                self.linkType = dict["LinkType"] as! Int64
            }
            if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                self.spaceId = dict["SpaceId"] as! String
            }
        }
    }
    public class Space : Tea.TeaModel {
        public class HdIconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class IconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Owner : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class RecentList : Tea.TeaModel {
            public class Creator : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class LinkSourceInfo : Tea.TeaModel {
                public class IconUrl : Tea.TeaModel {
                    public var line: String?

                    public var small: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.small != nil {
                            map["Small"] = self.small!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Line") && dict["Line"] != nil {
                            self.line = dict["Line"] as! String
                        }
                        if dict.keys.contains("Small") && dict["Small"] != nil {
                            self.small = dict["Small"] as! String
                        }
                    }
                }
                public var extension_: String?

                public var iconUrl: QueryDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl?

                public var id: String?

                public var linkType: Int64?

                public var spaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.iconUrl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.iconUrl != nil {
                        map["IconUrl"] = self.iconUrl?.toMap()
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.linkType != nil {
                        map["LinkType"] = self.linkType!
                    }
                    if self.spaceId != nil {
                        map["SpaceId"] = self.spaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") && dict["Extension"] != nil {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                        var model = QueryDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl()
                        model.fromMap(dict["IconUrl"] as! [String: Any])
                        self.iconUrl = model
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("LinkType") && dict["LinkType"] != nil {
                        self.linkType = dict["LinkType"] as! Int64
                    }
                    if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                        self.spaceId = dict["SpaceId"] as! String
                    }
                }
            }
            public class StatisticalInfo : Tea.TeaModel {
                public var wordCount: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.wordCount != nil {
                        map["WordCount"] = self.wordCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                        self.wordCount = dict["WordCount"] as! Int64
                    }
                }
            }
            public class Updater : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var contentType: String?

            public var createdTime: Int64?

            public var creator: QueryDentryResponseBody.Space.RecentList.Creator?

            public var dentryId: String?

            public var dentryType: String?

            public var dentryUuid: String?

            public var docKey: String?

            public var extension_: String?

            public var hasChildren: Bool?

            public var linkSourceInfo: QueryDentryResponseBody.Space.RecentList.LinkSourceInfo?

            public var name: String?

            public var path: String?

            public var space: Any?

            public var spaceId: String?

            public var statisticalInfo: QueryDentryResponseBody.Space.RecentList.StatisticalInfo?

            public var updatedTime: Int64?

            public var updater: QueryDentryResponseBody.Space.RecentList.Updater?

            public var url: String?

            public var visitorInfo: QueryDentryResponseBody.Space.RecentList.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.creator?.validate()
                try self.linkSourceInfo?.validate()
                try self.statisticalInfo?.validate()
                try self.updater?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator?.toMap()
                }
                if self.dentryId != nil {
                    map["DentryId"] = self.dentryId!
                }
                if self.dentryType != nil {
                    map["DentryType"] = self.dentryType!
                }
                if self.dentryUuid != nil {
                    map["DentryUuid"] = self.dentryUuid!
                }
                if self.docKey != nil {
                    map["DocKey"] = self.docKey!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.hasChildren != nil {
                    map["HasChildren"] = self.hasChildren!
                }
                if self.linkSourceInfo != nil {
                    map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.space != nil {
                    map["Space"] = self.space!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                if self.statisticalInfo != nil {
                    map["StatisticalInfo"] = self.statisticalInfo?.toMap()
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.updater != nil {
                    map["Updater"] = self.updater?.toMap()
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.Creator()
                    model.fromMap(dict["Creator"] as! [String: Any])
                    self.creator = model
                }
                if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
                    self.dentryId = dict["DentryId"] as! String
                }
                if dict.keys.contains("DentryType") && dict["DentryType"] != nil {
                    self.dentryType = dict["DentryType"] as! String
                }
                if dict.keys.contains("DentryUuid") && dict["DentryUuid"] != nil {
                    self.dentryUuid = dict["DentryUuid"] as! String
                }
                if dict.keys.contains("DocKey") && dict["DocKey"] != nil {
                    self.docKey = dict["DocKey"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                    self.hasChildren = dict["HasChildren"] as! Bool
                }
                if dict.keys.contains("LinkSourceInfo") && dict["LinkSourceInfo"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.LinkSourceInfo()
                    model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                    self.linkSourceInfo = model
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Space") && dict["Space"] != nil {
                    self.space = dict["Space"] as! Any
                }
                if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                    self.spaceId = dict["SpaceId"] as! String
                }
                if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.StatisticalInfo()
                    model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                    self.statisticalInfo = model
                }
                if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
                if dict.keys.contains("Updater") && dict["Updater"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.Updater()
                    model.fromMap(dict["Updater"] as! [String: Any])
                    self.updater = model
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var cover: String?

        public var description_: String?

        public var hdIconVO: QueryDentryResponseBody.Space.HdIconVO?

        public var iconVO: QueryDentryResponseBody.Space.IconVO?

        public var id: String?

        public var name: String?

        public var owner: QueryDentryResponseBody.Space.Owner?

        public var recentList: [QueryDentryResponseBody.Space.RecentList]?

        public var type: Int32?

        public var url: String?

        public var visitorInfo: QueryDentryResponseBody.Space.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.hdIconVO?.validate()
            try self.iconVO?.validate()
            try self.owner?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hdIconVO != nil {
                map["HdIconVO"] = self.hdIconVO?.toMap()
            }
            if self.iconVO != nil {
                map["IconVO"] = self.iconVO?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner?.toMap()
            }
            if self.recentList != nil {
                var tmp : [Any] = []
                for k in self.recentList! {
                    tmp.append(k.toMap())
                }
                map["RecentList"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("HdIconVO") && dict["HdIconVO"] != nil {
                var model = QueryDentryResponseBody.Space.HdIconVO()
                model.fromMap(dict["HdIconVO"] as! [String: Any])
                self.hdIconVO = model
            }
            if dict.keys.contains("IconVO") && dict["IconVO"] != nil {
                var model = QueryDentryResponseBody.Space.IconVO()
                model.fromMap(dict["IconVO"] as! [String: Any])
                self.iconVO = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") && dict["Owner"] != nil {
                var model = QueryDentryResponseBody.Space.Owner()
                model.fromMap(dict["Owner"] as! [String: Any])
                self.owner = model
            }
            if dict.keys.contains("RecentList") && dict["RecentList"] != nil {
                var tmp : [QueryDentryResponseBody.Space.RecentList] = []
                for v in dict["RecentList"] as! [Any] {
                    var model = QueryDentryResponseBody.Space.RecentList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recentList = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                var model = QueryDentryResponseBody.Space.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public class Updater : Tea.TeaModel {
        public var name: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class VisitorInfo : Tea.TeaModel {
        public var dentryActions: [String]?

        public var roleCode: String?

        public var spaceActions: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dentryActions != nil {
                map["DentryActions"] = self.dentryActions!
            }
            if self.roleCode != nil {
                map["RoleCode"] = self.roleCode!
            }
            if self.spaceActions != nil {
                map["SpaceActions"] = self.spaceActions!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                self.dentryActions = dict["DentryActions"] as! [String]
            }
            if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                self.roleCode = dict["RoleCode"] as! String
            }
            if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                self.spaceActions = dict["SpaceActions"] as! [String]
            }
        }
    }
    public var contentType: String?

    public var createdTime: Int64?

    public var creator: QueryDentryResponseBody.Creator?

    public var dentryId: String?

    public var dentryType: String?

    public var dentryUuid: String?

    public var docKey: String?

    public var extension_: String?

    public var hasChildren: Bool?

    public var linkSourceInfo: QueryDentryResponseBody.LinkSourceInfo?

    public var name: String?

    public var path: String?

    public var requestId: String?

    public var space: QueryDentryResponseBody.Space?

    public var spaceId: String?

    public var updatedTime: Int64?

    public var updater: QueryDentryResponseBody.Updater?

    public var url: String?

    public var visitorInfo: QueryDentryResponseBody.VisitorInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.creator?.validate()
        try self.linkSourceInfo?.validate()
        try self.space?.validate()
        try self.updater?.validate()
        try self.visitorInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentType != nil {
            map["contentType"] = self.contentType!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creator != nil {
            map["creator"] = self.creator?.toMap()
        }
        if self.dentryId != nil {
            map["dentryId"] = self.dentryId!
        }
        if self.dentryType != nil {
            map["dentryType"] = self.dentryType!
        }
        if self.dentryUuid != nil {
            map["dentryUuid"] = self.dentryUuid!
        }
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hasChildren != nil {
            map["hasChildren"] = self.hasChildren!
        }
        if self.linkSourceInfo != nil {
            map["linkSourceInfo"] = self.linkSourceInfo?.toMap()
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.space != nil {
            map["space"] = self.space?.toMap()
        }
        if self.spaceId != nil {
            map["spaceId"] = self.spaceId!
        }
        if self.updatedTime != nil {
            map["updatedTime"] = self.updatedTime!
        }
        if self.updater != nil {
            map["updater"] = self.updater?.toMap()
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.visitorInfo != nil {
            map["visitorInfo"] = self.visitorInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("contentType") && dict["contentType"] != nil {
            self.contentType = dict["contentType"] as! String
        }
        if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creator") && dict["creator"] != nil {
            var model = QueryDentryResponseBody.Creator()
            model.fromMap(dict["creator"] as! [String: Any])
            self.creator = model
        }
        if dict.keys.contains("dentryId") && dict["dentryId"] != nil {
            self.dentryId = dict["dentryId"] as! String
        }
        if dict.keys.contains("dentryType") && dict["dentryType"] != nil {
            self.dentryType = dict["dentryType"] as! String
        }
        if dict.keys.contains("dentryUuid") && dict["dentryUuid"] != nil {
            self.dentryUuid = dict["dentryUuid"] as! String
        }
        if dict.keys.contains("docKey") && dict["docKey"] != nil {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("extension") && dict["extension"] != nil {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hasChildren") && dict["hasChildren"] != nil {
            self.hasChildren = dict["hasChildren"] as! Bool
        }
        if dict.keys.contains("linkSourceInfo") && dict["linkSourceInfo"] != nil {
            var model = QueryDentryResponseBody.LinkSourceInfo()
            model.fromMap(dict["linkSourceInfo"] as! [String: Any])
            self.linkSourceInfo = model
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("path") && dict["path"] != nil {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("space") && dict["space"] != nil {
            var model = QueryDentryResponseBody.Space()
            model.fromMap(dict["space"] as! [String: Any])
            self.space = model
        }
        if dict.keys.contains("spaceId") && dict["spaceId"] != nil {
            self.spaceId = dict["spaceId"] as! String
        }
        if dict.keys.contains("updatedTime") && dict["updatedTime"] != nil {
            self.updatedTime = dict["updatedTime"] as! Int64
        }
        if dict.keys.contains("updater") && dict["updater"] != nil {
            var model = QueryDentryResponseBody.Updater()
            model.fromMap(dict["updater"] as! [String: Any])
            self.updater = model
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("visitorInfo") && dict["visitorInfo"] != nil {
            var model = QueryDentryResponseBody.VisitorInfo()
            model.fromMap(dict["visitorInfo"] as! [String: Any])
            self.visitorInfo = model
        }
    }
}

public class QueryDentryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDentryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryDentryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryLiveInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: QueryLiveInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryLiveInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveInfoShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveInfoResponseBody : Tea.TeaModel {
    public var coverUrl: String?

    public var duration: Int64?

    public var endTime: Int64?

    public var introduction: String?

    public var liveId: String?

    public var livePlayUrl: String?

    public var liveStatus: Int32?

    public var playbackDuration: Int64?

    public var requestId: String?

    public var startTime: Int64?

    public var subscribeCount: Int32?

    public var title: String?

    public var uv: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["coverUrl"] = self.coverUrl!
        }
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.introduction != nil {
            map["introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.livePlayUrl != nil {
            map["livePlayUrl"] = self.livePlayUrl!
        }
        if self.liveStatus != nil {
            map["liveStatus"] = self.liveStatus!
        }
        if self.playbackDuration != nil {
            map["playbackDuration"] = self.playbackDuration!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subscribeCount != nil {
            map["subscribeCount"] = self.subscribeCount!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("coverUrl") && dict["coverUrl"] != nil {
            self.coverUrl = dict["coverUrl"] as! String
        }
        if dict.keys.contains("duration") && dict["duration"] != nil {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("introduction") && dict["introduction"] != nil {
            self.introduction = dict["introduction"] as! String
        }
        if dict.keys.contains("liveId") && dict["liveId"] != nil {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("livePlayUrl") && dict["livePlayUrl"] != nil {
            self.livePlayUrl = dict["livePlayUrl"] as! String
        }
        if dict.keys.contains("liveStatus") && dict["liveStatus"] != nil {
            self.liveStatus = dict["liveStatus"] as! Int32
        }
        if dict.keys.contains("playbackDuration") && dict["playbackDuration"] != nil {
            self.playbackDuration = dict["playbackDuration"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subscribeCount") && dict["subscribeCount"] != nil {
            self.subscribeCount = dict["subscribeCount"] as! Int32
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("uv") && dict["uv"] != nil {
            self.uv = dict["uv"] as! Int32
        }
    }
}

public class QueryLiveInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLiveInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveWatchDetailHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveWatchDetailHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryLiveWatchDetailHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveWatchDetailShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveWatchDetailRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: QueryLiveWatchDetailRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryLiveWatchDetailRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveWatchDetailShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveWatchDetailResponseBody : Tea.TeaModel {
    public var avgWatchTime: Int64?

    public var liveUv: Int32?

    public var msgCount: Int32?

    public var playbackUv: Int32?

    public var praiseCount: Int32?

    public var pv: Int32?

    public var requestId: String?

    public var totalWatchTime: Int64?

    public var uv: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avgWatchTime != nil {
            map["avgWatchTime"] = self.avgWatchTime!
        }
        if self.liveUv != nil {
            map["liveUv"] = self.liveUv!
        }
        if self.msgCount != nil {
            map["msgCount"] = self.msgCount!
        }
        if self.playbackUv != nil {
            map["playbackUv"] = self.playbackUv!
        }
        if self.praiseCount != nil {
            map["praiseCount"] = self.praiseCount!
        }
        if self.pv != nil {
            map["pv"] = self.pv!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalWatchTime != nil {
            map["totalWatchTime"] = self.totalWatchTime!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("avgWatchTime") && dict["avgWatchTime"] != nil {
            self.avgWatchTime = dict["avgWatchTime"] as! Int64
        }
        if dict.keys.contains("liveUv") && dict["liveUv"] != nil {
            self.liveUv = dict["liveUv"] as! Int32
        }
        if dict.keys.contains("msgCount") && dict["msgCount"] != nil {
            self.msgCount = dict["msgCount"] as! Int32
        }
        if dict.keys.contains("playbackUv") && dict["playbackUv"] != nil {
            self.playbackUv = dict["playbackUv"] as! Int32
        }
        if dict.keys.contains("praiseCount") && dict["praiseCount"] != nil {
            self.praiseCount = dict["praiseCount"] as! Int32
        }
        if dict.keys.contains("pv") && dict["pv"] != nil {
            self.pv = dict["pv"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalWatchTime") && dict["totalWatchTime"] != nil {
            self.totalWatchTime = dict["totalWatchTime"] as! Int64
        }
        if dict.keys.contains("uv") && dict["uv"] != nil {
            self.uv = dict["uv"] as! Int32
        }
    }
}

public class QueryLiveWatchDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveWatchDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLiveWatchDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveWatchUserListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveWatchUserListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryLiveWatchUserListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveWatchUserListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveWatchUserListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantContext: QueryLiveWatchUserListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryLiveWatchUserListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveWatchUserListShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveWatchUserListResponseBody : Tea.TeaModel {
    public class OrgUsesList : Tea.TeaModel {
        public var deptName: String?

        public var name: String?

        public var userId: String?

        public var watchLiveTime: Int64?

        public var watchPlaybackTime: Int64?

        public var watchProgressMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.watchLiveTime != nil {
                map["WatchLiveTime"] = self.watchLiveTime!
            }
            if self.watchPlaybackTime != nil {
                map["WatchPlaybackTime"] = self.watchPlaybackTime!
            }
            if self.watchProgressMs != nil {
                map["WatchProgressMs"] = self.watchProgressMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WatchLiveTime") && dict["WatchLiveTime"] != nil {
                self.watchLiveTime = dict["WatchLiveTime"] as! Int64
            }
            if dict.keys.contains("WatchPlaybackTime") && dict["WatchPlaybackTime"] != nil {
                self.watchPlaybackTime = dict["WatchPlaybackTime"] as! Int64
            }
            if dict.keys.contains("WatchProgressMs") && dict["WatchProgressMs"] != nil {
                self.watchProgressMs = dict["WatchProgressMs"] as! Int64
            }
        }
    }
    public class OutOrgUserList : Tea.TeaModel {
        public var name: String?

        public var watchLiveTime: Int64?

        public var watchPlaybackTime: Int64?

        public var watchProgressMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.watchLiveTime != nil {
                map["WatchLiveTime"] = self.watchLiveTime!
            }
            if self.watchPlaybackTime != nil {
                map["WatchPlaybackTime"] = self.watchPlaybackTime!
            }
            if self.watchProgressMs != nil {
                map["WatchProgressMs"] = self.watchProgressMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WatchLiveTime") && dict["WatchLiveTime"] != nil {
                self.watchLiveTime = dict["WatchLiveTime"] as! Int64
            }
            if dict.keys.contains("WatchPlaybackTime") && dict["WatchPlaybackTime"] != nil {
                self.watchPlaybackTime = dict["WatchPlaybackTime"] as! Int64
            }
            if dict.keys.contains("WatchProgressMs") && dict["WatchProgressMs"] != nil {
                self.watchProgressMs = dict["WatchProgressMs"] as! Int64
            }
        }
    }
    public var orgUsesList: [QueryLiveWatchUserListResponseBody.OrgUsesList]?

    public var outOrgUserList: [QueryLiveWatchUserListResponseBody.OutOrgUserList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgUsesList != nil {
            var tmp : [Any] = []
            for k in self.orgUsesList! {
                tmp.append(k.toMap())
            }
            map["orgUsesList"] = tmp
        }
        if self.outOrgUserList != nil {
            var tmp : [Any] = []
            for k in self.outOrgUserList! {
                tmp.append(k.toMap())
            }
            map["outOrgUserList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("orgUsesList") && dict["orgUsesList"] != nil {
            var tmp : [QueryLiveWatchUserListResponseBody.OrgUsesList] = []
            for v in dict["orgUsesList"] as! [Any] {
                var model = QueryLiveWatchUserListResponseBody.OrgUsesList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orgUsesList = tmp
        }
        if dict.keys.contains("outOrgUserList") && dict["outOrgUserList"] != nil {
            var tmp : [QueryLiveWatchUserListResponseBody.OutOrgUserList] = []
            for v in dict["outOrgUserList"] as! [Any] {
                var model = QueryLiveWatchUserListResponseBody.OutOrgUserList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outOrgUserList = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryLiveWatchUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveWatchUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLiveWatchUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var roomId: String?

    public var tenantContext: QueryMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomShrinkRequest : Tea.TeaModel {
    public var roomId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RoomGroup : Tea.TeaModel {
            public var groupId: Int64?

            public var groupName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public class RoomLabels : Tea.TeaModel {
            public var labelId: Int64?

            public var labelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelId != nil {
                    map["LabelId"] = self.labelId!
                }
                if self.labelName != nil {
                    map["LabelName"] = self.labelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelId") && dict["LabelId"] != nil {
                    self.labelId = dict["LabelId"] as! Int64
                }
                if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                    self.labelName = dict["LabelName"] as! String
                }
            }
        }
        public class RoomLocation : Tea.TeaModel {
            public var desc: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var corpId: String?

        public var isvRoomId: String?

        public var roomCapacity: Int32?

        public var roomGroup: QueryMeetingRoomResponseBody.Result.RoomGroup?

        public var roomId: String?

        public var roomLabels: [QueryMeetingRoomResponseBody.Result.RoomLabels]?

        public var roomLocation: QueryMeetingRoomResponseBody.Result.RoomLocation?

        public var roomName: String?

        public var roomPicture: String?

        public var roomStaffId: String?

        public var roomStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.roomGroup?.validate()
            try self.roomLocation?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.isvRoomId != nil {
                map["IsvRoomId"] = self.isvRoomId!
            }
            if self.roomCapacity != nil {
                map["RoomCapacity"] = self.roomCapacity!
            }
            if self.roomGroup != nil {
                map["RoomGroup"] = self.roomGroup?.toMap()
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomLabels != nil {
                var tmp : [Any] = []
                for k in self.roomLabels! {
                    tmp.append(k.toMap())
                }
                map["RoomLabels"] = tmp
            }
            if self.roomLocation != nil {
                map["RoomLocation"] = self.roomLocation?.toMap()
            }
            if self.roomName != nil {
                map["RoomName"] = self.roomName!
            }
            if self.roomPicture != nil {
                map["RoomPicture"] = self.roomPicture!
            }
            if self.roomStaffId != nil {
                map["RoomStaffId"] = self.roomStaffId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
                self.isvRoomId = dict["IsvRoomId"] as! String
            }
            if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
                self.roomCapacity = dict["RoomCapacity"] as! Int32
            }
            if dict.keys.contains("RoomGroup") && dict["RoomGroup"] != nil {
                var model = QueryMeetingRoomResponseBody.Result.RoomGroup()
                model.fromMap(dict["RoomGroup"] as! [String: Any])
                self.roomGroup = model
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomLabels") && dict["RoomLabels"] != nil {
                var tmp : [QueryMeetingRoomResponseBody.Result.RoomLabels] = []
                for v in dict["RoomLabels"] as! [Any] {
                    var model = QueryMeetingRoomResponseBody.Result.RoomLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roomLabels = tmp
            }
            if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
                var model = QueryMeetingRoomResponseBody.Result.RoomLocation()
                model.fromMap(dict["RoomLocation"] as! [String: Any])
                self.roomLocation = model
            }
            if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
                self.roomName = dict["RoomName"] as! String
            }
            if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
                self.roomPicture = dict["RoomPicture"] as! String
            }
            if dict.keys.contains("RoomStaffId") && dict["RoomStaffId"] != nil {
                self.roomStaffId = dict["RoomStaffId"] as! String
            }
            if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: QueryMeetingRoomResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var model = QueryMeetingRoomResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
    }
}

public class QueryMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var tenantContext: QueryMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var groupId: Int64?

    public var groupName: String?

    public var parentId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["groupName"] = self.groupName!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("groupId") && dict["groupId"] != nil {
            self.groupId = dict["groupId"] as! Int64
        }
        if dict.keys.contains("groupName") && dict["groupName"] != nil {
            self.groupName = dict["groupName"] as! String
        }
        if dict.keys.contains("parentId") && dict["parentId"] != nil {
            self.parentId = dict["parentId"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomGroupListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomGroupListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomGroupListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomGroupListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: QueryMeetingRoomGroupListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomGroupListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomGroupListShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var groupId: Int64?

        public var groupName: String?

        public var parentId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [QueryMeetingRoomGroupListResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [QueryMeetingRoomGroupListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = QueryMeetingRoomGroupListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class QueryMeetingRoomGroupListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomGroupListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomGroupListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: Int64?

    public var tenantContext: QueryMeetingRoomListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomListShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RoomGroup : Tea.TeaModel {
            public var groupId: Int64?

            public var groupName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public class RoomLabels : Tea.TeaModel {
            public var labelId: Int64?

            public var labelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelId != nil {
                    map["LabelId"] = self.labelId!
                }
                if self.labelName != nil {
                    map["LabelName"] = self.labelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelId") && dict["LabelId"] != nil {
                    self.labelId = dict["LabelId"] as! Int64
                }
                if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                    self.labelName = dict["LabelName"] as! String
                }
            }
        }
        public class RoomLocation : Tea.TeaModel {
            public var desc: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var corpId: String?

        public var isvRoomId: String?

        public var roomCapacity: Int32?

        public var roomGroup: QueryMeetingRoomListResponseBody.Result.RoomGroup?

        public var roomId: String?

        public var roomLabels: [QueryMeetingRoomListResponseBody.Result.RoomLabels]?

        public var roomLocation: QueryMeetingRoomListResponseBody.Result.RoomLocation?

        public var roomName: String?

        public var roomPicture: String?

        public var roomStaffId: String?

        public var roomStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.roomGroup?.validate()
            try self.roomLocation?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.isvRoomId != nil {
                map["IsvRoomId"] = self.isvRoomId!
            }
            if self.roomCapacity != nil {
                map["RoomCapacity"] = self.roomCapacity!
            }
            if self.roomGroup != nil {
                map["RoomGroup"] = self.roomGroup?.toMap()
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomLabels != nil {
                var tmp : [Any] = []
                for k in self.roomLabels! {
                    tmp.append(k.toMap())
                }
                map["RoomLabels"] = tmp
            }
            if self.roomLocation != nil {
                map["RoomLocation"] = self.roomLocation?.toMap()
            }
            if self.roomName != nil {
                map["RoomName"] = self.roomName!
            }
            if self.roomPicture != nil {
                map["RoomPicture"] = self.roomPicture!
            }
            if self.roomStaffId != nil {
                map["RoomStaffId"] = self.roomStaffId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
                self.isvRoomId = dict["IsvRoomId"] as! String
            }
            if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
                self.roomCapacity = dict["RoomCapacity"] as! Int32
            }
            if dict.keys.contains("RoomGroup") && dict["RoomGroup"] != nil {
                var model = QueryMeetingRoomListResponseBody.Result.RoomGroup()
                model.fromMap(dict["RoomGroup"] as! [String: Any])
                self.roomGroup = model
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomLabels") && dict["RoomLabels"] != nil {
                var tmp : [QueryMeetingRoomListResponseBody.Result.RoomLabels] = []
                for v in dict["RoomLabels"] as! [Any] {
                    var model = QueryMeetingRoomListResponseBody.Result.RoomLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roomLabels = tmp
            }
            if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
                var model = QueryMeetingRoomListResponseBody.Result.RoomLocation()
                model.fromMap(dict["RoomLocation"] as! [String: Any])
                self.roomLocation = model
            }
            if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
                self.roomName = dict["RoomName"] as! String
            }
            if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
                self.roomPicture = dict["RoomPicture"] as! String
            }
            if dict.keys.contains("RoomStaffId") && dict["RoomStaffId"] != nil {
                self.roomStaffId = dict["RoomStaffId"] as! String
            }
            if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
        }
    }
    public var hasMore: Bool?

    public var nextToken: Int64?

    public var requestId: String?

    public var result: [QueryMeetingRoomListResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [QueryMeetingRoomListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = QueryMeetingRoomListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class QueryMeetingRoomListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrgHonorsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryOrgHonorsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryOrgHonorsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryOrgHonorsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryOrgHonorsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryOrgHonorsRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryOrgHonorsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
    }
}

public class QueryOrgHonorsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
    }
}

public class QueryOrgHonorsResponseBody : Tea.TeaModel {
    public class OpenHonors : Tea.TeaModel {
        public var honorDesc: String?

        public var honorId: Int64?

        public var honorImgUrl: String?

        public var honorName: String?

        public var honorPendantImgUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.honorDesc != nil {
                map["honorDesc"] = self.honorDesc!
            }
            if self.honorId != nil {
                map["honorId"] = self.honorId!
            }
            if self.honorImgUrl != nil {
                map["honorImgUrl"] = self.honorImgUrl!
            }
            if self.honorName != nil {
                map["honorName"] = self.honorName!
            }
            if self.honorPendantImgUrl != nil {
                map["honorPendantImgUrl"] = self.honorPendantImgUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("honorDesc") && dict["honorDesc"] != nil {
                self.honorDesc = dict["honorDesc"] as! String
            }
            if dict.keys.contains("honorId") && dict["honorId"] != nil {
                self.honorId = dict["honorId"] as! Int64
            }
            if dict.keys.contains("honorImgUrl") && dict["honorImgUrl"] != nil {
                self.honorImgUrl = dict["honorImgUrl"] as! String
            }
            if dict.keys.contains("honorName") && dict["honorName"] != nil {
                self.honorName = dict["honorName"] as! String
            }
            if dict.keys.contains("honorPendantImgUrl") && dict["honorPendantImgUrl"] != nil {
                self.honorPendantImgUrl = dict["honorPendantImgUrl"] as! String
            }
        }
    }
    public var nextToken: String?

    public var openHonors: [QueryOrgHonorsResponseBody.OpenHonors]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.openHonors != nil {
            var tmp : [Any] = []
            for k in self.openHonors! {
                tmp.append(k.toMap())
            }
            map["openHonors"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("openHonors") && dict["openHonors"] != nil {
            var tmp : [QueryOrgHonorsResponseBody.OpenHonors] = []
            for v in dict["openHonors"] as! [Any] {
                var model = QueryOrgHonorsResponseBody.OpenHonors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.openHonors = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryOrgHonorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrgHonorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrgHonorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrgTodoTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryOrgTodoTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryOrgTodoTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryOrgTodoTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryOrgTodoTasksRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryOrgTodoTasksRequest.TenantContext?

    public var isDone: Bool?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.isDone != nil {
            map["isDone"] = self.isDone!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryOrgTodoTasksRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("isDone") && dict["isDone"] != nil {
            self.isDone = dict["isDone"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryOrgTodoTasksShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var isDone: Bool?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.isDone != nil {
            map["isDone"] = self.isDone!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("isDone") && dict["isDone"] != nil {
            self.isDone = dict["isDone"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryOrgTodoTasksResponseBody : Tea.TeaModel {
    public class TodoCards : Tea.TeaModel {
        public class DetailUrl : Tea.TeaModel {
            public var appUrl: String?

            public var pcUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appUrl != nil {
                    map["appUrl"] = self.appUrl!
                }
                if self.pcUrl != nil {
                    map["pcUrl"] = self.pcUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("appUrl") && dict["appUrl"] != nil {
                    self.appUrl = dict["appUrl"] as! String
                }
                if dict.keys.contains("pcUrl") && dict["pcUrl"] != nil {
                    self.pcUrl = dict["pcUrl"] as! String
                }
            }
        }
        public var bizTag: String?

        public var createdTime: Int64?

        public var creatorId: String?

        public var detailUrl: QueryOrgTodoTasksResponseBody.TodoCards.DetailUrl?

        public var dueTime: Int64?

        public var isDone: Bool?

        public var modifiedTime: Int64?

        public var priority: Int32?

        public var sourceId: String?

        public var subject: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.detailUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizTag != nil {
                map["bizTag"] = self.bizTag!
            }
            if self.createdTime != nil {
                map["createdTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl?.toMap()
            }
            if self.dueTime != nil {
                map["dueTime"] = self.dueTime!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizTag") && dict["bizTag"] != nil {
                self.bizTag = dict["bizTag"] as! String
            }
            if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
                self.createdTime = dict["createdTime"] as! Int64
            }
            if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
                self.creatorId = dict["creatorId"] as! String
            }
            if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
                var model = QueryOrgTodoTasksResponseBody.TodoCards.DetailUrl()
                model.fromMap(dict["detailUrl"] as! [String: Any])
                self.detailUrl = model
            }
            if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
                self.dueTime = dict["dueTime"] as! Int64
            }
            if dict.keys.contains("isDone") && dict["isDone"] != nil {
                self.isDone = dict["isDone"] as! Bool
            }
            if dict.keys.contains("modifiedTime") && dict["modifiedTime"] != nil {
                self.modifiedTime = dict["modifiedTime"] as! Int64
            }
            if dict.keys.contains("priority") && dict["priority"] != nil {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
                self.sourceId = dict["sourceId"] as! String
            }
            if dict.keys.contains("subject") && dict["subject"] != nil {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("taskId") && dict["taskId"] != nil {
                self.taskId = dict["taskId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var todoCards: [QueryOrgTodoTasksResponseBody.TodoCards]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.todoCards != nil {
            var tmp : [Any] = []
            for k in self.todoCards! {
                tmp.append(k.toMap())
            }
            map["todoCards"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("todoCards") && dict["todoCards"] != nil {
            var tmp : [QueryOrgTodoTasksResponseBody.TodoCards] = []
            for v in dict["todoCards"] as! [Any] {
                var model = QueryOrgTodoTasksResponseBody.TodoCards()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.todoCards = tmp
        }
    }
}

public class QueryOrgTodoTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrgTodoTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrgTodoTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var requestUnionId: String?

    public var tenantContext: QueryScheduleConferenceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestUnionId != nil {
            map["RequestUnionId"] = self.requestUnionId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestUnionId") && dict["RequestUnionId"] != nil {
            self.requestUnionId = dict["RequestUnionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var requestUnionId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestUnionId != nil {
            map["RequestUnionId"] = self.requestUnionId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestUnionId") && dict["RequestUnionId"] != nil {
            self.requestUnionId = dict["RequestUnionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryScheduleConferenceResponseBody : Tea.TeaModel {
    public var endTime: Int64?

    public var phones: [String]?

    public var requestId: String?

    public var roomCode: String?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var title: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.phones != nil {
            map["phones"] = self.phones!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("phones") && dict["phones"] != nil {
            self.phones = dict["phones"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") && dict["roomCode"] != nil {
            self.roomCode = dict["roomCode"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") && dict["scheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class QueryScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUserHonorsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryUserHonorsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryUserHonorsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryUserHonorsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryUserHonorsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryUserHonorsRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryUserHonorsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class QueryUserHonorsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class QueryUserHonorsResponseBody : Tea.TeaModel {
    public class Honors : Tea.TeaModel {
        public class GrantHistory : Tea.TeaModel {
            public var grantTime: Int64?

            public var senderUserid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.grantTime != nil {
                    map["grantTime"] = self.grantTime!
                }
                if self.senderUserid != nil {
                    map["senderUserid"] = self.senderUserid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("grantTime") && dict["grantTime"] != nil {
                    self.grantTime = dict["grantTime"] as! Int64
                }
                if dict.keys.contains("senderUserid") && dict["senderUserid"] != nil {
                    self.senderUserid = dict["senderUserid"] as! String
                }
            }
        }
        public var expirationTime: Int64?

        public var grantHistory: [QueryUserHonorsResponseBody.Honors.GrantHistory]?

        public var honorDesc: String?

        public var honorId: String?

        public var honorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationTime != nil {
                map["expirationTime"] = self.expirationTime!
            }
            if self.grantHistory != nil {
                var tmp : [Any] = []
                for k in self.grantHistory! {
                    tmp.append(k.toMap())
                }
                map["grantHistory"] = tmp
            }
            if self.honorDesc != nil {
                map["honorDesc"] = self.honorDesc!
            }
            if self.honorId != nil {
                map["honorId"] = self.honorId!
            }
            if self.honorName != nil {
                map["honorName"] = self.honorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("expirationTime") && dict["expirationTime"] != nil {
                self.expirationTime = dict["expirationTime"] as! Int64
            }
            if dict.keys.contains("grantHistory") && dict["grantHistory"] != nil {
                var tmp : [QueryUserHonorsResponseBody.Honors.GrantHistory] = []
                for v in dict["grantHistory"] as! [Any] {
                    var model = QueryUserHonorsResponseBody.Honors.GrantHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.grantHistory = tmp
            }
            if dict.keys.contains("honorDesc") && dict["honorDesc"] != nil {
                self.honorDesc = dict["honorDesc"] as! String
            }
            if dict.keys.contains("honorId") && dict["honorId"] != nil {
                self.honorId = dict["honorId"] as! String
            }
            if dict.keys.contains("honorName") && dict["honorName"] != nil {
                self.honorName = dict["honorName"] as! String
            }
        }
    }
    public var honors: [QueryUserHonorsResponseBody.Honors]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honors != nil {
            var tmp : [Any] = []
            for k in self.honors! {
                tmp.append(k.toMap())
            }
            map["honors"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("honors") && dict["honors"] != nil {
            var tmp : [QueryUserHonorsResponseBody.Honors] = []
            for v in dict["honors"] as! [Any] {
                var model = QueryUserHonorsResponseBody.Honors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honors = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryUserHonorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUserHonorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUserHonorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecallHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RecallHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RecallHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RecallHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RecallHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: RecallHonorRequest.TenantContext?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = RecallHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class RecallHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class RecallHonorResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") && dict["data"] != nil {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: RecallHonorResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") && dict["content"] != nil {
            var model = RecallHonorResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") && dict["errorCode"] != nil {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") && dict["errorCtx"] != nil {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") && dict["errorMsg"] != nil {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") && dict["httpStatusCode"] != nil {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class RecallHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecallHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RecallHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReceiverListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ReceiverListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ReceiverListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ReceiverListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ReceiverListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: ReceiverListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ReceiverListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ReceiverListReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ReceiverListReportResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var useridList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.useridList != nil {
            map["useridList"] = self.useridList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("useridList") && dict["useridList"] != nil {
            self.useridList = dict["useridList"] as! [String]
        }
    }
}

public class ReceiverListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReceiverListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReceiverListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAttendeeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RemoveAttendeeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RemoveAttendeeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RemoveAttendeeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RemoveAttendeeRequest : Tea.TeaModel {
    public var attendeesToRemove: [String]?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToRemove != nil {
            map["AttendeesToRemove"] = self.attendeesToRemove!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToRemove") && dict["AttendeesToRemove"] != nil {
            self.attendeesToRemove = dict["AttendeesToRemove"] as! [String]
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class RemoveAttendeeShrinkRequest : Tea.TeaModel {
    public var attendeesToRemoveShrink: String?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToRemoveShrink != nil {
            map["AttendeesToRemove"] = self.attendeesToRemoveShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToRemove") && dict["AttendeesToRemove"] != nil {
            self.attendeesToRemoveShrink = dict["AttendeesToRemove"] as! String
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class RemoveAttendeeResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! Any
            }
        }
    }
    public var content: RemoveAttendeeResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["ErrorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            var model = RemoveAttendeeResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorCtx") && dict["ErrorCtx"] != nil {
            self.errorCtx = dict["ErrorCtx"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveAttendeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAttendeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAttendeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveMeetingRoomsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RemoveMeetingRoomsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RemoveMeetingRoomsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RemoveMeetingRoomsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RemoveMeetingRoomsRequest : Tea.TeaModel {
    public class MeetingRoomsToRemove : Tea.TeaModel {
        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToRemove: [RemoveMeetingRoomsRequest.MeetingRoomsToRemove]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToRemove != nil {
            var tmp : [Any] = []
            for k in self.meetingRoomsToRemove! {
                tmp.append(k.toMap())
            }
            map["MeetingRoomsToRemove"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToRemove") && dict["MeetingRoomsToRemove"] != nil {
            var tmp : [RemoveMeetingRoomsRequest.MeetingRoomsToRemove] = []
            for v in dict["MeetingRoomsToRemove"] as! [Any] {
                var model = RemoveMeetingRoomsRequest.MeetingRoomsToRemove()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRoomsToRemove = tmp
        }
    }
}

public class RemoveMeetingRoomsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToRemoveShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToRemoveShrink != nil {
            map["MeetingRoomsToRemove"] = self.meetingRoomsToRemoveShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToRemove") && dict["MeetingRoomsToRemove"] != nil {
            self.meetingRoomsToRemoveShrink = dict["MeetingRoomsToRemove"] as! String
        }
    }
}

public class RemoveMeetingRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class RemoveMeetingRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveMeetingRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveMeetingRoomsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveContentHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveContentHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SaveContentHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveContentShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveContentRequest : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var content: String?

        public var contentType: String?

        public var key: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var contents: [SaveContentRequest.Contents]?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContext: SaveContentRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            var tmp : [SaveContentRequest.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = SaveContentRequest.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SaveContentRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SaveContentShrinkRequest : Tea.TeaModel {
    public var contentsShrink: String?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentsShrink != nil {
            map["Contents"] = self.contentsShrink!
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            self.contentsShrink = dict["Contents"] as! String
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SaveContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SaveContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetColumnsVisibilityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetColumnsVisibilityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SetColumnsVisibilityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetColumnsVisibilityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetColumnsVisibilityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: SetColumnsVisibilityRequest.TenantContext?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SetColumnsVisibilityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetColumnsVisibilityShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetColumnsVisibilityResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SetColumnsVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetColumnsVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetColumnsVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetRowsVisibilityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetRowsVisibilityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SetRowsVisibilityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetRowsVisibilityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetRowsVisibilityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: SetRowsVisibilityRequest.TenantContext?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SetRowsVisibilityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetRowsVisibilityShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetRowsVisibilityResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SetRowsVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetRowsVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetRowsVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SimpleListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SimpleListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SimpleListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SimpleListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SimpleListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var cursor: Int64?

    public var endTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContext: SimpleListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SimpleListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SimpleListReportShrinkRequest : Tea.TeaModel {
    public var cursor: Int64?

    public var endTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SimpleListReportResponseBody : Tea.TeaModel {
    public class DataList : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorId: String?

        public var creatorName: String?

        public var deptName: String?

        public var remark: String?

        public var reportId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorName") && dict["CreatorName"] != nil {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var dataList: [SimpleListReportResponseBody.DataList]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataList != nil {
            var tmp : [Any] = []
            for k in self.dataList! {
                tmp.append(k.toMap())
            }
            map["dataList"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataList") && dict["dataList"] != nil {
            var tmp : [SimpleListReportResponseBody.DataList] = []
            for v in dict["dataList"] as! [Any] {
                var model = SimpleListReportResponseBody.DataList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataList = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int64
        }
    }
}

public class SimpleListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SimpleListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SimpleListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartCloudRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StartCloudRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StartCloudRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StartCloudRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StartCloudRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var mode: String?

    public var smallWindowPosition: String?

    public var tenantContext: StartCloudRecordRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.smallWindowPosition != nil {
            map["SmallWindowPosition"] = self.smallWindowPosition!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SmallWindowPosition") && dict["SmallWindowPosition"] != nil {
            self.smallWindowPosition = dict["SmallWindowPosition"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StartCloudRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StartCloudRecordShrinkRequest : Tea.TeaModel {
    public var mode: String?

    public var smallWindowPosition: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.smallWindowPosition != nil {
            map["SmallWindowPosition"] = self.smallWindowPosition!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SmallWindowPosition") && dict["SmallWindowPosition"] != nil {
            self.smallWindowPosition = dict["SmallWindowPosition"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StartCloudRecordResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") && dict["code"] != nil {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StartCloudRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCloudRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartCloudRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StatisticsListByTypeReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StatisticsListByTypeReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StatisticsListByTypeReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StatisticsListByTypeReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StatisticsListByTypeReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: StatisticsListByTypeReportRequest.TenantContext?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StatisticsListByTypeReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class StatisticsListByTypeReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class StatisticsListByTypeReportResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var useridList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.useridList != nil {
            map["useridList"] = self.useridList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("useridList") && dict["useridList"] != nil {
            self.useridList = dict["useridList"] as! [String]
        }
    }
}

public class StatisticsListByTypeReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StatisticsListByTypeReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StatisticsListByTypeReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StatisticsReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StatisticsReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StatisticsReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StatisticsReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StatisticsReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var reportId: String?

    public var tenantContext: StatisticsReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StatisticsReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class StatisticsReportShrinkRequest : Tea.TeaModel {
    public var reportId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class StatisticsReportResponseBody : Tea.TeaModel {
    public var commentNum: Int64?

    public var commentUserNum: Int64?

    public var likeNum: Int64?

    public var readNum: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentNum != nil {
            map["commentNum"] = self.commentNum!
        }
        if self.commentUserNum != nil {
            map["commentUserNum"] = self.commentUserNum!
        }
        if self.likeNum != nil {
            map["likeNum"] = self.likeNum!
        }
        if self.readNum != nil {
            map["readNum"] = self.readNum!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commentNum") && dict["commentNum"] != nil {
            self.commentNum = dict["commentNum"] as! Int64
        }
        if dict.keys.contains("commentUserNum") && dict["commentUserNum"] != nil {
            self.commentUserNum = dict["commentUserNum"] as! Int64
        }
        if dict.keys.contains("likeNum") && dict["likeNum"] != nil {
            self.likeNum = dict["likeNum"] as! Int64
        }
        if dict.keys.contains("readNum") && dict["readNum"] != nil {
            self.readNum = dict["readNum"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StatisticsReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StatisticsReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StatisticsReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopCloudRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StopCloudRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StopCloudRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StopCloudRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StopCloudRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: StopCloudRecordRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StopCloudRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopCloudRecordShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopCloudRecordResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") && dict["code"] != nil {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StopCloudRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCloudRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopCloudRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubscribeCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SubscribeCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SubscribeCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SubscribeCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SubscribeCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class SubscribeCalendarResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SubscribeCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubscribeCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubscribeCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnsubscribeCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UnsubscribeCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UnsubscribeCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UnsubscribeCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UnsubscribeCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class UnsubscribeCalendarResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UnsubscribeCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnsubscribeCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnsubscribeCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var coverUrl: String?

    public var introduction: String?

    public var liveId: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var tenantContext: UpdateLiveRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateLiveShrinkRequest : Tea.TeaModel {
    public var coverUrl: String?

    public var introduction: String?

    public var liveId: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateLiveResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateMeetingRoomRequest : Tea.TeaModel {
    public class RoomLocation : Tea.TeaModel {
        public var desc: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: Int64?

    public var isvRoomId: String?

    public var roomCapacity: Int32?

    public var roomId: String?

    public var roomLabelIds: [Int64]?

    public var roomLocation: UpdateMeetingRoomRequest.RoomLocation?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContext: UpdateMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.roomLocation?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomLabelIds != nil {
            map["RoomLabelIds"] = self.roomLabelIds!
        }
        if self.roomLocation != nil {
            map["RoomLocation"] = self.roomLocation?.toMap()
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIds = dict["RoomLabelIds"] as! [Int64]
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            var model = UpdateMeetingRoomRequest.RoomLocation()
            model.fromMap(dict["RoomLocation"] as! [String: Any])
            self.roomLocation = model
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateMeetingRoomShrinkRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var isvRoomId: String?

    public var roomCapacity: Int32?

    public var roomId: String?

    public var roomLabelIdsShrink: String?

    public var roomLocationShrink: String?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomLabelIdsShrink != nil {
            map["RoomLabelIds"] = self.roomLabelIdsShrink!
        }
        if self.roomLocationShrink != nil {
            map["RoomLocation"] = self.roomLocationShrink!
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIdsShrink = dict["RoomLabelIds"] as! String
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            self.roomLocationShrink = dict["RoomLocation"] as! String
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateMeetingRoomResponseBody : Tea.TeaModel {
    public var result: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var groupName: String?

    public var tenantContext: UpdateMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRangeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateRangeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateRangeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateRangeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateRangeRequest : Tea.TeaModel {
    public class Hyperlinks : Tea.TeaModel {
        public var type: String?

        public var link: String?

        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Text") && dict["Text"] != nil {
                self.text = dict["Text"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var backgroundColors: [[String]]?

    public var hyperlinks: [[UpdateRangeRequest.Hyperlinks]]?

    public var numberFormat: String?

    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: UpdateRangeRequest.TenantContext?

    public var values: [[String]]?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColors != nil {
            map["BackgroundColors"] = self.backgroundColors!
        }
        if self.hyperlinks != nil {
            var tmp : [Any] = []
            for k in self.hyperlinks! {
                var l1 : [Any] = []
                for k1 in k {
                    l1.append(k1.toMap())
                }
                tmp.append(l1)
            }
            map["Hyperlinks"] = tmp
        }
        if self.numberFormat != nil {
            map["NumberFormat"] = self.numberFormat!
        }
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackgroundColors") && dict["BackgroundColors"] != nil {
            self.backgroundColors = dict["BackgroundColors"] as! [[String]]
        }
        if dict.keys.contains("Hyperlinks") && dict["Hyperlinks"] != nil {
            var tmp : [[UpdateRangeRequest.Hyperlinks]] = []
            for v in dict["Hyperlinks"] as! [Any] {
                var l1 : [UpdateRangeRequest.Hyperlinks] = []
                for v1 in v as! [Any] {
                    var model = UpdateRangeRequest.Hyperlinks()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp.append(l1)
            }
            self.hyperlinks = tmp
        }
        if dict.keys.contains("NumberFormat") && dict["NumberFormat"] != nil {
            self.numberFormat = dict["NumberFormat"] as! String
        }
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateRangeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.values = dict["Values"] as! [[String]]
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class UpdateRangeShrinkRequest : Tea.TeaModel {
    public var backgroundColorsShrink: String?

    public var hyperlinksShrink: String?

    public var numberFormat: String?

    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var valuesShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColorsShrink != nil {
            map["BackgroundColors"] = self.backgroundColorsShrink!
        }
        if self.hyperlinksShrink != nil {
            map["Hyperlinks"] = self.hyperlinksShrink!
        }
        if self.numberFormat != nil {
            map["NumberFormat"] = self.numberFormat!
        }
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.valuesShrink != nil {
            map["Values"] = self.valuesShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackgroundColors") && dict["BackgroundColors"] != nil {
            self.backgroundColorsShrink = dict["BackgroundColors"] as! String
        }
        if dict.keys.contains("Hyperlinks") && dict["Hyperlinks"] != nil {
            self.hyperlinksShrink = dict["Hyperlinks"] as! String
        }
        if dict.keys.contains("NumberFormat") && dict["NumberFormat"] != nil {
            self.numberFormat = dict["NumberFormat"] as! String
        }
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.valuesShrink = dict["Values"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class UpdateRangeResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") && dict["a1Notation"] != nil {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var tenantContext: UpdateScheduleConferenceRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateScheduleConferenceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSubscribedCalendarsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateSubscribedCalendarsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateSubscribedCalendarsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateSubscribedCalendarsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateSubscribedCalendarsRequest : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var calendarId: String?

    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var subscribeScope: UpdateSubscribedCalendarsRequest.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScope != nil {
            map["SubscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managers = dict["Managers"] as! [String]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            var model = UpdateSubscribedCalendarsRequest.SubscribeScope()
            model.fromMap(dict["SubscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class UpdateSubscribedCalendarsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var description_: String?

    public var managersShrink: String?

    public var name: String?

    public var subscribeScopeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScopeShrink != nil {
            map["SubscribeScope"] = self.subscribeScopeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managersShrink = dict["Managers"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            self.subscribeScopeShrink = dict["SubscribeScope"] as! String
        }
    }
}

public class UpdateSubscribedCalendarsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateSubscribedCalendarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSubscribedCalendarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSubscribedCalendarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: UpdateTodoTaskRequest.TenantContext?

    public var description_: String?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var participantIds: [String]?

    public var subject: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("done") && dict["done"] != nil {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var description_: String?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var participantIdsShrink: String?

    public var subject: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["executorIds"] = self.executorIdsShrink!
        }
        if self.participantIdsShrink != nil {
            map["participantIds"] = self.participantIdsShrink!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("done") && dict["done"] != nil {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIdsShrink = dict["executorIds"] as! String
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIdsShrink = dict["participantIds"] as! String
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTodoTaskExecutorStatusHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateTodoTaskExecutorStatusHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateTodoTaskExecutorStatusHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateTodoTaskExecutorStatusShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class ExecutorStatusList : Tea.TeaModel {
        public var id: String?

        public var isDone: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isDone") && dict["isDone"] != nil {
                self.isDone = dict["isDone"] as! Bool
            }
        }
    }
    public var tenantContext: UpdateTodoTaskExecutorStatusRequest.TenantContext?

    public var executorStatusList: [UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList]?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.executorStatusList != nil {
            var tmp : [Any] = []
            for k in self.executorStatusList! {
                tmp.append(k.toMap())
            }
            map["executorStatusList"] = tmp
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateTodoTaskExecutorStatusRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("executorStatusList") && dict["executorStatusList"] != nil {
            var tmp : [UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList] = []
            for v in dict["executorStatusList"] as! [Any] {
                var model = UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.executorStatusList = tmp
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var executorStatusListShrink: String?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.executorStatusListShrink != nil {
            map["executorStatusList"] = self.executorStatusListShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("executorStatusList") && dict["executorStatusList"] != nil {
            self.executorStatusListShrink = dict["executorStatusList"] as! String
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateTodoTaskExecutorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTodoTaskExecutorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTodoTaskExecutorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [UpdateWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: UpdateWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [UpdateWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = UpdateWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [UpdateWorkspaceMembersRequest.Members]?

    public var tenantContext: UpdateWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [UpdateWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = UpdateWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UploadMediaHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UploadMediaHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UploadMediaShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UploadMediaRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: UploadMediaRequest.TenantContext?

    public var mediaName: String?

    public var mediaType: String?

    public var orgId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.mediaName != nil {
            map["mediaName"] = self.mediaName!
        }
        if self.mediaType != nil {
            map["mediaType"] = self.mediaType!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UploadMediaRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("mediaName") && dict["mediaName"] != nil {
            self.mediaName = dict["mediaName"] as! String
        }
        if dict.keys.contains("mediaType") && dict["mediaType"] != nil {
            self.mediaType = dict["mediaType"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class UploadMediaShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var mediaName: String?

    public var mediaType: String?

    public var orgId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.mediaName != nil {
            map["mediaName"] = self.mediaName!
        }
        if self.mediaType != nil {
            map["mediaType"] = self.mediaType!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("mediaName") && dict["mediaName"] != nil {
            self.mediaName = dict["mediaName"] as! String
        }
        if dict.keys.contains("mediaType") && dict["mediaType"] != nil {
            self.mediaType = dict["mediaType"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class UploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["mediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("mediaId") && dict["mediaId"] != nil {
            self.mediaId = dict["mediaId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WearOrgHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: WearOrgHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = WearOrgHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class WearOrgHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class WearOrgHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: WearOrgHonorRequest.TenantContext?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public var wear: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.wear != nil {
            map["wear"] = self.wear!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = WearOrgHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("wear") && dict["wear"] != nil {
            self.wear = dict["wear"] as! Bool
        }
    }
}

public class WearOrgHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public var wear: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.wear != nil {
            map["wear"] = self.wear!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("wear") && dict["wear"] != nil {
            self.wear = dict["wear"] as! Bool
        }
    }
}

public class WearOrgHonorResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") && dict["data"] != nil {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: WearOrgHonorResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") && dict["content"] != nil {
            var model = WearOrgHonorResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") && dict["errorCode"] != nil {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") && dict["errorCtx"] != nil {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") && dict["errorMsg"] != nil {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") && dict["httpStatusCode"] != nil {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class WearOrgHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WearOrgHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = WearOrgHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
